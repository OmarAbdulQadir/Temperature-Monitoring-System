
NTI_RTOS_PROJ_TempMonitorSys.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00009a32  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001b8  00800060  00009a32  00009ac6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002bb  00800218  00800218  00009c7e  2**0
                  ALLOC
  3 .stab         0000b814  00000000  00000000  00009c80  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005f82  00000000  00000000  00015494  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001c0  00000000  00000000  0001b416  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000214  00000000  00000000  0001b5d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002612  00000000  00000000  0001b7ea  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000014ce  00000000  00000000  0001ddfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000130b  00000000  00000000  0001f2ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001e0  00000000  00000000  000205d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000307  00000000  00000000  000207b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000a1a  00000000  00000000  00020abf  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000214d9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 de 11 	jmp	0x23bc	; 0x23bc <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 c0 24 	jmp	0x4980	; 0x4980 <__vector_13>
      38:	0c 94 f6 24 	jmp	0x49ec	; 0x49ec <__vector_14>
      3c:	0c 94 06 25 	jmp	0x4a0c	; 0x4a0c <__vector_15>
      40:	0c 94 1a 29 	jmp	0x5234	; 0x5234 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e3       	ldi	r30, 0x32	; 50
      68:	fa e9       	ldi	r31, 0x9A	; 154
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 31       	cpi	r26, 0x18	; 24
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a8 e1       	ldi	r26, 0x18	; 24
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3d       	cpi	r26, 0xD3	; 211
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 01 0a 	call	0x1402	; 0x1402 <main>
      8a:	0c 94 17 4d 	jmp	0x9a2e	; 0x9a2e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 d7 4c 	jmp	0x99ae	; 0x99ae <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a6 ee       	ldi	r26, 0xE6	; 230
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 f3 4c 	jmp	0x99e6	; 0x99e6 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 e3 4c 	jmp	0x99c6	; 0x99c6 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 ff 4c 	jmp	0x99fe	; 0x99fe <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 e3 4c 	jmp	0x99c6	; 0x99c6 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 ff 4c 	jmp	0x99fe	; 0x99fe <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 d7 4c 	jmp	0x99ae	; 0x99ae <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	86 ee       	ldi	r24, 0xE6	; 230
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 f3 4c 	jmp	0x99e6	; 0x99e6 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 df 4c 	jmp	0x99be	; 0x99be <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	66 ee       	ldi	r22, 0xE6	; 230
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 fb 4c 	jmp	0x99f6	; 0x99f6 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 e3 4c 	jmp	0x99c6	; 0x99c6 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 ff 4c 	jmp	0x99fe	; 0x99fe <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 e3 4c 	jmp	0x99c6	; 0x99c6 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 ff 4c 	jmp	0x99fe	; 0x99fe <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 e3 4c 	jmp	0x99c6	; 0x99c6 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 ff 4c 	jmp	0x99fe	; 0x99fe <__epilogue_restores__+0x18>

000008aa <__floatsisf>:
     8aa:	a8 e0       	ldi	r26, 0x08	; 8
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 e0 4c 	jmp	0x99c0	; 0x99c0 <__prologue_saves__+0x12>
     8b6:	9b 01       	movw	r18, r22
     8b8:	ac 01       	movw	r20, r24
     8ba:	83 e0       	ldi	r24, 0x03	; 3
     8bc:	89 83       	std	Y+1, r24	; 0x01
     8be:	da 01       	movw	r26, r20
     8c0:	c9 01       	movw	r24, r18
     8c2:	88 27       	eor	r24, r24
     8c4:	b7 fd       	sbrc	r27, 7
     8c6:	83 95       	inc	r24
     8c8:	99 27       	eor	r25, r25
     8ca:	aa 27       	eor	r26, r26
     8cc:	bb 27       	eor	r27, r27
     8ce:	b8 2e       	mov	r11, r24
     8d0:	21 15       	cp	r18, r1
     8d2:	31 05       	cpc	r19, r1
     8d4:	41 05       	cpc	r20, r1
     8d6:	51 05       	cpc	r21, r1
     8d8:	19 f4       	brne	.+6      	; 0x8e0 <__floatsisf+0x36>
     8da:	82 e0       	ldi	r24, 0x02	; 2
     8dc:	89 83       	std	Y+1, r24	; 0x01
     8de:	3a c0       	rjmp	.+116    	; 0x954 <__floatsisf+0xaa>
     8e0:	88 23       	and	r24, r24
     8e2:	a9 f0       	breq	.+42     	; 0x90e <__floatsisf+0x64>
     8e4:	20 30       	cpi	r18, 0x00	; 0
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	38 07       	cpc	r19, r24
     8ea:	80 e0       	ldi	r24, 0x00	; 0
     8ec:	48 07       	cpc	r20, r24
     8ee:	80 e8       	ldi	r24, 0x80	; 128
     8f0:	58 07       	cpc	r21, r24
     8f2:	29 f4       	brne	.+10     	; 0x8fe <__floatsisf+0x54>
     8f4:	60 e0       	ldi	r22, 0x00	; 0
     8f6:	70 e0       	ldi	r23, 0x00	; 0
     8f8:	80 e0       	ldi	r24, 0x00	; 0
     8fa:	9f ec       	ldi	r25, 0xCF	; 207
     8fc:	30 c0       	rjmp	.+96     	; 0x95e <__floatsisf+0xb4>
     8fe:	ee 24       	eor	r14, r14
     900:	ff 24       	eor	r15, r15
     902:	87 01       	movw	r16, r14
     904:	e2 1a       	sub	r14, r18
     906:	f3 0a       	sbc	r15, r19
     908:	04 0b       	sbc	r16, r20
     90a:	15 0b       	sbc	r17, r21
     90c:	02 c0       	rjmp	.+4      	; 0x912 <__floatsisf+0x68>
     90e:	79 01       	movw	r14, r18
     910:	8a 01       	movw	r16, r20
     912:	8e e1       	ldi	r24, 0x1E	; 30
     914:	c8 2e       	mov	r12, r24
     916:	d1 2c       	mov	r13, r1
     918:	dc 82       	std	Y+4, r13	; 0x04
     91a:	cb 82       	std	Y+3, r12	; 0x03
     91c:	ed 82       	std	Y+5, r14	; 0x05
     91e:	fe 82       	std	Y+6, r15	; 0x06
     920:	0f 83       	std	Y+7, r16	; 0x07
     922:	18 87       	std	Y+8, r17	; 0x08
     924:	c8 01       	movw	r24, r16
     926:	b7 01       	movw	r22, r14
     928:	0e 94 80 05 	call	0xb00	; 0xb00 <__clzsi2>
     92c:	01 97       	sbiw	r24, 0x01	; 1
     92e:	18 16       	cp	r1, r24
     930:	19 06       	cpc	r1, r25
     932:	84 f4       	brge	.+32     	; 0x954 <__floatsisf+0xaa>
     934:	08 2e       	mov	r0, r24
     936:	04 c0       	rjmp	.+8      	; 0x940 <__floatsisf+0x96>
     938:	ee 0c       	add	r14, r14
     93a:	ff 1c       	adc	r15, r15
     93c:	00 1f       	adc	r16, r16
     93e:	11 1f       	adc	r17, r17
     940:	0a 94       	dec	r0
     942:	d2 f7       	brpl	.-12     	; 0x938 <__floatsisf+0x8e>
     944:	ed 82       	std	Y+5, r14	; 0x05
     946:	fe 82       	std	Y+6, r15	; 0x06
     948:	0f 83       	std	Y+7, r16	; 0x07
     94a:	18 87       	std	Y+8, r17	; 0x08
     94c:	c8 1a       	sub	r12, r24
     94e:	d9 0a       	sbc	r13, r25
     950:	dc 82       	std	Y+4, r13	; 0x04
     952:	cb 82       	std	Y+3, r12	; 0x03
     954:	ba 82       	std	Y+2, r11	; 0x02
     956:	ce 01       	movw	r24, r28
     958:	01 96       	adiw	r24, 0x01	; 1
     95a:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     95e:	28 96       	adiw	r28, 0x08	; 8
     960:	e9 e0       	ldi	r30, 0x09	; 9
     962:	0c 94 fc 4c 	jmp	0x99f8	; 0x99f8 <__epilogue_restores__+0x12>

00000966 <__fixsfsi>:
     966:	ac e0       	ldi	r26, 0x0C	; 12
     968:	b0 e0       	ldi	r27, 0x00	; 0
     96a:	e9 eb       	ldi	r30, 0xB9	; 185
     96c:	f4 e0       	ldi	r31, 0x04	; 4
     96e:	0c 94 e7 4c 	jmp	0x99ce	; 0x99ce <__prologue_saves__+0x20>
     972:	69 83       	std	Y+1, r22	; 0x01
     974:	7a 83       	std	Y+2, r23	; 0x02
     976:	8b 83       	std	Y+3, r24	; 0x03
     978:	9c 83       	std	Y+4, r25	; 0x04
     97a:	ce 01       	movw	r24, r28
     97c:	01 96       	adiw	r24, 0x01	; 1
     97e:	be 01       	movw	r22, r28
     980:	6b 5f       	subi	r22, 0xFB	; 251
     982:	7f 4f       	sbci	r23, 0xFF	; 255
     984:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     988:	8d 81       	ldd	r24, Y+5	; 0x05
     98a:	82 30       	cpi	r24, 0x02	; 2
     98c:	61 f1       	breq	.+88     	; 0x9e6 <__fixsfsi+0x80>
     98e:	82 30       	cpi	r24, 0x02	; 2
     990:	50 f1       	brcs	.+84     	; 0x9e6 <__fixsfsi+0x80>
     992:	84 30       	cpi	r24, 0x04	; 4
     994:	21 f4       	brne	.+8      	; 0x99e <__fixsfsi+0x38>
     996:	8e 81       	ldd	r24, Y+6	; 0x06
     998:	88 23       	and	r24, r24
     99a:	51 f1       	breq	.+84     	; 0x9f0 <__fixsfsi+0x8a>
     99c:	2e c0       	rjmp	.+92     	; 0x9fa <__fixsfsi+0x94>
     99e:	2f 81       	ldd	r18, Y+7	; 0x07
     9a0:	38 85       	ldd	r19, Y+8	; 0x08
     9a2:	37 fd       	sbrc	r19, 7
     9a4:	20 c0       	rjmp	.+64     	; 0x9e6 <__fixsfsi+0x80>
     9a6:	6e 81       	ldd	r22, Y+6	; 0x06
     9a8:	2f 31       	cpi	r18, 0x1F	; 31
     9aa:	31 05       	cpc	r19, r1
     9ac:	1c f0       	brlt	.+6      	; 0x9b4 <__fixsfsi+0x4e>
     9ae:	66 23       	and	r22, r22
     9b0:	f9 f0       	breq	.+62     	; 0x9f0 <__fixsfsi+0x8a>
     9b2:	23 c0       	rjmp	.+70     	; 0x9fa <__fixsfsi+0x94>
     9b4:	8e e1       	ldi	r24, 0x1E	; 30
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	82 1b       	sub	r24, r18
     9ba:	93 0b       	sbc	r25, r19
     9bc:	29 85       	ldd	r18, Y+9	; 0x09
     9be:	3a 85       	ldd	r19, Y+10	; 0x0a
     9c0:	4b 85       	ldd	r20, Y+11	; 0x0b
     9c2:	5c 85       	ldd	r21, Y+12	; 0x0c
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__fixsfsi+0x68>
     9c6:	56 95       	lsr	r21
     9c8:	47 95       	ror	r20
     9ca:	37 95       	ror	r19
     9cc:	27 95       	ror	r18
     9ce:	8a 95       	dec	r24
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__fixsfsi+0x60>
     9d2:	66 23       	and	r22, r22
     9d4:	b1 f0       	breq	.+44     	; 0xa02 <__fixsfsi+0x9c>
     9d6:	50 95       	com	r21
     9d8:	40 95       	com	r20
     9da:	30 95       	com	r19
     9dc:	21 95       	neg	r18
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	4f 4f       	sbci	r20, 0xFF	; 255
     9e2:	5f 4f       	sbci	r21, 0xFF	; 255
     9e4:	0e c0       	rjmp	.+28     	; 0xa02 <__fixsfsi+0x9c>
     9e6:	20 e0       	ldi	r18, 0x00	; 0
     9e8:	30 e0       	ldi	r19, 0x00	; 0
     9ea:	40 e0       	ldi	r20, 0x00	; 0
     9ec:	50 e0       	ldi	r21, 0x00	; 0
     9ee:	09 c0       	rjmp	.+18     	; 0xa02 <__fixsfsi+0x9c>
     9f0:	2f ef       	ldi	r18, 0xFF	; 255
     9f2:	3f ef       	ldi	r19, 0xFF	; 255
     9f4:	4f ef       	ldi	r20, 0xFF	; 255
     9f6:	5f e7       	ldi	r21, 0x7F	; 127
     9f8:	04 c0       	rjmp	.+8      	; 0xa02 <__fixsfsi+0x9c>
     9fa:	20 e0       	ldi	r18, 0x00	; 0
     9fc:	30 e0       	ldi	r19, 0x00	; 0
     9fe:	40 e0       	ldi	r20, 0x00	; 0
     a00:	50 e8       	ldi	r21, 0x80	; 128
     a02:	b9 01       	movw	r22, r18
     a04:	ca 01       	movw	r24, r20
     a06:	2c 96       	adiw	r28, 0x0c	; 12
     a08:	e2 e0       	ldi	r30, 0x02	; 2
     a0a:	0c 94 03 4d 	jmp	0x9a06	; 0x9a06 <__epilogue_restores__+0x20>

00000a0e <__floatunsisf>:
     a0e:	a8 e0       	ldi	r26, 0x08	; 8
     a10:	b0 e0       	ldi	r27, 0x00	; 0
     a12:	ed e0       	ldi	r30, 0x0D	; 13
     a14:	f5 e0       	ldi	r31, 0x05	; 5
     a16:	0c 94 df 4c 	jmp	0x99be	; 0x99be <__prologue_saves__+0x10>
     a1a:	7b 01       	movw	r14, r22
     a1c:	8c 01       	movw	r16, r24
     a1e:	61 15       	cp	r22, r1
     a20:	71 05       	cpc	r23, r1
     a22:	81 05       	cpc	r24, r1
     a24:	91 05       	cpc	r25, r1
     a26:	19 f4       	brne	.+6      	; 0xa2e <__floatunsisf+0x20>
     a28:	82 e0       	ldi	r24, 0x02	; 2
     a2a:	89 83       	std	Y+1, r24	; 0x01
     a2c:	60 c0       	rjmp	.+192    	; 0xaee <__floatunsisf+0xe0>
     a2e:	83 e0       	ldi	r24, 0x03	; 3
     a30:	89 83       	std	Y+1, r24	; 0x01
     a32:	8e e1       	ldi	r24, 0x1E	; 30
     a34:	c8 2e       	mov	r12, r24
     a36:	d1 2c       	mov	r13, r1
     a38:	dc 82       	std	Y+4, r13	; 0x04
     a3a:	cb 82       	std	Y+3, r12	; 0x03
     a3c:	ed 82       	std	Y+5, r14	; 0x05
     a3e:	fe 82       	std	Y+6, r15	; 0x06
     a40:	0f 83       	std	Y+7, r16	; 0x07
     a42:	18 87       	std	Y+8, r17	; 0x08
     a44:	c8 01       	movw	r24, r16
     a46:	b7 01       	movw	r22, r14
     a48:	0e 94 80 05 	call	0xb00	; 0xb00 <__clzsi2>
     a4c:	fc 01       	movw	r30, r24
     a4e:	31 97       	sbiw	r30, 0x01	; 1
     a50:	f7 ff       	sbrs	r31, 7
     a52:	3b c0       	rjmp	.+118    	; 0xaca <__floatunsisf+0xbc>
     a54:	22 27       	eor	r18, r18
     a56:	33 27       	eor	r19, r19
     a58:	2e 1b       	sub	r18, r30
     a5a:	3f 0b       	sbc	r19, r31
     a5c:	57 01       	movw	r10, r14
     a5e:	68 01       	movw	r12, r16
     a60:	02 2e       	mov	r0, r18
     a62:	04 c0       	rjmp	.+8      	; 0xa6c <__floatunsisf+0x5e>
     a64:	d6 94       	lsr	r13
     a66:	c7 94       	ror	r12
     a68:	b7 94       	ror	r11
     a6a:	a7 94       	ror	r10
     a6c:	0a 94       	dec	r0
     a6e:	d2 f7       	brpl	.-12     	; 0xa64 <__floatunsisf+0x56>
     a70:	40 e0       	ldi	r20, 0x00	; 0
     a72:	50 e0       	ldi	r21, 0x00	; 0
     a74:	60 e0       	ldi	r22, 0x00	; 0
     a76:	70 e0       	ldi	r23, 0x00	; 0
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	90 e0       	ldi	r25, 0x00	; 0
     a7c:	a0 e0       	ldi	r26, 0x00	; 0
     a7e:	b0 e0       	ldi	r27, 0x00	; 0
     a80:	04 c0       	rjmp	.+8      	; 0xa8a <__floatunsisf+0x7c>
     a82:	88 0f       	add	r24, r24
     a84:	99 1f       	adc	r25, r25
     a86:	aa 1f       	adc	r26, r26
     a88:	bb 1f       	adc	r27, r27
     a8a:	2a 95       	dec	r18
     a8c:	d2 f7       	brpl	.-12     	; 0xa82 <__floatunsisf+0x74>
     a8e:	01 97       	sbiw	r24, 0x01	; 1
     a90:	a1 09       	sbc	r26, r1
     a92:	b1 09       	sbc	r27, r1
     a94:	8e 21       	and	r24, r14
     a96:	9f 21       	and	r25, r15
     a98:	a0 23       	and	r26, r16
     a9a:	b1 23       	and	r27, r17
     a9c:	00 97       	sbiw	r24, 0x00	; 0
     a9e:	a1 05       	cpc	r26, r1
     aa0:	b1 05       	cpc	r27, r1
     aa2:	21 f0       	breq	.+8      	; 0xaac <__floatunsisf+0x9e>
     aa4:	41 e0       	ldi	r20, 0x01	; 1
     aa6:	50 e0       	ldi	r21, 0x00	; 0
     aa8:	60 e0       	ldi	r22, 0x00	; 0
     aaa:	70 e0       	ldi	r23, 0x00	; 0
     aac:	4a 29       	or	r20, r10
     aae:	5b 29       	or	r21, r11
     ab0:	6c 29       	or	r22, r12
     ab2:	7d 29       	or	r23, r13
     ab4:	4d 83       	std	Y+5, r20	; 0x05
     ab6:	5e 83       	std	Y+6, r21	; 0x06
     ab8:	6f 83       	std	Y+7, r22	; 0x07
     aba:	78 87       	std	Y+8, r23	; 0x08
     abc:	8e e1       	ldi	r24, 0x1E	; 30
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	8e 1b       	sub	r24, r30
     ac2:	9f 0b       	sbc	r25, r31
     ac4:	9c 83       	std	Y+4, r25	; 0x04
     ac6:	8b 83       	std	Y+3, r24	; 0x03
     ac8:	12 c0       	rjmp	.+36     	; 0xaee <__floatunsisf+0xe0>
     aca:	30 97       	sbiw	r30, 0x00	; 0
     acc:	81 f0       	breq	.+32     	; 0xaee <__floatunsisf+0xe0>
     ace:	0e 2e       	mov	r0, r30
     ad0:	04 c0       	rjmp	.+8      	; 0xada <__floatunsisf+0xcc>
     ad2:	ee 0c       	add	r14, r14
     ad4:	ff 1c       	adc	r15, r15
     ad6:	00 1f       	adc	r16, r16
     ad8:	11 1f       	adc	r17, r17
     ada:	0a 94       	dec	r0
     adc:	d2 f7       	brpl	.-12     	; 0xad2 <__floatunsisf+0xc4>
     ade:	ed 82       	std	Y+5, r14	; 0x05
     ae0:	fe 82       	std	Y+6, r15	; 0x06
     ae2:	0f 83       	std	Y+7, r16	; 0x07
     ae4:	18 87       	std	Y+8, r17	; 0x08
     ae6:	ce 1a       	sub	r12, r30
     ae8:	df 0a       	sbc	r13, r31
     aea:	dc 82       	std	Y+4, r13	; 0x04
     aec:	cb 82       	std	Y+3, r12	; 0x03
     aee:	1a 82       	std	Y+2, r1	; 0x02
     af0:	ce 01       	movw	r24, r28
     af2:	01 96       	adiw	r24, 0x01	; 1
     af4:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     af8:	28 96       	adiw	r28, 0x08	; 8
     afa:	ea e0       	ldi	r30, 0x0A	; 10
     afc:	0c 94 fb 4c 	jmp	0x99f6	; 0x99f6 <__epilogue_restores__+0x10>

00000b00 <__clzsi2>:
     b00:	ef 92       	push	r14
     b02:	ff 92       	push	r15
     b04:	0f 93       	push	r16
     b06:	1f 93       	push	r17
     b08:	7b 01       	movw	r14, r22
     b0a:	8c 01       	movw	r16, r24
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	e8 16       	cp	r14, r24
     b10:	80 e0       	ldi	r24, 0x00	; 0
     b12:	f8 06       	cpc	r15, r24
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	08 07       	cpc	r16, r24
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	18 07       	cpc	r17, r24
     b1c:	88 f4       	brcc	.+34     	; 0xb40 <__clzsi2+0x40>
     b1e:	8f ef       	ldi	r24, 0xFF	; 255
     b20:	e8 16       	cp	r14, r24
     b22:	f1 04       	cpc	r15, r1
     b24:	01 05       	cpc	r16, r1
     b26:	11 05       	cpc	r17, r1
     b28:	31 f0       	breq	.+12     	; 0xb36 <__clzsi2+0x36>
     b2a:	28 f0       	brcs	.+10     	; 0xb36 <__clzsi2+0x36>
     b2c:	88 e0       	ldi	r24, 0x08	; 8
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	a0 e0       	ldi	r26, 0x00	; 0
     b32:	b0 e0       	ldi	r27, 0x00	; 0
     b34:	17 c0       	rjmp	.+46     	; 0xb64 <__clzsi2+0x64>
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	a0 e0       	ldi	r26, 0x00	; 0
     b3c:	b0 e0       	ldi	r27, 0x00	; 0
     b3e:	12 c0       	rjmp	.+36     	; 0xb64 <__clzsi2+0x64>
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	e8 16       	cp	r14, r24
     b44:	80 e0       	ldi	r24, 0x00	; 0
     b46:	f8 06       	cpc	r15, r24
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	08 07       	cpc	r16, r24
     b4c:	81 e0       	ldi	r24, 0x01	; 1
     b4e:	18 07       	cpc	r17, r24
     b50:	28 f0       	brcs	.+10     	; 0xb5c <__clzsi2+0x5c>
     b52:	88 e1       	ldi	r24, 0x18	; 24
     b54:	90 e0       	ldi	r25, 0x00	; 0
     b56:	a0 e0       	ldi	r26, 0x00	; 0
     b58:	b0 e0       	ldi	r27, 0x00	; 0
     b5a:	04 c0       	rjmp	.+8      	; 0xb64 <__clzsi2+0x64>
     b5c:	80 e1       	ldi	r24, 0x10	; 16
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	a0 e0       	ldi	r26, 0x00	; 0
     b62:	b0 e0       	ldi	r27, 0x00	; 0
     b64:	20 e2       	ldi	r18, 0x20	; 32
     b66:	30 e0       	ldi	r19, 0x00	; 0
     b68:	40 e0       	ldi	r20, 0x00	; 0
     b6a:	50 e0       	ldi	r21, 0x00	; 0
     b6c:	28 1b       	sub	r18, r24
     b6e:	39 0b       	sbc	r19, r25
     b70:	4a 0b       	sbc	r20, r26
     b72:	5b 0b       	sbc	r21, r27
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__clzsi2+0x7e>
     b76:	16 95       	lsr	r17
     b78:	07 95       	ror	r16
     b7a:	f7 94       	ror	r15
     b7c:	e7 94       	ror	r14
     b7e:	8a 95       	dec	r24
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__clzsi2+0x76>
     b82:	f7 01       	movw	r30, r14
     b84:	e2 51       	subi	r30, 0x12	; 18
     b86:	ff 4f       	sbci	r31, 0xFF	; 255
     b88:	80 81       	ld	r24, Z
     b8a:	28 1b       	sub	r18, r24
     b8c:	31 09       	sbc	r19, r1
     b8e:	41 09       	sbc	r20, r1
     b90:	51 09       	sbc	r21, r1
     b92:	c9 01       	movw	r24, r18
     b94:	1f 91       	pop	r17
     b96:	0f 91       	pop	r16
     b98:	ff 90       	pop	r15
     b9a:	ef 90       	pop	r14
     b9c:	08 95       	ret

00000b9e <__pack_f>:
     b9e:	df 92       	push	r13
     ba0:	ef 92       	push	r14
     ba2:	ff 92       	push	r15
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	fc 01       	movw	r30, r24
     baa:	e4 80       	ldd	r14, Z+4	; 0x04
     bac:	f5 80       	ldd	r15, Z+5	; 0x05
     bae:	06 81       	ldd	r16, Z+6	; 0x06
     bb0:	17 81       	ldd	r17, Z+7	; 0x07
     bb2:	d1 80       	ldd	r13, Z+1	; 0x01
     bb4:	80 81       	ld	r24, Z
     bb6:	82 30       	cpi	r24, 0x02	; 2
     bb8:	48 f4       	brcc	.+18     	; 0xbcc <__pack_f+0x2e>
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	90 e0       	ldi	r25, 0x00	; 0
     bbe:	a0 e1       	ldi	r26, 0x10	; 16
     bc0:	b0 e0       	ldi	r27, 0x00	; 0
     bc2:	e8 2a       	or	r14, r24
     bc4:	f9 2a       	or	r15, r25
     bc6:	0a 2b       	or	r16, r26
     bc8:	1b 2b       	or	r17, r27
     bca:	a5 c0       	rjmp	.+330    	; 0xd16 <__pack_f+0x178>
     bcc:	84 30       	cpi	r24, 0x04	; 4
     bce:	09 f4       	brne	.+2      	; 0xbd2 <__pack_f+0x34>
     bd0:	9f c0       	rjmp	.+318    	; 0xd10 <__pack_f+0x172>
     bd2:	82 30       	cpi	r24, 0x02	; 2
     bd4:	21 f4       	brne	.+8      	; 0xbde <__pack_f+0x40>
     bd6:	ee 24       	eor	r14, r14
     bd8:	ff 24       	eor	r15, r15
     bda:	87 01       	movw	r16, r14
     bdc:	05 c0       	rjmp	.+10     	; 0xbe8 <__pack_f+0x4a>
     bde:	e1 14       	cp	r14, r1
     be0:	f1 04       	cpc	r15, r1
     be2:	01 05       	cpc	r16, r1
     be4:	11 05       	cpc	r17, r1
     be6:	19 f4       	brne	.+6      	; 0xbee <__pack_f+0x50>
     be8:	e0 e0       	ldi	r30, 0x00	; 0
     bea:	f0 e0       	ldi	r31, 0x00	; 0
     bec:	96 c0       	rjmp	.+300    	; 0xd1a <__pack_f+0x17c>
     bee:	62 81       	ldd	r22, Z+2	; 0x02
     bf0:	73 81       	ldd	r23, Z+3	; 0x03
     bf2:	9f ef       	ldi	r25, 0xFF	; 255
     bf4:	62 38       	cpi	r22, 0x82	; 130
     bf6:	79 07       	cpc	r23, r25
     bf8:	0c f0       	brlt	.+2      	; 0xbfc <__pack_f+0x5e>
     bfa:	5b c0       	rjmp	.+182    	; 0xcb2 <__pack_f+0x114>
     bfc:	22 e8       	ldi	r18, 0x82	; 130
     bfe:	3f ef       	ldi	r19, 0xFF	; 255
     c00:	26 1b       	sub	r18, r22
     c02:	37 0b       	sbc	r19, r23
     c04:	2a 31       	cpi	r18, 0x1A	; 26
     c06:	31 05       	cpc	r19, r1
     c08:	2c f0       	brlt	.+10     	; 0xc14 <__pack_f+0x76>
     c0a:	20 e0       	ldi	r18, 0x00	; 0
     c0c:	30 e0       	ldi	r19, 0x00	; 0
     c0e:	40 e0       	ldi	r20, 0x00	; 0
     c10:	50 e0       	ldi	r21, 0x00	; 0
     c12:	2a c0       	rjmp	.+84     	; 0xc68 <__pack_f+0xca>
     c14:	b8 01       	movw	r22, r16
     c16:	a7 01       	movw	r20, r14
     c18:	02 2e       	mov	r0, r18
     c1a:	04 c0       	rjmp	.+8      	; 0xc24 <__pack_f+0x86>
     c1c:	76 95       	lsr	r23
     c1e:	67 95       	ror	r22
     c20:	57 95       	ror	r21
     c22:	47 95       	ror	r20
     c24:	0a 94       	dec	r0
     c26:	d2 f7       	brpl	.-12     	; 0xc1c <__pack_f+0x7e>
     c28:	81 e0       	ldi	r24, 0x01	; 1
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	a0 e0       	ldi	r26, 0x00	; 0
     c2e:	b0 e0       	ldi	r27, 0x00	; 0
     c30:	04 c0       	rjmp	.+8      	; 0xc3a <__pack_f+0x9c>
     c32:	88 0f       	add	r24, r24
     c34:	99 1f       	adc	r25, r25
     c36:	aa 1f       	adc	r26, r26
     c38:	bb 1f       	adc	r27, r27
     c3a:	2a 95       	dec	r18
     c3c:	d2 f7       	brpl	.-12     	; 0xc32 <__pack_f+0x94>
     c3e:	01 97       	sbiw	r24, 0x01	; 1
     c40:	a1 09       	sbc	r26, r1
     c42:	b1 09       	sbc	r27, r1
     c44:	8e 21       	and	r24, r14
     c46:	9f 21       	and	r25, r15
     c48:	a0 23       	and	r26, r16
     c4a:	b1 23       	and	r27, r17
     c4c:	00 97       	sbiw	r24, 0x00	; 0
     c4e:	a1 05       	cpc	r26, r1
     c50:	b1 05       	cpc	r27, r1
     c52:	21 f0       	breq	.+8      	; 0xc5c <__pack_f+0xbe>
     c54:	81 e0       	ldi	r24, 0x01	; 1
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	a0 e0       	ldi	r26, 0x00	; 0
     c5a:	b0 e0       	ldi	r27, 0x00	; 0
     c5c:	9a 01       	movw	r18, r20
     c5e:	ab 01       	movw	r20, r22
     c60:	28 2b       	or	r18, r24
     c62:	39 2b       	or	r19, r25
     c64:	4a 2b       	or	r20, r26
     c66:	5b 2b       	or	r21, r27
     c68:	da 01       	movw	r26, r20
     c6a:	c9 01       	movw	r24, r18
     c6c:	8f 77       	andi	r24, 0x7F	; 127
     c6e:	90 70       	andi	r25, 0x00	; 0
     c70:	a0 70       	andi	r26, 0x00	; 0
     c72:	b0 70       	andi	r27, 0x00	; 0
     c74:	80 34       	cpi	r24, 0x40	; 64
     c76:	91 05       	cpc	r25, r1
     c78:	a1 05       	cpc	r26, r1
     c7a:	b1 05       	cpc	r27, r1
     c7c:	39 f4       	brne	.+14     	; 0xc8c <__pack_f+0xee>
     c7e:	27 ff       	sbrs	r18, 7
     c80:	09 c0       	rjmp	.+18     	; 0xc94 <__pack_f+0xf6>
     c82:	20 5c       	subi	r18, 0xC0	; 192
     c84:	3f 4f       	sbci	r19, 0xFF	; 255
     c86:	4f 4f       	sbci	r20, 0xFF	; 255
     c88:	5f 4f       	sbci	r21, 0xFF	; 255
     c8a:	04 c0       	rjmp	.+8      	; 0xc94 <__pack_f+0xf6>
     c8c:	21 5c       	subi	r18, 0xC1	; 193
     c8e:	3f 4f       	sbci	r19, 0xFF	; 255
     c90:	4f 4f       	sbci	r20, 0xFF	; 255
     c92:	5f 4f       	sbci	r21, 0xFF	; 255
     c94:	e0 e0       	ldi	r30, 0x00	; 0
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	20 30       	cpi	r18, 0x00	; 0
     c9a:	a0 e0       	ldi	r26, 0x00	; 0
     c9c:	3a 07       	cpc	r19, r26
     c9e:	a0 e0       	ldi	r26, 0x00	; 0
     ca0:	4a 07       	cpc	r20, r26
     ca2:	a0 e4       	ldi	r26, 0x40	; 64
     ca4:	5a 07       	cpc	r21, r26
     ca6:	10 f0       	brcs	.+4      	; 0xcac <__pack_f+0x10e>
     ca8:	e1 e0       	ldi	r30, 0x01	; 1
     caa:	f0 e0       	ldi	r31, 0x00	; 0
     cac:	79 01       	movw	r14, r18
     cae:	8a 01       	movw	r16, r20
     cb0:	27 c0       	rjmp	.+78     	; 0xd00 <__pack_f+0x162>
     cb2:	60 38       	cpi	r22, 0x80	; 128
     cb4:	71 05       	cpc	r23, r1
     cb6:	64 f5       	brge	.+88     	; 0xd10 <__pack_f+0x172>
     cb8:	fb 01       	movw	r30, r22
     cba:	e1 58       	subi	r30, 0x81	; 129
     cbc:	ff 4f       	sbci	r31, 0xFF	; 255
     cbe:	d8 01       	movw	r26, r16
     cc0:	c7 01       	movw	r24, r14
     cc2:	8f 77       	andi	r24, 0x7F	; 127
     cc4:	90 70       	andi	r25, 0x00	; 0
     cc6:	a0 70       	andi	r26, 0x00	; 0
     cc8:	b0 70       	andi	r27, 0x00	; 0
     cca:	80 34       	cpi	r24, 0x40	; 64
     ccc:	91 05       	cpc	r25, r1
     cce:	a1 05       	cpc	r26, r1
     cd0:	b1 05       	cpc	r27, r1
     cd2:	39 f4       	brne	.+14     	; 0xce2 <__pack_f+0x144>
     cd4:	e7 fe       	sbrs	r14, 7
     cd6:	0d c0       	rjmp	.+26     	; 0xcf2 <__pack_f+0x154>
     cd8:	80 e4       	ldi	r24, 0x40	; 64
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	a0 e0       	ldi	r26, 0x00	; 0
     cde:	b0 e0       	ldi	r27, 0x00	; 0
     ce0:	04 c0       	rjmp	.+8      	; 0xcea <__pack_f+0x14c>
     ce2:	8f e3       	ldi	r24, 0x3F	; 63
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	a0 e0       	ldi	r26, 0x00	; 0
     ce8:	b0 e0       	ldi	r27, 0x00	; 0
     cea:	e8 0e       	add	r14, r24
     cec:	f9 1e       	adc	r15, r25
     cee:	0a 1f       	adc	r16, r26
     cf0:	1b 1f       	adc	r17, r27
     cf2:	17 ff       	sbrs	r17, 7
     cf4:	05 c0       	rjmp	.+10     	; 0xd00 <__pack_f+0x162>
     cf6:	16 95       	lsr	r17
     cf8:	07 95       	ror	r16
     cfa:	f7 94       	ror	r15
     cfc:	e7 94       	ror	r14
     cfe:	31 96       	adiw	r30, 0x01	; 1
     d00:	87 e0       	ldi	r24, 0x07	; 7
     d02:	16 95       	lsr	r17
     d04:	07 95       	ror	r16
     d06:	f7 94       	ror	r15
     d08:	e7 94       	ror	r14
     d0a:	8a 95       	dec	r24
     d0c:	d1 f7       	brne	.-12     	; 0xd02 <__pack_f+0x164>
     d0e:	05 c0       	rjmp	.+10     	; 0xd1a <__pack_f+0x17c>
     d10:	ee 24       	eor	r14, r14
     d12:	ff 24       	eor	r15, r15
     d14:	87 01       	movw	r16, r14
     d16:	ef ef       	ldi	r30, 0xFF	; 255
     d18:	f0 e0       	ldi	r31, 0x00	; 0
     d1a:	6e 2f       	mov	r22, r30
     d1c:	67 95       	ror	r22
     d1e:	66 27       	eor	r22, r22
     d20:	67 95       	ror	r22
     d22:	90 2f       	mov	r25, r16
     d24:	9f 77       	andi	r25, 0x7F	; 127
     d26:	d7 94       	ror	r13
     d28:	dd 24       	eor	r13, r13
     d2a:	d7 94       	ror	r13
     d2c:	8e 2f       	mov	r24, r30
     d2e:	86 95       	lsr	r24
     d30:	49 2f       	mov	r20, r25
     d32:	46 2b       	or	r20, r22
     d34:	58 2f       	mov	r21, r24
     d36:	5d 29       	or	r21, r13
     d38:	b7 01       	movw	r22, r14
     d3a:	ca 01       	movw	r24, r20
     d3c:	1f 91       	pop	r17
     d3e:	0f 91       	pop	r16
     d40:	ff 90       	pop	r15
     d42:	ef 90       	pop	r14
     d44:	df 90       	pop	r13
     d46:	08 95       	ret

00000d48 <__unpack_f>:
     d48:	fc 01       	movw	r30, r24
     d4a:	db 01       	movw	r26, r22
     d4c:	40 81       	ld	r20, Z
     d4e:	51 81       	ldd	r21, Z+1	; 0x01
     d50:	22 81       	ldd	r18, Z+2	; 0x02
     d52:	62 2f       	mov	r22, r18
     d54:	6f 77       	andi	r22, 0x7F	; 127
     d56:	70 e0       	ldi	r23, 0x00	; 0
     d58:	22 1f       	adc	r18, r18
     d5a:	22 27       	eor	r18, r18
     d5c:	22 1f       	adc	r18, r18
     d5e:	93 81       	ldd	r25, Z+3	; 0x03
     d60:	89 2f       	mov	r24, r25
     d62:	88 0f       	add	r24, r24
     d64:	82 2b       	or	r24, r18
     d66:	28 2f       	mov	r18, r24
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	99 1f       	adc	r25, r25
     d6c:	99 27       	eor	r25, r25
     d6e:	99 1f       	adc	r25, r25
     d70:	11 96       	adiw	r26, 0x01	; 1
     d72:	9c 93       	st	X, r25
     d74:	11 97       	sbiw	r26, 0x01	; 1
     d76:	21 15       	cp	r18, r1
     d78:	31 05       	cpc	r19, r1
     d7a:	a9 f5       	brne	.+106    	; 0xde6 <__unpack_f+0x9e>
     d7c:	41 15       	cp	r20, r1
     d7e:	51 05       	cpc	r21, r1
     d80:	61 05       	cpc	r22, r1
     d82:	71 05       	cpc	r23, r1
     d84:	11 f4       	brne	.+4      	; 0xd8a <__unpack_f+0x42>
     d86:	82 e0       	ldi	r24, 0x02	; 2
     d88:	37 c0       	rjmp	.+110    	; 0xdf8 <__unpack_f+0xb0>
     d8a:	82 e8       	ldi	r24, 0x82	; 130
     d8c:	9f ef       	ldi	r25, 0xFF	; 255
     d8e:	13 96       	adiw	r26, 0x03	; 3
     d90:	9c 93       	st	X, r25
     d92:	8e 93       	st	-X, r24
     d94:	12 97       	sbiw	r26, 0x02	; 2
     d96:	9a 01       	movw	r18, r20
     d98:	ab 01       	movw	r20, r22
     d9a:	67 e0       	ldi	r22, 0x07	; 7
     d9c:	22 0f       	add	r18, r18
     d9e:	33 1f       	adc	r19, r19
     da0:	44 1f       	adc	r20, r20
     da2:	55 1f       	adc	r21, r21
     da4:	6a 95       	dec	r22
     da6:	d1 f7       	brne	.-12     	; 0xd9c <__unpack_f+0x54>
     da8:	83 e0       	ldi	r24, 0x03	; 3
     daa:	8c 93       	st	X, r24
     dac:	0d c0       	rjmp	.+26     	; 0xdc8 <__unpack_f+0x80>
     dae:	22 0f       	add	r18, r18
     db0:	33 1f       	adc	r19, r19
     db2:	44 1f       	adc	r20, r20
     db4:	55 1f       	adc	r21, r21
     db6:	12 96       	adiw	r26, 0x02	; 2
     db8:	8d 91       	ld	r24, X+
     dba:	9c 91       	ld	r25, X
     dbc:	13 97       	sbiw	r26, 0x03	; 3
     dbe:	01 97       	sbiw	r24, 0x01	; 1
     dc0:	13 96       	adiw	r26, 0x03	; 3
     dc2:	9c 93       	st	X, r25
     dc4:	8e 93       	st	-X, r24
     dc6:	12 97       	sbiw	r26, 0x02	; 2
     dc8:	20 30       	cpi	r18, 0x00	; 0
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	38 07       	cpc	r19, r24
     dce:	80 e0       	ldi	r24, 0x00	; 0
     dd0:	48 07       	cpc	r20, r24
     dd2:	80 e4       	ldi	r24, 0x40	; 64
     dd4:	58 07       	cpc	r21, r24
     dd6:	58 f3       	brcs	.-42     	; 0xdae <__unpack_f+0x66>
     dd8:	14 96       	adiw	r26, 0x04	; 4
     dda:	2d 93       	st	X+, r18
     ddc:	3d 93       	st	X+, r19
     dde:	4d 93       	st	X+, r20
     de0:	5c 93       	st	X, r21
     de2:	17 97       	sbiw	r26, 0x07	; 7
     de4:	08 95       	ret
     de6:	2f 3f       	cpi	r18, 0xFF	; 255
     de8:	31 05       	cpc	r19, r1
     dea:	79 f4       	brne	.+30     	; 0xe0a <__unpack_f+0xc2>
     dec:	41 15       	cp	r20, r1
     dee:	51 05       	cpc	r21, r1
     df0:	61 05       	cpc	r22, r1
     df2:	71 05       	cpc	r23, r1
     df4:	19 f4       	brne	.+6      	; 0xdfc <__unpack_f+0xb4>
     df6:	84 e0       	ldi	r24, 0x04	; 4
     df8:	8c 93       	st	X, r24
     dfa:	08 95       	ret
     dfc:	64 ff       	sbrs	r22, 4
     dfe:	03 c0       	rjmp	.+6      	; 0xe06 <__unpack_f+0xbe>
     e00:	81 e0       	ldi	r24, 0x01	; 1
     e02:	8c 93       	st	X, r24
     e04:	12 c0       	rjmp	.+36     	; 0xe2a <__unpack_f+0xe2>
     e06:	1c 92       	st	X, r1
     e08:	10 c0       	rjmp	.+32     	; 0xe2a <__unpack_f+0xe2>
     e0a:	2f 57       	subi	r18, 0x7F	; 127
     e0c:	30 40       	sbci	r19, 0x00	; 0
     e0e:	13 96       	adiw	r26, 0x03	; 3
     e10:	3c 93       	st	X, r19
     e12:	2e 93       	st	-X, r18
     e14:	12 97       	sbiw	r26, 0x02	; 2
     e16:	83 e0       	ldi	r24, 0x03	; 3
     e18:	8c 93       	st	X, r24
     e1a:	87 e0       	ldi	r24, 0x07	; 7
     e1c:	44 0f       	add	r20, r20
     e1e:	55 1f       	adc	r21, r21
     e20:	66 1f       	adc	r22, r22
     e22:	77 1f       	adc	r23, r23
     e24:	8a 95       	dec	r24
     e26:	d1 f7       	brne	.-12     	; 0xe1c <__unpack_f+0xd4>
     e28:	70 64       	ori	r23, 0x40	; 64
     e2a:	14 96       	adiw	r26, 0x04	; 4
     e2c:	4d 93       	st	X+, r20
     e2e:	5d 93       	st	X+, r21
     e30:	6d 93       	st	X+, r22
     e32:	7c 93       	st	X, r23
     e34:	17 97       	sbiw	r26, 0x07	; 7
     e36:	08 95       	ret

00000e38 <__fpcmp_parts_f>:
     e38:	1f 93       	push	r17
     e3a:	dc 01       	movw	r26, r24
     e3c:	fb 01       	movw	r30, r22
     e3e:	9c 91       	ld	r25, X
     e40:	92 30       	cpi	r25, 0x02	; 2
     e42:	08 f4       	brcc	.+2      	; 0xe46 <__fpcmp_parts_f+0xe>
     e44:	47 c0       	rjmp	.+142    	; 0xed4 <__fpcmp_parts_f+0x9c>
     e46:	80 81       	ld	r24, Z
     e48:	82 30       	cpi	r24, 0x02	; 2
     e4a:	08 f4       	brcc	.+2      	; 0xe4e <__fpcmp_parts_f+0x16>
     e4c:	43 c0       	rjmp	.+134    	; 0xed4 <__fpcmp_parts_f+0x9c>
     e4e:	94 30       	cpi	r25, 0x04	; 4
     e50:	51 f4       	brne	.+20     	; 0xe66 <__fpcmp_parts_f+0x2e>
     e52:	11 96       	adiw	r26, 0x01	; 1
     e54:	1c 91       	ld	r17, X
     e56:	84 30       	cpi	r24, 0x04	; 4
     e58:	99 f5       	brne	.+102    	; 0xec0 <__fpcmp_parts_f+0x88>
     e5a:	81 81       	ldd	r24, Z+1	; 0x01
     e5c:	68 2f       	mov	r22, r24
     e5e:	70 e0       	ldi	r23, 0x00	; 0
     e60:	61 1b       	sub	r22, r17
     e62:	71 09       	sbc	r23, r1
     e64:	3f c0       	rjmp	.+126    	; 0xee4 <__fpcmp_parts_f+0xac>
     e66:	84 30       	cpi	r24, 0x04	; 4
     e68:	21 f0       	breq	.+8      	; 0xe72 <__fpcmp_parts_f+0x3a>
     e6a:	92 30       	cpi	r25, 0x02	; 2
     e6c:	31 f4       	brne	.+12     	; 0xe7a <__fpcmp_parts_f+0x42>
     e6e:	82 30       	cpi	r24, 0x02	; 2
     e70:	b9 f1       	breq	.+110    	; 0xee0 <__fpcmp_parts_f+0xa8>
     e72:	81 81       	ldd	r24, Z+1	; 0x01
     e74:	88 23       	and	r24, r24
     e76:	89 f1       	breq	.+98     	; 0xeda <__fpcmp_parts_f+0xa2>
     e78:	2d c0       	rjmp	.+90     	; 0xed4 <__fpcmp_parts_f+0x9c>
     e7a:	11 96       	adiw	r26, 0x01	; 1
     e7c:	1c 91       	ld	r17, X
     e7e:	11 97       	sbiw	r26, 0x01	; 1
     e80:	82 30       	cpi	r24, 0x02	; 2
     e82:	f1 f0       	breq	.+60     	; 0xec0 <__fpcmp_parts_f+0x88>
     e84:	81 81       	ldd	r24, Z+1	; 0x01
     e86:	18 17       	cp	r17, r24
     e88:	d9 f4       	brne	.+54     	; 0xec0 <__fpcmp_parts_f+0x88>
     e8a:	12 96       	adiw	r26, 0x02	; 2
     e8c:	2d 91       	ld	r18, X+
     e8e:	3c 91       	ld	r19, X
     e90:	13 97       	sbiw	r26, 0x03	; 3
     e92:	82 81       	ldd	r24, Z+2	; 0x02
     e94:	93 81       	ldd	r25, Z+3	; 0x03
     e96:	82 17       	cp	r24, r18
     e98:	93 07       	cpc	r25, r19
     e9a:	94 f0       	brlt	.+36     	; 0xec0 <__fpcmp_parts_f+0x88>
     e9c:	28 17       	cp	r18, r24
     e9e:	39 07       	cpc	r19, r25
     ea0:	bc f0       	brlt	.+46     	; 0xed0 <__fpcmp_parts_f+0x98>
     ea2:	14 96       	adiw	r26, 0x04	; 4
     ea4:	8d 91       	ld	r24, X+
     ea6:	9d 91       	ld	r25, X+
     ea8:	0d 90       	ld	r0, X+
     eaa:	bc 91       	ld	r27, X
     eac:	a0 2d       	mov	r26, r0
     eae:	24 81       	ldd	r18, Z+4	; 0x04
     eb0:	35 81       	ldd	r19, Z+5	; 0x05
     eb2:	46 81       	ldd	r20, Z+6	; 0x06
     eb4:	57 81       	ldd	r21, Z+7	; 0x07
     eb6:	28 17       	cp	r18, r24
     eb8:	39 07       	cpc	r19, r25
     eba:	4a 07       	cpc	r20, r26
     ebc:	5b 07       	cpc	r21, r27
     ebe:	18 f4       	brcc	.+6      	; 0xec6 <__fpcmp_parts_f+0x8e>
     ec0:	11 23       	and	r17, r17
     ec2:	41 f0       	breq	.+16     	; 0xed4 <__fpcmp_parts_f+0x9c>
     ec4:	0a c0       	rjmp	.+20     	; 0xeda <__fpcmp_parts_f+0xa2>
     ec6:	82 17       	cp	r24, r18
     ec8:	93 07       	cpc	r25, r19
     eca:	a4 07       	cpc	r26, r20
     ecc:	b5 07       	cpc	r27, r21
     ece:	40 f4       	brcc	.+16     	; 0xee0 <__fpcmp_parts_f+0xa8>
     ed0:	11 23       	and	r17, r17
     ed2:	19 f0       	breq	.+6      	; 0xeda <__fpcmp_parts_f+0xa2>
     ed4:	61 e0       	ldi	r22, 0x01	; 1
     ed6:	70 e0       	ldi	r23, 0x00	; 0
     ed8:	05 c0       	rjmp	.+10     	; 0xee4 <__fpcmp_parts_f+0xac>
     eda:	6f ef       	ldi	r22, 0xFF	; 255
     edc:	7f ef       	ldi	r23, 0xFF	; 255
     ede:	02 c0       	rjmp	.+4      	; 0xee4 <__fpcmp_parts_f+0xac>
     ee0:	60 e0       	ldi	r22, 0x00	; 0
     ee2:	70 e0       	ldi	r23, 0x00	; 0
     ee4:	cb 01       	movw	r24, r22
     ee6:	1f 91       	pop	r17
     ee8:	08 95       	ret

00000eea <Alarm_init>:

// Global variables
extern EventGroupHandle_t E_Gr;

void Alarm_init( void )
{
     eea:	ef 92       	push	r14
     eec:	ff 92       	push	r15
     eee:	0f 93       	push	r16
     ef0:	df 93       	push	r29
     ef2:	cf 93       	push	r28
     ef4:	cd b7       	in	r28, 0x3d	; 61
     ef6:	de b7       	in	r29, 0x3e	; 62
	// initiate the output port
	DIO_void_set_pin_dir(DIO_REF_PORTB, B0, OUTPUT);
     ef8:	81 e0       	ldi	r24, 0x01	; 1
     efa:	60 e0       	ldi	r22, 0x00	; 0
     efc:	41 e0       	ldi	r20, 0x01	; 1
     efe:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_clear_pin(DIO_REF_PORTB, B0);
     f02:	81 e0       	ldi	r24, 0x01	; 1
     f04:	60 e0       	ldi	r22, 0x00	; 0
     f06:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
	// Create update temperature main task
	xTaskCreate(ALarm_main, "Alarm", ALARM_STACK, NULL, ALARM_PRIORITY, NULL);
     f0a:	89 e9       	ldi	r24, 0x99	; 153
     f0c:	97 e0       	ldi	r25, 0x07	; 7
     f0e:	20 e6       	ldi	r18, 0x60	; 96
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	b9 01       	movw	r22, r18
     f14:	45 e5       	ldi	r20, 0x55	; 85
     f16:	50 e0       	ldi	r21, 0x00	; 0
     f18:	20 e0       	ldi	r18, 0x00	; 0
     f1a:	30 e0       	ldi	r19, 0x00	; 0
     f1c:	01 e0       	ldi	r16, 0x01	; 1
     f1e:	ee 24       	eor	r14, r14
     f20:	ff 24       	eor	r15, r15
     f22:	0e 94 03 19 	call	0x3206	; 0x3206 <xTaskCreate>
}
     f26:	cf 91       	pop	r28
     f28:	df 91       	pop	r29
     f2a:	0f 91       	pop	r16
     f2c:	ff 90       	pop	r15
     f2e:	ef 90       	pop	r14
     f30:	08 95       	ret

00000f32 <ALarm_main>:

void ALarm_main( void* pvParameters)
{
     f32:	0f 93       	push	r16
     f34:	1f 93       	push	r17
     f36:	df 93       	push	r29
     f38:	cf 93       	push	r28
     f3a:	00 d0       	rcall	.+0      	; 0xf3c <ALarm_main+0xa>
     f3c:	cd b7       	in	r28, 0x3d	; 61
     f3e:	de b7       	in	r29, 0x3e	; 62
     f40:	9a 83       	std	Y+2, r25	; 0x02
     f42:	89 83       	std	Y+1, r24	; 0x01

	while( 1 )
	{
		// Super loop
		// turn on the alarm
		DIO_void_set_pin(DIO_REF_PORTB, B0);
     f44:	81 e0       	ldi	r24, 0x01	; 1
     f46:	60 e0       	ldi	r22, 0x00	; 0
     f48:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
		// wait 5 ticks
		vTaskDelay(75);
     f4c:	8b e4       	ldi	r24, 0x4B	; 75
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskDelay>
		// turn off the alarm
		DIO_void_clear_pin(DIO_REF_PORTB, B0);
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	60 e0       	ldi	r22, 0x00	; 0
     f58:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
		// check the alarm event flag
		if( (xEventGroupGetBits(E_Gr) & ALARM_E_ALARM) == ALARM_E_ALARM )
     f5c:	80 91 d1 04 	lds	r24, 0x04D1
     f60:	90 91 d2 04 	lds	r25, 0x04D2
     f64:	60 e0       	ldi	r22, 0x00	; 0
     f66:	70 e0       	ldi	r23, 0x00	; 0
     f68:	0e 94 b4 0b 	call	0x1768	; 0x1768 <xEventGroupClearBits>
     f6c:	82 70       	andi	r24, 0x02	; 2
     f6e:	90 70       	andi	r25, 0x00	; 0
     f70:	00 97       	sbiw	r24, 0x00	; 0
     f72:	29 f0       	breq	.+10     	; 0xf7e <ALarm_main+0x4c>
		{// if true
			// wait 5 ticks
			vTaskDelay(25);
     f74:	89 e1       	ldi	r24, 0x19	; 25
     f76:	90 e0       	ldi	r25, 0x00	; 0
     f78:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskDelay>
     f7c:	e3 cf       	rjmp	.-58     	; 0xf44 <ALarm_main+0x12>
		}
		else
		{// if false
			// wait till the event flag is raised
			xEventGroupWaitBits(E_Gr, ALARM_E_ALARM, pdFALSE, pdFALSE, portMAX_DELAY);
     f7e:	80 91 d1 04 	lds	r24, 0x04D1
     f82:	90 91 d2 04 	lds	r25, 0x04D2
     f86:	62 e0       	ldi	r22, 0x02	; 2
     f88:	70 e0       	ldi	r23, 0x00	; 0
     f8a:	40 e0       	ldi	r20, 0x00	; 0
     f8c:	20 e0       	ldi	r18, 0x00	; 0
     f8e:	0f ef       	ldi	r16, 0xFF	; 255
     f90:	1f ef       	ldi	r17, 0xFF	; 255
     f92:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <xEventGroupWaitBits>
     f96:	d6 cf       	rjmp	.-84     	; 0xf44 <ALarm_main+0x12>

00000f98 <LCDdisp_init>:
extern u8 Global_AlarmState;
extern EventGroupHandle_t E_Gr;


void LCDdisp_init( void )
{
     f98:	ef 92       	push	r14
     f9a:	ff 92       	push	r15
     f9c:	0f 93       	push	r16
     f9e:	df 93       	push	r29
     fa0:	cf 93       	push	r28
     fa2:	cd b7       	in	r28, 0x3d	; 61
     fa4:	de b7       	in	r29, 0x3e	; 62
	// initiate LCD
	LCD_init();
     fa6:	0e 94 7b 43 	call	0x86f6	; 0x86f6 <LCD_init>
	// Create the LCD main task
	xTaskCreate(LCDdisp_main, "LCD_disp", LCD_DISP_STACK, NULL, LCD_DISP_PRIORITY, NULL);
     faa:	89 ee       	ldi	r24, 0xE9	; 233
     fac:	97 e0       	ldi	r25, 0x07	; 7
     fae:	26 e6       	ldi	r18, 0x66	; 102
     fb0:	30 e0       	ldi	r19, 0x00	; 0
     fb2:	b9 01       	movw	r22, r18
     fb4:	45 e5       	ldi	r20, 0x55	; 85
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	20 e0       	ldi	r18, 0x00	; 0
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	02 e0       	ldi	r16, 0x02	; 2
     fbe:	ee 24       	eor	r14, r14
     fc0:	ff 24       	eor	r15, r15
     fc2:	0e 94 03 19 	call	0x3206	; 0x3206 <xTaskCreate>
}
     fc6:	cf 91       	pop	r28
     fc8:	df 91       	pop	r29
     fca:	0f 91       	pop	r16
     fcc:	ff 90       	pop	r15
     fce:	ef 90       	pop	r14
     fd0:	08 95       	ret

00000fd2 <LCDdisp_main>:

void LCDdisp_main( void* pvParameters )
{
     fd2:	0f 93       	push	r16
     fd4:	1f 93       	push	r17
     fd6:	df 93       	push	r29
     fd8:	cf 93       	push	r28
     fda:	cd b7       	in	r28, 0x3d	; 61
     fdc:	de b7       	in	r29, 0x3e	; 62
     fde:	2c 97       	sbiw	r28, 0x0c	; 12
     fe0:	0f b6       	in	r0, 0x3f	; 63
     fe2:	f8 94       	cli
     fe4:	de bf       	out	0x3e, r29	; 62
     fe6:	0f be       	out	0x3f, r0	; 63
     fe8:	cd bf       	out	0x3d, r28	; 61
     fea:	98 87       	std	Y+8, r25	; 0x08
     fec:	8f 83       	std	Y+7, r24	; 0x07
	// Setup section
	EventBits_t Local_E_Gr = xEventGroupGetBits(E_Gr);
     fee:	80 91 d1 04 	lds	r24, 0x04D1
     ff2:	90 91 d2 04 	lds	r25, 0x04D2
     ff6:	60 e0       	ldi	r22, 0x00	; 0
     ff8:	70 e0       	ldi	r23, 0x00	; 0
     ffa:	0e 94 b4 0b 	call	0x1768	; 0x1768 <xEventGroupClearBits>
     ffe:	9e 83       	std	Y+6, r25	; 0x06
    1000:	8d 83       	std	Y+5, r24	; 0x05
	u8 Current_state = STATE_IDLE;
    1002:	81 e0       	ldi	r24, 0x01	; 1
    1004:	8c 83       	std	Y+4, r24	; 0x04
	u8 Local_Temp = Global_Temp;
    1006:	80 91 18 02 	lds	r24, 0x0218
    100a:	8b 83       	std	Y+3, r24	; 0x03
	u8 Local_Threshold = Global_Threshold;
    100c:	80 91 ee 01 	lds	r24, 0x01EE
    1010:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_AlarmState = Global_AlarmState;
    1012:	80 91 ef 01 	lds	r24, 0x01EF
    1016:	89 83       	std	Y+1, r24	; 0x01

	while( 1 )
	{
		// Super loop
		Local_E_Gr = xEventGroupGetBits(E_Gr);
    1018:	80 91 d1 04 	lds	r24, 0x04D1
    101c:	90 91 d2 04 	lds	r25, 0x04D2
    1020:	60 e0       	ldi	r22, 0x00	; 0
    1022:	70 e0       	ldi	r23, 0x00	; 0
    1024:	0e 94 b4 0b 	call	0x1768	; 0x1768 <xEventGroupClearBits>
    1028:	9e 83       	std	Y+6, r25	; 0x06
    102a:	8d 83       	std	Y+5, r24	; 0x05
		// Check for the state
		if( ( ( Local_E_Gr & LCD_DISP_E_CONFIG ) == pdFALSE )
    102c:	8d 81       	ldd	r24, Y+5	; 0x05
    102e:	9e 81       	ldd	r25, Y+6	; 0x06
    1030:	81 70       	andi	r24, 0x01	; 1
    1032:	90 70       	andi	r25, 0x00	; 0
    1034:	00 97       	sbiw	r24, 0x00	; 0
    1036:	79 f4       	brne	.+30     	; 0x1056 <LCDdisp_main+0x84>
    1038:	8d 81       	ldd	r24, Y+5	; 0x05
    103a:	9e 81       	ldd	r25, Y+6	; 0x06
    103c:	82 70       	andi	r24, 0x02	; 2
    103e:	90 70       	andi	r25, 0x00	; 0
    1040:	00 97       	sbiw	r24, 0x00	; 0
    1042:	49 f4       	brne	.+18     	; 0x1056 <LCDdisp_main+0x84>
    1044:	8d 81       	ldd	r24, Y+5	; 0x05
    1046:	9e 81       	ldd	r25, Y+6	; 0x06
    1048:	84 70       	andi	r24, 0x04	; 4
    104a:	90 70       	andi	r25, 0x00	; 0
    104c:	00 97       	sbiw	r24, 0x00	; 0
    104e:	19 f0       	breq	.+6      	; 0x1056 <LCDdisp_main+0x84>
		 && ( ( Local_E_Gr & LCD_DISP_E_ALARM ) == pdFALSE )
		 && ( ( Local_E_Gr & LCD_DISP_E_IDLE ) == LCD_DISP_E_IDLE ) )
		{// Idle state
			// set the state to Idle
			Current_state = STATE_IDLE;
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	8c 83       	std	Y+4, r24	; 0x04
    1054:	2c c0       	rjmp	.+88     	; 0x10ae <LCDdisp_main+0xdc>
		}
		else if( ( ( Local_E_Gr & LCD_DISP_E_CONFIG ) == LCD_DISP_E_CONFIG )
    1056:	8d 81       	ldd	r24, Y+5	; 0x05
    1058:	9e 81       	ldd	r25, Y+6	; 0x06
    105a:	81 70       	andi	r24, 0x01	; 1
    105c:	90 70       	andi	r25, 0x00	; 0
    105e:	98 2f       	mov	r25, r24
    1060:	81 e0       	ldi	r24, 0x01	; 1
    1062:	89 27       	eor	r24, r25
    1064:	88 23       	and	r24, r24
    1066:	79 f4       	brne	.+30     	; 0x1086 <LCDdisp_main+0xb4>
    1068:	8d 81       	ldd	r24, Y+5	; 0x05
    106a:	9e 81       	ldd	r25, Y+6	; 0x06
    106c:	82 70       	andi	r24, 0x02	; 2
    106e:	90 70       	andi	r25, 0x00	; 0
    1070:	00 97       	sbiw	r24, 0x00	; 0
    1072:	49 f4       	brne	.+18     	; 0x1086 <LCDdisp_main+0xb4>
    1074:	8d 81       	ldd	r24, Y+5	; 0x05
    1076:	9e 81       	ldd	r25, Y+6	; 0x06
    1078:	84 70       	andi	r24, 0x04	; 4
    107a:	90 70       	andi	r25, 0x00	; 0
    107c:	00 97       	sbiw	r24, 0x00	; 0
    107e:	19 f4       	brne	.+6      	; 0x1086 <LCDdisp_main+0xb4>
			  && ( ( Local_E_Gr & LCD_DISP_E_ALARM ) == pdFALSE )
			  && ( ( Local_E_Gr & LCD_DISP_E_IDLE ) == pdFALSE ) )
		{// Config state
			// set the state to config
			Current_state = STATE_CONFIG;
    1080:	83 e0       	ldi	r24, 0x03	; 3
    1082:	8c 83       	std	Y+4, r24	; 0x04
    1084:	14 c0       	rjmp	.+40     	; 0x10ae <LCDdisp_main+0xdc>
		}
		else if( ( ( Local_E_Gr & LCD_DISP_E_CONFIG ) == pdFALSE )
    1086:	8d 81       	ldd	r24, Y+5	; 0x05
    1088:	9e 81       	ldd	r25, Y+6	; 0x06
    108a:	81 70       	andi	r24, 0x01	; 1
    108c:	90 70       	andi	r25, 0x00	; 0
    108e:	00 97       	sbiw	r24, 0x00	; 0
    1090:	71 f4       	brne	.+28     	; 0x10ae <LCDdisp_main+0xdc>
    1092:	8d 81       	ldd	r24, Y+5	; 0x05
    1094:	9e 81       	ldd	r25, Y+6	; 0x06
    1096:	82 70       	andi	r24, 0x02	; 2
    1098:	90 70       	andi	r25, 0x00	; 0
    109a:	00 97       	sbiw	r24, 0x00	; 0
    109c:	41 f0       	breq	.+16     	; 0x10ae <LCDdisp_main+0xdc>
    109e:	8d 81       	ldd	r24, Y+5	; 0x05
    10a0:	9e 81       	ldd	r25, Y+6	; 0x06
    10a2:	84 70       	andi	r24, 0x04	; 4
    10a4:	90 70       	andi	r25, 0x00	; 0
    10a6:	00 97       	sbiw	r24, 0x00	; 0
    10a8:	11 f4       	brne	.+4      	; 0x10ae <LCDdisp_main+0xdc>
			  && ( ( Local_E_Gr & LCD_DISP_E_ALARM ) == LCD_DISP_E_ALARM )
			  && ( ( Local_E_Gr & LCD_DISP_E_IDLE ) == pdFALSE ) )
		{// Alarm state
			// set the state to alarm
			Current_state = STATE_ALARM;
    10aa:	82 e0       	ldi	r24, 0x02	; 2
    10ac:	8c 83       	std	Y+4, r24	; 0x04
		else
		{//
			// do nothing
		}
		// get the new values
		Local_Temp = Global_Temp;
    10ae:	80 91 18 02 	lds	r24, 0x0218
    10b2:	8b 83       	std	Y+3, r24	; 0x03
		Local_Threshold = Global_Threshold;
    10b4:	80 91 ee 01 	lds	r24, 0x01EE
    10b8:	8a 83       	std	Y+2, r24	; 0x02
		Local_AlarmState = Global_AlarmState;
    10ba:	80 91 ef 01 	lds	r24, 0x01EF
    10be:	89 83       	std	Y+1, r24	; 0x01
		// check system status update event
		if( ( Local_E_Gr & LCD_DISP_E_USYS_STATE ) == LCD_DISP_E_USYS_STATE )
    10c0:	8d 81       	ldd	r24, Y+5	; 0x05
    10c2:	9e 81       	ldd	r25, Y+6	; 0x06
    10c4:	80 78       	andi	r24, 0x80	; 128
    10c6:	90 70       	andi	r25, 0x00	; 0
    10c8:	00 97       	sbiw	r24, 0x00	; 0
    10ca:	f9 f0       	breq	.+62     	; 0x110a <LCDdisp_main+0x138>
		{// if true
			// update system status event
			switch( Current_state )
    10cc:	8c 81       	ldd	r24, Y+4	; 0x04
    10ce:	28 2f       	mov	r18, r24
    10d0:	30 e0       	ldi	r19, 0x00	; 0
    10d2:	3c 87       	std	Y+12, r19	; 0x0c
    10d4:	2b 87       	std	Y+11, r18	; 0x0b
    10d6:	8b 85       	ldd	r24, Y+11	; 0x0b
    10d8:	9c 85       	ldd	r25, Y+12	; 0x0c
    10da:	82 30       	cpi	r24, 0x02	; 2
    10dc:	91 05       	cpc	r25, r1
    10de:	71 f0       	breq	.+28     	; 0x10fc <LCDdisp_main+0x12a>
    10e0:	2b 85       	ldd	r18, Y+11	; 0x0b
    10e2:	3c 85       	ldd	r19, Y+12	; 0x0c
    10e4:	23 30       	cpi	r18, 0x03	; 3
    10e6:	31 05       	cpc	r19, r1
    10e8:	69 f0       	breq	.+26     	; 0x1104 <LCDdisp_main+0x132>
    10ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    10ec:	9c 85       	ldd	r25, Y+12	; 0x0c
    10ee:	81 30       	cpi	r24, 0x01	; 1
    10f0:	91 05       	cpc	r25, r1
    10f2:	59 f4       	brne	.+22     	; 0x110a <LCDdisp_main+0x138>
			{
			case STATE_IDLE:
				LCDdisp_writeScreen(LCDdisp_IDLE_SCREEN);
    10f4:	83 e0       	ldi	r24, 0x03	; 3
    10f6:	0e 94 cb 08 	call	0x1196	; 0x1196 <LCDdisp_writeScreen>
    10fa:	07 c0       	rjmp	.+14     	; 0x110a <LCDdisp_main+0x138>
				break;
			case STATE_ALARM:
				LCDdisp_writeScreen(LCDdisp_ALARM_SCREEN);
    10fc:	82 e0       	ldi	r24, 0x02	; 2
    10fe:	0e 94 cb 08 	call	0x1196	; 0x1196 <LCDdisp_writeScreen>
    1102:	03 c0       	rjmp	.+6      	; 0x110a <LCDdisp_main+0x138>
				break;
			case STATE_CONFIG:
				LCDdisp_writeScreen(LCDdisp_CONFIG_SCREEN);
    1104:	81 e0       	ldi	r24, 0x01	; 1
    1106:	0e 94 cb 08 	call	0x1196	; 0x1196 <LCDdisp_writeScreen>
		}
		else
		{

		}
		switch( Current_state )
    110a:	8c 81       	ldd	r24, Y+4	; 0x04
    110c:	28 2f       	mov	r18, r24
    110e:	30 e0       	ldi	r19, 0x00	; 0
    1110:	3a 87       	std	Y+10, r19	; 0x0a
    1112:	29 87       	std	Y+9, r18	; 0x09
    1114:	89 85       	ldd	r24, Y+9	; 0x09
    1116:	9a 85       	ldd	r25, Y+10	; 0x0a
    1118:	81 30       	cpi	r24, 0x01	; 1
    111a:	91 05       	cpc	r25, r1
    111c:	31 f0       	breq	.+12     	; 0x112a <LCDdisp_main+0x158>
    111e:	29 85       	ldd	r18, Y+9	; 0x09
    1120:	3a 85       	ldd	r19, Y+10	; 0x0a
    1122:	23 30       	cpi	r18, 0x03	; 3
    1124:	31 05       	cpc	r19, r1
    1126:	01 f1       	breq	.+64     	; 0x1168 <LCDdisp_main+0x196>
    1128:	29 c0       	rjmp	.+82     	; 0x117c <LCDdisp_main+0x1aa>
		{
		case STATE_IDLE:
			// check current temperature update event
			if( ( Local_E_Gr & LCD_DISP_E_UCURRENT_TMEP ) == LCD_DISP_E_UCURRENT_TMEP )
    112a:	8d 81       	ldd	r24, Y+5	; 0x05
    112c:	9e 81       	ldd	r25, Y+6	; 0x06
    112e:	88 70       	andi	r24, 0x08	; 8
    1130:	90 70       	andi	r25, 0x00	; 0
    1132:	00 97       	sbiw	r24, 0x00	; 0
    1134:	21 f0       	breq	.+8      	; 0x113e <LCDdisp_main+0x16c>
			{// if true
				// update current temperature
				LCDdisp_writevalue(LCDdisp_CURRENT_TEMP, Local_Temp);
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	6b 81       	ldd	r22, Y+3	; 0x03
    113a:	0e 94 38 09 	call	0x1270	; 0x1270 <LCDdisp_writevalue>
			else
			{// if false
				// do nothing
			}
			// check threshold Idle update event
			if( ( Local_E_Gr & LCD_DISP_E_UTHRESHOLD_IDLE ) == LCD_DISP_E_UTHRESHOLD_IDLE )
    113e:	8d 81       	ldd	r24, Y+5	; 0x05
    1140:	9e 81       	ldd	r25, Y+6	; 0x06
    1142:	80 72       	andi	r24, 0x20	; 32
    1144:	90 70       	andi	r25, 0x00	; 0
    1146:	00 97       	sbiw	r24, 0x00	; 0
    1148:	21 f0       	breq	.+8      	; 0x1152 <LCDdisp_main+0x180>
			{// if true
				// update threshold Idle
				LCDdisp_writevalue(LCDdisp_THRESHOLD_IDLE, Local_Threshold);
    114a:	83 e0       	ldi	r24, 0x03	; 3
    114c:	6a 81       	ldd	r22, Y+2	; 0x02
    114e:	0e 94 38 09 	call	0x1270	; 0x1270 <LCDdisp_writevalue>
			else
			{// if false
				// do nothing
			}
			// check Alarm state update event
			if( ( Local_E_Gr & LCD_DISP_E_UALARM_STATE ) == LCD_DISP_E_UALARM_STATE )
    1152:	8d 81       	ldd	r24, Y+5	; 0x05
    1154:	9e 81       	ldd	r25, Y+6	; 0x06
    1156:	80 74       	andi	r24, 0x40	; 64
    1158:	90 70       	andi	r25, 0x00	; 0
    115a:	00 97       	sbiw	r24, 0x00	; 0
    115c:	79 f0       	breq	.+30     	; 0x117c <LCDdisp_main+0x1aa>
			{// if true
				// update Alarm state
				LCDdisp_writevalue(LCDdisp_ALARM_STATE, Local_AlarmState);
    115e:	84 e0       	ldi	r24, 0x04	; 4
    1160:	69 81       	ldd	r22, Y+1	; 0x01
    1162:	0e 94 38 09 	call	0x1270	; 0x1270 <LCDdisp_writevalue>
    1166:	0a c0       	rjmp	.+20     	; 0x117c <LCDdisp_main+0x1aa>
				// do nothing
			}
			break;
		case STATE_CONFIG:
			// check threshold config update event
			if( ( Local_E_Gr & LCD_DISP_E_UTHRESHOLD_CONFIG ) == LCD_DISP_E_UTHRESHOLD_CONFIG )
    1168:	8d 81       	ldd	r24, Y+5	; 0x05
    116a:	9e 81       	ldd	r25, Y+6	; 0x06
    116c:	80 71       	andi	r24, 0x10	; 16
    116e:	90 70       	andi	r25, 0x00	; 0
    1170:	00 97       	sbiw	r24, 0x00	; 0
    1172:	21 f0       	breq	.+8      	; 0x117c <LCDdisp_main+0x1aa>
			{// if true
				// update threshold config
				LCDdisp_writevalue(LCDdisp_THERSHOLD_CONFIG, Local_Threshold);
    1174:	82 e0       	ldi	r24, 0x02	; 2
    1176:	6a 81       	ldd	r22, Y+2	; 0x02
    1178:	0e 94 38 09 	call	0x1270	; 0x1270 <LCDdisp_writevalue>
		default:
			// do nothing
			break;
		}
		// wait and clear the event bits
		xEventGroupWaitBits(E_Gr,
    117c:	80 91 d1 04 	lds	r24, 0x04D1
    1180:	90 91 d2 04 	lds	r25, 0x04D2
    1184:	68 ef       	ldi	r22, 0xF8	; 248
    1186:	70 e0       	ldi	r23, 0x00	; 0
    1188:	41 e0       	ldi	r20, 0x01	; 1
    118a:	20 e0       	ldi	r18, 0x00	; 0
    118c:	0f ef       	ldi	r16, 0xFF	; 255
    118e:	1f ef       	ldi	r17, 0xFF	; 255
    1190:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <xEventGroupWaitBits>
    1194:	41 cf       	rjmp	.-382    	; 0x1018 <LCDdisp_main+0x46>

00001196 <LCDdisp_writeScreen>:
							portMAX_DELAY);
	}
}

void LCDdisp_writeScreen( u8 copy_u8ScreenID )
{
    1196:	df 93       	push	r29
    1198:	cf 93       	push	r28
    119a:	00 d0       	rcall	.+0      	; 0x119c <LCDdisp_writeScreen+0x6>
    119c:	0f 92       	push	r0
    119e:	cd b7       	in	r28, 0x3d	; 61
    11a0:	de b7       	in	r29, 0x3e	; 62
    11a2:	89 83       	std	Y+1, r24	; 0x01
	switch( copy_u8ScreenID )
    11a4:	89 81       	ldd	r24, Y+1	; 0x01
    11a6:	28 2f       	mov	r18, r24
    11a8:	30 e0       	ldi	r19, 0x00	; 0
    11aa:	3b 83       	std	Y+3, r19	; 0x03
    11ac:	2a 83       	std	Y+2, r18	; 0x02
    11ae:	8a 81       	ldd	r24, Y+2	; 0x02
    11b0:	9b 81       	ldd	r25, Y+3	; 0x03
    11b2:	82 30       	cpi	r24, 0x02	; 2
    11b4:	91 05       	cpc	r25, r1
    11b6:	09 f4       	brne	.+2      	; 0x11ba <LCDdisp_writeScreen+0x24>
    11b8:	45 c0       	rjmp	.+138    	; 0x1244 <LCDdisp_writeScreen+0xae>
    11ba:	2a 81       	ldd	r18, Y+2	; 0x02
    11bc:	3b 81       	ldd	r19, Y+3	; 0x03
    11be:	23 30       	cpi	r18, 0x03	; 3
    11c0:	31 05       	cpc	r19, r1
    11c2:	31 f0       	breq	.+12     	; 0x11d0 <LCDdisp_writeScreen+0x3a>
    11c4:	8a 81       	ldd	r24, Y+2	; 0x02
    11c6:	9b 81       	ldd	r25, Y+3	; 0x03
    11c8:	81 30       	cpi	r24, 0x01	; 1
    11ca:	91 05       	cpc	r25, r1
    11cc:	21 f1       	breq	.+72     	; 0x1216 <LCDdisp_writeScreen+0x80>
    11ce:	4a c0       	rjmp	.+148    	; 0x1264 <LCDdisp_writeScreen+0xce>
	{
	case LCDdisp_IDLE_SCREEN:
		LCD_set_cursor(LINE1_LOC);
    11d0:	80 e0       	ldi	r24, 0x00	; 0
    11d2:	60 e0       	ldi	r22, 0x00	; 0
    11d4:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_str((u8*)"C:    T:    AS: ");
    11d8:	8f e6       	ldi	r24, 0x6F	; 111
    11da:	90 e0       	ldi	r25, 0x00	; 0
    11dc:	0e 94 81 4a 	call	0x9502	; 0x9502 <LCD_write_str>
		LCD_set_cursor(LINE2_LOC);
    11e0:	81 e0       	ldi	r24, 0x01	; 1
    11e2:	60 e0       	ldi	r22, 0x00	; 0
    11e4:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_str((u8*)"  TC:C   AST:T  ");
    11e8:	80 e8       	ldi	r24, 0x80	; 128
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	0e 94 81 4a 	call	0x9502	; 0x9502 <LCD_write_str>
		LCDdisp_writevalue(LCDdisp_CURRENT_TEMP, Global_Temp);
    11f0:	90 91 18 02 	lds	r25, 0x0218
    11f4:	81 e0       	ldi	r24, 0x01	; 1
    11f6:	69 2f       	mov	r22, r25
    11f8:	0e 94 38 09 	call	0x1270	; 0x1270 <LCDdisp_writevalue>
		LCDdisp_writevalue(LCDdisp_THRESHOLD_IDLE, Global_Threshold);
    11fc:	90 91 ee 01 	lds	r25, 0x01EE
    1200:	83 e0       	ldi	r24, 0x03	; 3
    1202:	69 2f       	mov	r22, r25
    1204:	0e 94 38 09 	call	0x1270	; 0x1270 <LCDdisp_writevalue>
		LCDdisp_writevalue(LCDdisp_ALARM_STATE, Global_AlarmState);
    1208:	90 91 ef 01 	lds	r25, 0x01EF
    120c:	84 e0       	ldi	r24, 0x04	; 4
    120e:	69 2f       	mov	r22, r25
    1210:	0e 94 38 09 	call	0x1270	; 0x1270 <LCDdisp_writevalue>
    1214:	27 c0       	rjmp	.+78     	; 0x1264 <LCDdisp_writeScreen+0xce>
		break;
	case LCDdisp_CONFIG_SCREEN:
		LCD_set_cursor(LINE1_LOC);
    1216:	80 e0       	ldi	r24, 0x00	; 0
    1218:	60 e0       	ldi	r22, 0x00	; 0
    121a:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_str((u8*)"      T:        ");
    121e:	81 e9       	ldi	r24, 0x91	; 145
    1220:	90 e0       	ldi	r25, 0x00	; 0
    1222:	0e 94 81 4a 	call	0x9502	; 0x9502 <LCD_write_str>
		LCD_set_cursor(LINE2_LOC);
    1226:	81 e0       	ldi	r24, 0x01	; 1
    1228:	60 e0       	ldi	r22, 0x00	; 0
    122a:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_str((u8*)"  OK:O    CN:C  ");
    122e:	82 ea       	ldi	r24, 0xA2	; 162
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	0e 94 81 4a 	call	0x9502	; 0x9502 <LCD_write_str>
		LCDdisp_writevalue(LCDdisp_THERSHOLD_CONFIG, Global_Threshold);
    1236:	90 91 ee 01 	lds	r25, 0x01EE
    123a:	82 e0       	ldi	r24, 0x02	; 2
    123c:	69 2f       	mov	r22, r25
    123e:	0e 94 38 09 	call	0x1270	; 0x1270 <LCDdisp_writevalue>
    1242:	10 c0       	rjmp	.+32     	; 0x1264 <LCDdisp_writeScreen+0xce>
		break;
	case LCDdisp_ALARM_SCREEN:
		LCD_set_cursor(LINE1_LOC);
    1244:	80 e0       	ldi	r24, 0x00	; 0
    1246:	60 e0       	ldi	r22, 0x00	; 0
    1248:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_str((u8*)" !!!ALARMING!!! ");
    124c:	83 eb       	ldi	r24, 0xB3	; 179
    124e:	90 e0       	ldi	r25, 0x00	; 0
    1250:	0e 94 81 4a 	call	0x9502	; 0x9502 <LCD_write_str>
		LCD_set_cursor(LINE2_LOC);
    1254:	81 e0       	ldi	r24, 0x01	; 1
    1256:	60 e0       	ldi	r22, 0x00	; 0
    1258:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_str((u8*)"      AS:S      ");
    125c:	84 ec       	ldi	r24, 0xC4	; 196
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	0e 94 81 4a 	call	0x9502	; 0x9502 <LCD_write_str>
		break;
	default:
		break;
	}
}
    1264:	0f 90       	pop	r0
    1266:	0f 90       	pop	r0
    1268:	0f 90       	pop	r0
    126a:	cf 91       	pop	r28
    126c:	df 91       	pop	r29
    126e:	08 95       	ret

00001270 <LCDdisp_writevalue>:

void LCDdisp_writevalue( u8 copy_u8ValueID, u8 copy_u8Value )
{
    1270:	df 93       	push	r29
    1272:	cf 93       	push	r28
    1274:	00 d0       	rcall	.+0      	; 0x1276 <LCDdisp_writevalue+0x6>
    1276:	00 d0       	rcall	.+0      	; 0x1278 <LCDdisp_writevalue+0x8>
    1278:	cd b7       	in	r28, 0x3d	; 61
    127a:	de b7       	in	r29, 0x3e	; 62
    127c:	89 83       	std	Y+1, r24	; 0x01
    127e:	6a 83       	std	Y+2, r22	; 0x02
	switch( copy_u8ValueID )
    1280:	89 81       	ldd	r24, Y+1	; 0x01
    1282:	28 2f       	mov	r18, r24
    1284:	30 e0       	ldi	r19, 0x00	; 0
    1286:	3c 83       	std	Y+4, r19	; 0x04
    1288:	2b 83       	std	Y+3, r18	; 0x03
    128a:	8b 81       	ldd	r24, Y+3	; 0x03
    128c:	9c 81       	ldd	r25, Y+4	; 0x04
    128e:	82 30       	cpi	r24, 0x02	; 2
    1290:	91 05       	cpc	r25, r1
    1292:	21 f1       	breq	.+72     	; 0x12dc <LCDdisp_writevalue+0x6c>
    1294:	2b 81       	ldd	r18, Y+3	; 0x03
    1296:	3c 81       	ldd	r19, Y+4	; 0x04
    1298:	23 30       	cpi	r18, 0x03	; 3
    129a:	31 05       	cpc	r19, r1
    129c:	34 f4       	brge	.+12     	; 0x12aa <LCDdisp_writevalue+0x3a>
    129e:	8b 81       	ldd	r24, Y+3	; 0x03
    12a0:	9c 81       	ldd	r25, Y+4	; 0x04
    12a2:	81 30       	cpi	r24, 0x01	; 1
    12a4:	91 05       	cpc	r25, r1
    12a6:	61 f0       	breq	.+24     	; 0x12c0 <LCDdisp_writevalue+0x50>
    12a8:	42 c0       	rjmp	.+132    	; 0x132e <LCDdisp_writevalue+0xbe>
    12aa:	2b 81       	ldd	r18, Y+3	; 0x03
    12ac:	3c 81       	ldd	r19, Y+4	; 0x04
    12ae:	23 30       	cpi	r18, 0x03	; 3
    12b0:	31 05       	cpc	r19, r1
    12b2:	11 f1       	breq	.+68     	; 0x12f8 <LCDdisp_writevalue+0x88>
    12b4:	8b 81       	ldd	r24, Y+3	; 0x03
    12b6:	9c 81       	ldd	r25, Y+4	; 0x04
    12b8:	84 30       	cpi	r24, 0x04	; 4
    12ba:	91 05       	cpc	r25, r1
    12bc:	59 f1       	breq	.+86     	; 0x1314 <LCDdisp_writevalue+0xa4>
    12be:	37 c0       	rjmp	.+110    	; 0x132e <LCDdisp_writevalue+0xbe>
	{
	case LCDdisp_CURRENT_TEMP:
		LCD_set_cursor(CURRENT_TEMP_LOC);
    12c0:	80 e0       	ldi	r24, 0x00	; 0
    12c2:	62 e0       	ldi	r22, 0x02	; 2
    12c4:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_s32_number(copy_u8Value);
    12c8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ca:	88 2f       	mov	r24, r24
    12cc:	90 e0       	ldi	r25, 0x00	; 0
    12ce:	a0 e0       	ldi	r26, 0x00	; 0
    12d0:	b0 e0       	ldi	r27, 0x00	; 0
    12d2:	bc 01       	movw	r22, r24
    12d4:	cd 01       	movw	r24, r26
    12d6:	0e 94 aa 4a 	call	0x9554	; 0x9554 <LCD_write_s32_number>
    12da:	29 c0       	rjmp	.+82     	; 0x132e <LCDdisp_writevalue+0xbe>
		break;
	case LCDdisp_THERSHOLD_CONFIG:
		LCD_set_cursor(THERSHOLD_CONFIG_LOC);
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	69 e0       	ldi	r22, 0x09	; 9
    12e0:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_s32_number(copy_u8Value);
    12e4:	8a 81       	ldd	r24, Y+2	; 0x02
    12e6:	88 2f       	mov	r24, r24
    12e8:	90 e0       	ldi	r25, 0x00	; 0
    12ea:	a0 e0       	ldi	r26, 0x00	; 0
    12ec:	b0 e0       	ldi	r27, 0x00	; 0
    12ee:	bc 01       	movw	r22, r24
    12f0:	cd 01       	movw	r24, r26
    12f2:	0e 94 aa 4a 	call	0x9554	; 0x9554 <LCD_write_s32_number>
    12f6:	1b c0       	rjmp	.+54     	; 0x132e <LCDdisp_writevalue+0xbe>
		break;
	case LCDdisp_THRESHOLD_IDLE:
		LCD_set_cursor(THRESHOLD_IDLE_LOC);
    12f8:	80 e0       	ldi	r24, 0x00	; 0
    12fa:	69 e0       	ldi	r22, 0x09	; 9
    12fc:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_s32_number(copy_u8Value);
    1300:	8a 81       	ldd	r24, Y+2	; 0x02
    1302:	88 2f       	mov	r24, r24
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	a0 e0       	ldi	r26, 0x00	; 0
    1308:	b0 e0       	ldi	r27, 0x00	; 0
    130a:	bc 01       	movw	r22, r24
    130c:	cd 01       	movw	r24, r26
    130e:	0e 94 aa 4a 	call	0x9554	; 0x9554 <LCD_write_s32_number>
    1312:	0d c0       	rjmp	.+26     	; 0x132e <LCDdisp_writevalue+0xbe>
		break;
	case LCDdisp_ALARM_STATE:
		LCD_set_cursor(ALARM_STATE_LOC);
    1314:	80 e0       	ldi	r24, 0x00	; 0
    1316:	6f e0       	ldi	r22, 0x0F	; 15
    1318:	0e 94 5d 46 	call	0x8cba	; 0x8cba <LCD_set_cursor>
		LCD_write_s32_number(copy_u8Value);
    131c:	8a 81       	ldd	r24, Y+2	; 0x02
    131e:	88 2f       	mov	r24, r24
    1320:	90 e0       	ldi	r25, 0x00	; 0
    1322:	a0 e0       	ldi	r26, 0x00	; 0
    1324:	b0 e0       	ldi	r27, 0x00	; 0
    1326:	bc 01       	movw	r22, r24
    1328:	cd 01       	movw	r24, r26
    132a:	0e 94 aa 4a 	call	0x9554	; 0x9554 <LCD_write_s32_number>
		break;
	default:
		break;
	}
}
    132e:	0f 90       	pop	r0
    1330:	0f 90       	pop	r0
    1332:	0f 90       	pop	r0
    1334:	0f 90       	pop	r0
    1336:	cf 91       	pop	r28
    1338:	df 91       	pop	r29
    133a:	08 95       	ret

0000133c <TempUpdate_init>:
u8 Global_Temp = 0;
extern u8 Global_Threshold;
extern EventGroupHandle_t E_Gr;

void TempUpdate_init( void )
{
    133c:	ef 92       	push	r14
    133e:	ff 92       	push	r15
    1340:	0f 93       	push	r16
    1342:	df 93       	push	r29
    1344:	cf 93       	push	r28
    1346:	cd b7       	in	r28, 0x3d	; 61
    1348:	de b7       	in	r29, 0x3e	; 62
	// initiate temperature driver
	Temp_sensor_voidInit(0);
    134a:	80 e0       	ldi	r24, 0x00	; 0
    134c:	0e 94 51 29 	call	0x52a2	; 0x52a2 <Temp_sensor_voidInit>
	// get initial value
	Global_Temp = ( u8 ) Temp_sensor_voidClcTemp();
    1350:	0e 94 6a 29 	call	0x52d4	; 0x52d4 <Temp_sensor_voidClcTemp>
    1354:	dc 01       	movw	r26, r24
    1356:	cb 01       	movw	r24, r22
    1358:	bc 01       	movw	r22, r24
    135a:	cd 01       	movw	r24, r26
    135c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1360:	dc 01       	movw	r26, r24
    1362:	cb 01       	movw	r24, r22
    1364:	80 93 18 02 	sts	0x0218, r24
	// Set the state to Idle

	// Create update temperature main task
	xTaskCreate(TempUpdate_main, "Update_Temp", TAMP_UPDATE_STACK, NULL, TAMP_UPDATE_PRIORITY, NULL);
    1368:	88 ec       	ldi	r24, 0xC8	; 200
    136a:	99 e0       	ldi	r25, 0x09	; 9
    136c:	25 ed       	ldi	r18, 0xD5	; 213
    136e:	30 e0       	ldi	r19, 0x00	; 0
    1370:	b9 01       	movw	r22, r18
    1372:	45 e5       	ldi	r20, 0x55	; 85
    1374:	50 e0       	ldi	r21, 0x00	; 0
    1376:	20 e0       	ldi	r18, 0x00	; 0
    1378:	30 e0       	ldi	r19, 0x00	; 0
    137a:	03 e0       	ldi	r16, 0x03	; 3
    137c:	ee 24       	eor	r14, r14
    137e:	ff 24       	eor	r15, r15
    1380:	0e 94 03 19 	call	0x3206	; 0x3206 <xTaskCreate>
}
    1384:	cf 91       	pop	r28
    1386:	df 91       	pop	r29
    1388:	0f 91       	pop	r16
    138a:	ff 90       	pop	r15
    138c:	ef 90       	pop	r14
    138e:	08 95       	ret

00001390 <TempUpdate_main>:

void TempUpdate_main( void* pvParameters)
{
    1390:	df 93       	push	r29
    1392:	cf 93       	push	r28
    1394:	00 d0       	rcall	.+0      	; 0x1396 <TempUpdate_main+0x6>
    1396:	0f 92       	push	r0
    1398:	cd b7       	in	r28, 0x3d	; 61
    139a:	de b7       	in	r29, 0x3e	; 62
    139c:	9b 83       	std	Y+3, r25	; 0x03
    139e:	8a 83       	std	Y+2, r24	; 0x02
	// Setup section
	u8 Local_Temp = 0;
    13a0:	19 82       	std	Y+1, r1	; 0x01
	while( 1 )
	{
		// Loop section
		// get the initial reading
		Local_Temp = ( u8 ) Temp_sensor_voidClcTemp();
    13a2:	0e 94 6a 29 	call	0x52d4	; 0x52d4 <Temp_sensor_voidClcTemp>
    13a6:	dc 01       	movw	r26, r24
    13a8:	cb 01       	movw	r24, r22
    13aa:	bc 01       	movw	r22, r24
    13ac:	cd 01       	movw	r24, r26
    13ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    13b2:	dc 01       	movw	r26, r24
    13b4:	cb 01       	movw	r24, r22
    13b6:	89 83       	std	Y+1, r24	; 0x01
		// Check if the value is changed
		if( Global_Temp != Local_Temp )
    13b8:	90 91 18 02 	lds	r25, 0x0218
    13bc:	89 81       	ldd	r24, Y+1	; 0x01
    13be:	98 17       	cp	r25, r24
    13c0:	41 f0       	breq	.+16     	; 0x13d2 <TempUpdate_main+0x42>
		{// if changed
			// check the state
			if( 1 )
			{// If Idle
				// Compare with the threshold
				if( Local_Temp > Global_Threshold )
    13c2:	90 91 ee 01 	lds	r25, 0x01EE
    13c6:	89 81       	ldd	r24, Y+1	; 0x01
    13c8:	98 17       	cp	r25, r24
    13ca:	18 f0       	brcs	.+6      	; 0x13d2 <TempUpdate_main+0x42>
					}
				}
				else
				{// if the temperature within range
					// copy to the global variable
					Global_Temp = Local_Temp;
    13cc:	89 81       	ldd	r24, Y+1	; 0x01
    13ce:	80 93 18 02 	sts	0x0218, r24
		else
		{// if same value
			// do nothing
		}
		// Delay 100 ticks
		vTaskDelay( 100 );
    13d2:	84 e6       	ldi	r24, 0x64	; 100
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskDelay>
    13da:	e3 cf       	rjmp	.-58     	; 0x13a2 <TempUpdate_main+0x12>

000013dc <UserInput_init>:
u8 Global_Threshold = 100;
u8 Global_AlarmState = 1;
extern EventGroupHandle_t E_Gr;

void UserInput_init( void )
{
    13dc:	df 93       	push	r29
    13de:	cf 93       	push	r28
    13e0:	cd b7       	in	r28, 0x3d	; 61
    13e2:	de b7       	in	r29, 0x3e	; 62

}
    13e4:	cf 91       	pop	r28
    13e6:	df 91       	pop	r29
    13e8:	08 95       	ret

000013ea <UserInput_main>:


void UserInput_main( void* pvParameters )
{
    13ea:	df 93       	push	r29
    13ec:	cf 93       	push	r28
    13ee:	00 d0       	rcall	.+0      	; 0x13f0 <UserInput_main+0x6>
    13f0:	cd b7       	in	r28, 0x3d	; 61
    13f2:	de b7       	in	r29, 0x3e	; 62
    13f4:	9a 83       	std	Y+2, r25	; 0x02
    13f6:	89 83       	std	Y+1, r24	; 0x01

}
    13f8:	0f 90       	pop	r0
    13fa:	0f 90       	pop	r0
    13fc:	cf 91       	pop	r28
    13fe:	df 91       	pop	r29
    1400:	08 95       	ret

00001402 <main>:
// Global variable
EventGroupHandle_t E_Gr;

// Main function
int main( void )
{
    1402:	df 93       	push	r29
    1404:	cf 93       	push	r28
    1406:	cd b7       	in	r28, 0x3d	; 61
    1408:	de b7       	in	r29, 0x3e	; 62
	// Setup section

	E_Gr = xEventGroupCreate();
    140a:	0e 94 16 0a 	call	0x142c	; 0x142c <xEventGroupCreate>
    140e:	90 93 d2 04 	sts	0x04D2, r25
    1412:	80 93 d1 04 	sts	0x04D1, r24

	TempUpdate_init();
    1416:	0e 94 9e 09 	call	0x133c	; 0x133c <TempUpdate_init>
	LCDdisp_init();
    141a:	0e 94 cc 07 	call	0xf98	; 0xf98 <LCDdisp_init>
	Alarm_init();
    141e:	0e 94 75 07 	call	0xeea	; 0xeea <Alarm_init>
	UserInput_init();
    1422:	0e 94 ee 09 	call	0x13dc	; 0x13dc <UserInput_init>

	vTaskStartScheduler();
    1426:	0e 94 43 1b 	call	0x3686	; 0x3686 <vTaskStartScheduler>
    142a:	ff cf       	rjmp	.-2      	; 0x142a <main+0x28>

0000142c <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    142c:	df 93       	push	r29
    142e:	cf 93       	push	r28
    1430:	00 d0       	rcall	.+0      	; 0x1432 <xEventGroupCreate+0x6>
    1432:	cd b7       	in	r28, 0x3d	; 61
    1434:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1436:	8b e0       	ldi	r24, 0x0B	; 11
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <pvPortMalloc>
    143e:	9a 83       	std	Y+2, r25	; 0x02
    1440:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    1442:	89 81       	ldd	r24, Y+1	; 0x01
    1444:	9a 81       	ldd	r25, Y+2	; 0x02
    1446:	00 97       	sbiw	r24, 0x00	; 0
    1448:	49 f0       	breq	.+18     	; 0x145c <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    144a:	e9 81       	ldd	r30, Y+1	; 0x01
    144c:	fa 81       	ldd	r31, Y+2	; 0x02
    144e:	11 82       	std	Z+1, r1	; 0x01
    1450:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1452:	89 81       	ldd	r24, Y+1	; 0x01
    1454:	9a 81       	ldd	r25, Y+2	; 0x02
    1456:	02 96       	adiw	r24, 0x02	; 2
    1458:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    145c:	89 81       	ldd	r24, Y+1	; 0x01
    145e:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1460:	0f 90       	pop	r0
    1462:	0f 90       	pop	r0
    1464:	cf 91       	pop	r28
    1466:	df 91       	pop	r29
    1468:	08 95       	ret

0000146a <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    146a:	df 93       	push	r29
    146c:	cf 93       	push	r28
    146e:	cd b7       	in	r28, 0x3d	; 61
    1470:	de b7       	in	r29, 0x3e	; 62
    1472:	60 97       	sbiw	r28, 0x10	; 16
    1474:	0f b6       	in	r0, 0x3f	; 63
    1476:	f8 94       	cli
    1478:	de bf       	out	0x3e, r29	; 62
    147a:	0f be       	out	0x3f, r0	; 63
    147c:	cd bf       	out	0x3d, r28	; 61
    147e:	9a 87       	std	Y+10, r25	; 0x0a
    1480:	89 87       	std	Y+9, r24	; 0x09
    1482:	7c 87       	std	Y+12, r23	; 0x0c
    1484:	6b 87       	std	Y+11, r22	; 0x0b
    1486:	5e 87       	std	Y+14, r21	; 0x0e
    1488:	4d 87       	std	Y+13, r20	; 0x0d
    148a:	38 8b       	std	Y+16, r19	; 0x10
    148c:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    148e:	89 85       	ldd	r24, Y+9	; 0x09
    1490:	9a 85       	ldd	r25, Y+10	; 0x0a
    1492:	9c 83       	std	Y+4, r25	; 0x04
    1494:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1496:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1498:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    149c:	eb 81       	ldd	r30, Y+3	; 0x03
    149e:	fc 81       	ldd	r31, Y+4	; 0x04
    14a0:	80 81       	ld	r24, Z
    14a2:	91 81       	ldd	r25, Z+1	; 0x01
    14a4:	98 87       	std	Y+8, r25	; 0x08
    14a6:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    14a8:	89 85       	ldd	r24, Y+9	; 0x09
    14aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    14ac:	2b 85       	ldd	r18, Y+11	; 0x0b
    14ae:	3c 85       	ldd	r19, Y+12	; 0x0c
    14b0:	b9 01       	movw	r22, r18
    14b2:	0e 94 0c 0c 	call	0x1818	; 0x1818 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    14b6:	2f 81       	ldd	r18, Y+7	; 0x07
    14b8:	38 85       	ldd	r19, Y+8	; 0x08
    14ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    14bc:	9c 85       	ldd	r25, Y+12	; 0x0c
    14be:	28 2b       	or	r18, r24
    14c0:	39 2b       	or	r19, r25
    14c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    14c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    14c6:	28 23       	and	r18, r24
    14c8:	39 23       	and	r19, r25
    14ca:	8d 85       	ldd	r24, Y+13	; 0x0d
    14cc:	9e 85       	ldd	r25, Y+14	; 0x0e
    14ce:	28 17       	cp	r18, r24
    14d0:	39 07       	cpc	r19, r25
    14d2:	c9 f4       	brne	.+50     	; 0x1506 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    14d4:	2f 81       	ldd	r18, Y+7	; 0x07
    14d6:	38 85       	ldd	r19, Y+8	; 0x08
    14d8:	8b 85       	ldd	r24, Y+11	; 0x0b
    14da:	9c 85       	ldd	r25, Y+12	; 0x0c
    14dc:	82 2b       	or	r24, r18
    14de:	93 2b       	or	r25, r19
    14e0:	9e 83       	std	Y+6, r25	; 0x06
    14e2:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    14e4:	eb 81       	ldd	r30, Y+3	; 0x03
    14e6:	fc 81       	ldd	r31, Y+4	; 0x04
    14e8:	20 81       	ld	r18, Z
    14ea:	31 81       	ldd	r19, Z+1	; 0x01
    14ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    14ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    14f0:	80 95       	com	r24
    14f2:	90 95       	com	r25
    14f4:	82 23       	and	r24, r18
    14f6:	93 23       	and	r25, r19
    14f8:	eb 81       	ldd	r30, Y+3	; 0x03
    14fa:	fc 81       	ldd	r31, Y+4	; 0x04
    14fc:	91 83       	std	Z+1, r25	; 0x01
    14fe:	80 83       	st	Z, r24

			xTicksToWait = 0;
    1500:	18 8a       	std	Y+16, r1	; 0x10
    1502:	1f 86       	std	Y+15, r1	; 0x0f
    1504:	1e c0       	rjmp	.+60     	; 0x1542 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1506:	8f 85       	ldd	r24, Y+15	; 0x0f
    1508:	98 89       	ldd	r25, Y+16	; 0x10
    150a:	00 97       	sbiw	r24, 0x00	; 0
    150c:	91 f0       	breq	.+36     	; 0x1532 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    150e:	8b 81       	ldd	r24, Y+3	; 0x03
    1510:	9c 81       	ldd	r25, Y+4	; 0x04
    1512:	bc 01       	movw	r22, r24
    1514:	6e 5f       	subi	r22, 0xFE	; 254
    1516:	7f 4f       	sbci	r23, 0xFF	; 255
    1518:	8d 85       	ldd	r24, Y+13	; 0x0d
    151a:	9e 85       	ldd	r25, Y+14	; 0x0e
    151c:	9c 01       	movw	r18, r24
    151e:	35 60       	ori	r19, 0x05	; 5
    1520:	4f 85       	ldd	r20, Y+15	; 0x0f
    1522:	58 89       	ldd	r21, Y+16	; 0x10
    1524:	cb 01       	movw	r24, r22
    1526:	b9 01       	movw	r22, r18
    1528:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    152c:	1e 82       	std	Y+6, r1	; 0x06
    152e:	1d 82       	std	Y+5, r1	; 0x05
    1530:	08 c0       	rjmp	.+16     	; 0x1542 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1532:	eb 81       	ldd	r30, Y+3	; 0x03
    1534:	fc 81       	ldd	r31, Y+4	; 0x04
    1536:	80 81       	ld	r24, Z
    1538:	91 81       	ldd	r25, Z+1	; 0x01
    153a:	9e 83       	std	Y+6, r25	; 0x06
    153c:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    153e:	81 e0       	ldi	r24, 0x01	; 1
    1540:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1542:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    1546:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    1548:	8f 85       	ldd	r24, Y+15	; 0x0f
    154a:	98 89       	ldd	r25, Y+16	; 0x10
    154c:	00 97       	sbiw	r24, 0x00	; 0
    154e:	09 f4       	brne	.+2      	; 0x1552 <xEventGroupSync+0xe8>
    1550:	3a c0       	rjmp	.+116    	; 0x15c6 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    1552:	8a 81       	ldd	r24, Y+2	; 0x02
    1554:	88 23       	and	r24, r24
    1556:	11 f4       	brne	.+4      	; 0x155c <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    1558:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    155c:	0e 94 02 20 	call	0x4004	; 0x4004 <uxTaskResetEventItemValue>
    1560:	9e 83       	std	Y+6, r25	; 0x06
    1562:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1564:	8d 81       	ldd	r24, Y+5	; 0x05
    1566:	9e 81       	ldd	r25, Y+6	; 0x06
    1568:	80 70       	andi	r24, 0x00	; 0
    156a:	92 70       	andi	r25, 0x02	; 2
    156c:	00 97       	sbiw	r24, 0x00	; 0
    156e:	31 f5       	brne	.+76     	; 0x15bc <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1570:	0f b6       	in	r0, 0x3f	; 63
    1572:	f8 94       	cli
    1574:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1576:	eb 81       	ldd	r30, Y+3	; 0x03
    1578:	fc 81       	ldd	r31, Y+4	; 0x04
    157a:	80 81       	ld	r24, Z
    157c:	91 81       	ldd	r25, Z+1	; 0x01
    157e:	9e 83       	std	Y+6, r25	; 0x06
    1580:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1582:	2d 81       	ldd	r18, Y+5	; 0x05
    1584:	3e 81       	ldd	r19, Y+6	; 0x06
    1586:	8d 85       	ldd	r24, Y+13	; 0x0d
    1588:	9e 85       	ldd	r25, Y+14	; 0x0e
    158a:	28 23       	and	r18, r24
    158c:	39 23       	and	r19, r25
    158e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1590:	9e 85       	ldd	r25, Y+14	; 0x0e
    1592:	28 17       	cp	r18, r24
    1594:	39 07       	cpc	r19, r25
    1596:	71 f4       	brne	.+28     	; 0x15b4 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1598:	eb 81       	ldd	r30, Y+3	; 0x03
    159a:	fc 81       	ldd	r31, Y+4	; 0x04
    159c:	20 81       	ld	r18, Z
    159e:	31 81       	ldd	r19, Z+1	; 0x01
    15a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    15a2:	9e 85       	ldd	r25, Y+14	; 0x0e
    15a4:	80 95       	com	r24
    15a6:	90 95       	com	r25
    15a8:	82 23       	and	r24, r18
    15aa:	93 23       	and	r25, r19
    15ac:	eb 81       	ldd	r30, Y+3	; 0x03
    15ae:	fc 81       	ldd	r31, Y+4	; 0x04
    15b0:	91 83       	std	Z+1, r25	; 0x01
    15b2:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    15b4:	0f 90       	pop	r0
    15b6:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    15b8:	81 e0       	ldi	r24, 0x01	; 1
    15ba:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    15bc:	8d 81       	ldd	r24, Y+5	; 0x05
    15be:	9e 81       	ldd	r25, Y+6	; 0x06
    15c0:	90 70       	andi	r25, 0x00	; 0
    15c2:	9e 83       	std	Y+6, r25	; 0x06
    15c4:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    15c6:	8d 81       	ldd	r24, Y+5	; 0x05
    15c8:	9e 81       	ldd	r25, Y+6	; 0x06
}
    15ca:	60 96       	adiw	r28, 0x10	; 16
    15cc:	0f b6       	in	r0, 0x3f	; 63
    15ce:	f8 94       	cli
    15d0:	de bf       	out	0x3e, r29	; 62
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	cd bf       	out	0x3d, r28	; 61
    15d6:	cf 91       	pop	r28
    15d8:	df 91       	pop	r29
    15da:	08 95       	ret

000015dc <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    15dc:	0f 93       	push	r16
    15de:	1f 93       	push	r17
    15e0:	df 93       	push	r29
    15e2:	cf 93       	push	r28
    15e4:	cd b7       	in	r28, 0x3d	; 61
    15e6:	de b7       	in	r29, 0x3e	; 62
    15e8:	63 97       	sbiw	r28, 0x13	; 19
    15ea:	0f b6       	in	r0, 0x3f	; 63
    15ec:	f8 94       	cli
    15ee:	de bf       	out	0x3e, r29	; 62
    15f0:	0f be       	out	0x3f, r0	; 63
    15f2:	cd bf       	out	0x3d, r28	; 61
    15f4:	9d 87       	std	Y+13, r25	; 0x0d
    15f6:	8c 87       	std	Y+12, r24	; 0x0c
    15f8:	7f 87       	std	Y+15, r23	; 0x0f
    15fa:	6e 87       	std	Y+14, r22	; 0x0e
    15fc:	48 8b       	std	Y+16, r20	; 0x10
    15fe:	29 8b       	std	Y+17, r18	; 0x11
    1600:	1b 8b       	std	Y+19, r17	; 0x13
    1602:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    1604:	8c 85       	ldd	r24, Y+12	; 0x0c
    1606:	9d 85       	ldd	r25, Y+13	; 0x0d
    1608:	9b 87       	std	Y+11, r25	; 0x0b
    160a:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    160c:	1f 82       	std	Y+7, r1	; 0x07
    160e:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1610:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1612:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1616:	ea 85       	ldd	r30, Y+10	; 0x0a
    1618:	fb 85       	ldd	r31, Y+11	; 0x0b
    161a:	80 81       	ld	r24, Z
    161c:	91 81       	ldd	r25, Z+1	; 0x01
    161e:	9a 83       	std	Y+2, r25	; 0x02
    1620:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1622:	89 81       	ldd	r24, Y+1	; 0x01
    1624:	9a 81       	ldd	r25, Y+2	; 0x02
    1626:	2e 85       	ldd	r18, Y+14	; 0x0e
    1628:	3f 85       	ldd	r19, Y+15	; 0x0f
    162a:	b9 01       	movw	r22, r18
    162c:	49 89       	ldd	r20, Y+17	; 0x11
    162e:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <prvTestWaitCondition>
    1632:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    1634:	8d 81       	ldd	r24, Y+5	; 0x05
    1636:	88 23       	and	r24, r24
    1638:	c1 f0       	breq	.+48     	; 0x166a <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    163a:	89 81       	ldd	r24, Y+1	; 0x01
    163c:	9a 81       	ldd	r25, Y+2	; 0x02
    163e:	99 87       	std	Y+9, r25	; 0x09
    1640:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    1642:	1b 8a       	std	Y+19, r1	; 0x13
    1644:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    1646:	88 89       	ldd	r24, Y+16	; 0x10
    1648:	88 23       	and	r24, r24
    164a:	e9 f1       	breq	.+122    	; 0x16c6 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    164c:	ea 85       	ldd	r30, Y+10	; 0x0a
    164e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1650:	20 81       	ld	r18, Z
    1652:	31 81       	ldd	r19, Z+1	; 0x01
    1654:	8e 85       	ldd	r24, Y+14	; 0x0e
    1656:	9f 85       	ldd	r25, Y+15	; 0x0f
    1658:	80 95       	com	r24
    165a:	90 95       	com	r25
    165c:	82 23       	and	r24, r18
    165e:	93 23       	and	r25, r19
    1660:	ea 85       	ldd	r30, Y+10	; 0x0a
    1662:	fb 85       	ldd	r31, Y+11	; 0x0b
    1664:	91 83       	std	Z+1, r25	; 0x01
    1666:	80 83       	st	Z, r24
    1668:	2e c0       	rjmp	.+92     	; 0x16c6 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    166a:	8a 89       	ldd	r24, Y+18	; 0x12
    166c:	9b 89       	ldd	r25, Y+19	; 0x13
    166e:	00 97       	sbiw	r24, 0x00	; 0
    1670:	39 f4       	brne	.+14     	; 0x1680 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    1672:	89 81       	ldd	r24, Y+1	; 0x01
    1674:	9a 81       	ldd	r25, Y+2	; 0x02
    1676:	99 87       	std	Y+9, r25	; 0x09
    1678:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    167a:	81 e0       	ldi	r24, 0x01	; 1
    167c:	8b 83       	std	Y+3, r24	; 0x03
    167e:	23 c0       	rjmp	.+70     	; 0x16c6 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    1680:	88 89       	ldd	r24, Y+16	; 0x10
    1682:	88 23       	and	r24, r24
    1684:	29 f0       	breq	.+10     	; 0x1690 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1686:	8e 81       	ldd	r24, Y+6	; 0x06
    1688:	9f 81       	ldd	r25, Y+7	; 0x07
    168a:	91 60       	ori	r25, 0x01	; 1
    168c:	9f 83       	std	Y+7, r25	; 0x07
    168e:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    1690:	89 89       	ldd	r24, Y+17	; 0x11
    1692:	88 23       	and	r24, r24
    1694:	29 f0       	breq	.+10     	; 0x16a0 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1696:	8e 81       	ldd	r24, Y+6	; 0x06
    1698:	9f 81       	ldd	r25, Y+7	; 0x07
    169a:	94 60       	ori	r25, 0x04	; 4
    169c:	9f 83       	std	Y+7, r25	; 0x07
    169e:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    16a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    16a2:	9b 85       	ldd	r25, Y+11	; 0x0b
    16a4:	bc 01       	movw	r22, r24
    16a6:	6e 5f       	subi	r22, 0xFE	; 254
    16a8:	7f 4f       	sbci	r23, 0xFF	; 255
    16aa:	2e 85       	ldd	r18, Y+14	; 0x0e
    16ac:	3f 85       	ldd	r19, Y+15	; 0x0f
    16ae:	8e 81       	ldd	r24, Y+6	; 0x06
    16b0:	9f 81       	ldd	r25, Y+7	; 0x07
    16b2:	28 2b       	or	r18, r24
    16b4:	39 2b       	or	r19, r25
    16b6:	4a 89       	ldd	r20, Y+18	; 0x12
    16b8:	5b 89       	ldd	r21, Y+19	; 0x13
    16ba:	cb 01       	movw	r24, r22
    16bc:	b9 01       	movw	r22, r18
    16be:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    16c2:	19 86       	std	Y+9, r1	; 0x09
    16c4:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    16c6:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    16ca:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    16cc:	8a 89       	ldd	r24, Y+18	; 0x12
    16ce:	9b 89       	ldd	r25, Y+19	; 0x13
    16d0:	00 97       	sbiw	r24, 0x00	; 0
    16d2:	09 f4       	brne	.+2      	; 0x16d6 <xEventGroupWaitBits+0xfa>
    16d4:	3c c0       	rjmp	.+120    	; 0x174e <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    16d6:	8c 81       	ldd	r24, Y+4	; 0x04
    16d8:	88 23       	and	r24, r24
    16da:	11 f4       	brne	.+4      	; 0x16e0 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    16dc:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    16e0:	0e 94 02 20 	call	0x4004	; 0x4004 <uxTaskResetEventItemValue>
    16e4:	99 87       	std	Y+9, r25	; 0x09
    16e6:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    16e8:	88 85       	ldd	r24, Y+8	; 0x08
    16ea:	99 85       	ldd	r25, Y+9	; 0x09
    16ec:	80 70       	andi	r24, 0x00	; 0
    16ee:	92 70       	andi	r25, 0x02	; 2
    16f0:	00 97       	sbiw	r24, 0x00	; 0
    16f2:	41 f5       	brne	.+80     	; 0x1744 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    16f4:	0f b6       	in	r0, 0x3f	; 63
    16f6:	f8 94       	cli
    16f8:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    16fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    16fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    16fe:	80 81       	ld	r24, Z
    1700:	91 81       	ldd	r25, Z+1	; 0x01
    1702:	99 87       	std	Y+9, r25	; 0x09
    1704:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1706:	88 85       	ldd	r24, Y+8	; 0x08
    1708:	99 85       	ldd	r25, Y+9	; 0x09
    170a:	2e 85       	ldd	r18, Y+14	; 0x0e
    170c:	3f 85       	ldd	r19, Y+15	; 0x0f
    170e:	b9 01       	movw	r22, r18
    1710:	49 89       	ldd	r20, Y+17	; 0x11
    1712:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <prvTestWaitCondition>
    1716:	88 23       	and	r24, r24
    1718:	89 f0       	breq	.+34     	; 0x173c <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    171a:	88 89       	ldd	r24, Y+16	; 0x10
    171c:	88 23       	and	r24, r24
    171e:	71 f0       	breq	.+28     	; 0x173c <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1720:	ea 85       	ldd	r30, Y+10	; 0x0a
    1722:	fb 85       	ldd	r31, Y+11	; 0x0b
    1724:	20 81       	ld	r18, Z
    1726:	31 81       	ldd	r19, Z+1	; 0x01
    1728:	8e 85       	ldd	r24, Y+14	; 0x0e
    172a:	9f 85       	ldd	r25, Y+15	; 0x0f
    172c:	80 95       	com	r24
    172e:	90 95       	com	r25
    1730:	82 23       	and	r24, r18
    1732:	93 23       	and	r25, r19
    1734:	ea 85       	ldd	r30, Y+10	; 0x0a
    1736:	fb 85       	ldd	r31, Y+11	; 0x0b
    1738:	91 83       	std	Z+1, r25	; 0x01
    173a:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    173c:	81 e0       	ldi	r24, 0x01	; 1
    173e:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    1740:	0f 90       	pop	r0
    1742:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1744:	88 85       	ldd	r24, Y+8	; 0x08
    1746:	99 85       	ldd	r25, Y+9	; 0x09
    1748:	90 70       	andi	r25, 0x00	; 0
    174a:	99 87       	std	Y+9, r25	; 0x09
    174c:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    174e:	88 85       	ldd	r24, Y+8	; 0x08
    1750:	99 85       	ldd	r25, Y+9	; 0x09
}
    1752:	63 96       	adiw	r28, 0x13	; 19
    1754:	0f b6       	in	r0, 0x3f	; 63
    1756:	f8 94       	cli
    1758:	de bf       	out	0x3e, r29	; 62
    175a:	0f be       	out	0x3f, r0	; 63
    175c:	cd bf       	out	0x3d, r28	; 61
    175e:	cf 91       	pop	r28
    1760:	df 91       	pop	r29
    1762:	1f 91       	pop	r17
    1764:	0f 91       	pop	r16
    1766:	08 95       	ret

00001768 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    1768:	df 93       	push	r29
    176a:	cf 93       	push	r28
    176c:	cd b7       	in	r28, 0x3d	; 61
    176e:	de b7       	in	r29, 0x3e	; 62
    1770:	28 97       	sbiw	r28, 0x08	; 8
    1772:	0f b6       	in	r0, 0x3f	; 63
    1774:	f8 94       	cli
    1776:	de bf       	out	0x3e, r29	; 62
    1778:	0f be       	out	0x3f, r0	; 63
    177a:	cd bf       	out	0x3d, r28	; 61
    177c:	9e 83       	std	Y+6, r25	; 0x06
    177e:	8d 83       	std	Y+5, r24	; 0x05
    1780:	78 87       	std	Y+8, r23	; 0x08
    1782:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    1784:	8d 81       	ldd	r24, Y+5	; 0x05
    1786:	9e 81       	ldd	r25, Y+6	; 0x06
    1788:	9c 83       	std	Y+4, r25	; 0x04
    178a:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	f8 94       	cli
    1790:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1792:	eb 81       	ldd	r30, Y+3	; 0x03
    1794:	fc 81       	ldd	r31, Y+4	; 0x04
    1796:	80 81       	ld	r24, Z
    1798:	91 81       	ldd	r25, Z+1	; 0x01
    179a:	9a 83       	std	Y+2, r25	; 0x02
    179c:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    179e:	eb 81       	ldd	r30, Y+3	; 0x03
    17a0:	fc 81       	ldd	r31, Y+4	; 0x04
    17a2:	20 81       	ld	r18, Z
    17a4:	31 81       	ldd	r19, Z+1	; 0x01
    17a6:	8f 81       	ldd	r24, Y+7	; 0x07
    17a8:	98 85       	ldd	r25, Y+8	; 0x08
    17aa:	80 95       	com	r24
    17ac:	90 95       	com	r25
    17ae:	82 23       	and	r24, r18
    17b0:	93 23       	and	r25, r19
    17b2:	eb 81       	ldd	r30, Y+3	; 0x03
    17b4:	fc 81       	ldd	r31, Y+4	; 0x04
    17b6:	91 83       	std	Z+1, r25	; 0x01
    17b8:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    17ba:	0f 90       	pop	r0
    17bc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    17be:	89 81       	ldd	r24, Y+1	; 0x01
    17c0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    17c2:	28 96       	adiw	r28, 0x08	; 8
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	f8 94       	cli
    17c8:	de bf       	out	0x3e, r29	; 62
    17ca:	0f be       	out	0x3f, r0	; 63
    17cc:	cd bf       	out	0x3d, r28	; 61
    17ce:	cf 91       	pop	r28
    17d0:	df 91       	pop	r29
    17d2:	08 95       	ret

000017d4 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    17d4:	df 93       	push	r29
    17d6:	cf 93       	push	r28
    17d8:	cd b7       	in	r28, 0x3d	; 61
    17da:	de b7       	in	r29, 0x3e	; 62
    17dc:	27 97       	sbiw	r28, 0x07	; 7
    17de:	0f b6       	in	r0, 0x3f	; 63
    17e0:	f8 94       	cli
    17e2:	de bf       	out	0x3e, r29	; 62
    17e4:	0f be       	out	0x3f, r0	; 63
    17e6:	cd bf       	out	0x3d, r28	; 61
    17e8:	9f 83       	std	Y+7, r25	; 0x07
    17ea:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    17ec:	8e 81       	ldd	r24, Y+6	; 0x06
    17ee:	9f 81       	ldd	r25, Y+7	; 0x07
    17f0:	9c 83       	std	Y+4, r25	; 0x04
    17f2:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    17f4:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    17f6:	eb 81       	ldd	r30, Y+3	; 0x03
    17f8:	fc 81       	ldd	r31, Y+4	; 0x04
    17fa:	80 81       	ld	r24, Z
    17fc:	91 81       	ldd	r25, Z+1	; 0x01
    17fe:	9a 83       	std	Y+2, r25	; 0x02
    1800:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    1802:	89 81       	ldd	r24, Y+1	; 0x01
    1804:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1806:	27 96       	adiw	r28, 0x07	; 7
    1808:	0f b6       	in	r0, 0x3f	; 63
    180a:	f8 94       	cli
    180c:	de bf       	out	0x3e, r29	; 62
    180e:	0f be       	out	0x3f, r0	; 63
    1810:	cd bf       	out	0x3d, r28	; 61
    1812:	cf 91       	pop	r28
    1814:	df 91       	pop	r29
    1816:	08 95       	ret

00001818 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    1818:	df 93       	push	r29
    181a:	cf 93       	push	r28
    181c:	cd b7       	in	r28, 0x3d	; 61
    181e:	de b7       	in	r29, 0x3e	; 62
    1820:	65 97       	sbiw	r28, 0x15	; 21
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	f8 94       	cli
    1826:	de bf       	out	0x3e, r29	; 62
    1828:	0f be       	out	0x3f, r0	; 63
    182a:	cd bf       	out	0x3d, r28	; 61
    182c:	9b 8b       	std	Y+19, r25	; 0x13
    182e:	8a 8b       	std	Y+18, r24	; 0x12
    1830:	7d 8b       	std	Y+21, r23	; 0x15
    1832:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1834:	19 86       	std	Y+9, r1	; 0x09
    1836:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    1838:	8a 89       	ldd	r24, Y+18	; 0x12
    183a:	9b 89       	ldd	r25, Y+19	; 0x13
    183c:	9b 83       	std	Y+3, r25	; 0x03
    183e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    1840:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    1842:	8a 81       	ldd	r24, Y+2	; 0x02
    1844:	9b 81       	ldd	r25, Y+3	; 0x03
    1846:	02 96       	adiw	r24, 0x02	; 2
    1848:	9b 87       	std	Y+11, r25	; 0x0b
    184a:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    184c:	8a 85       	ldd	r24, Y+10	; 0x0a
    184e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1850:	03 96       	adiw	r24, 0x03	; 3
    1852:	9d 87       	std	Y+13, r25	; 0x0d
    1854:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    1856:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    185a:	ea 85       	ldd	r30, Y+10	; 0x0a
    185c:	fb 85       	ldd	r31, Y+11	; 0x0b
    185e:	85 81       	ldd	r24, Z+5	; 0x05
    1860:	96 81       	ldd	r25, Z+6	; 0x06
    1862:	99 8b       	std	Y+17, r25	; 0x11
    1864:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1866:	ea 81       	ldd	r30, Y+2	; 0x02
    1868:	fb 81       	ldd	r31, Y+3	; 0x03
    186a:	20 81       	ld	r18, Z
    186c:	31 81       	ldd	r19, Z+1	; 0x01
    186e:	8c 89       	ldd	r24, Y+20	; 0x14
    1870:	9d 89       	ldd	r25, Y+21	; 0x15
    1872:	82 2b       	or	r24, r18
    1874:	93 2b       	or	r25, r19
    1876:	ea 81       	ldd	r30, Y+2	; 0x02
    1878:	fb 81       	ldd	r31, Y+3	; 0x03
    187a:	91 83       	std	Z+1, r25	; 0x01
    187c:	80 83       	st	Z, r24
    187e:	59 c0       	rjmp	.+178    	; 0x1932 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    1880:	e8 89       	ldd	r30, Y+16	; 0x10
    1882:	f9 89       	ldd	r31, Y+17	; 0x11
    1884:	82 81       	ldd	r24, Z+2	; 0x02
    1886:	93 81       	ldd	r25, Z+3	; 0x03
    1888:	9f 87       	std	Y+15, r25	; 0x0f
    188a:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    188c:	e8 89       	ldd	r30, Y+16	; 0x10
    188e:	f9 89       	ldd	r31, Y+17	; 0x11
    1890:	80 81       	ld	r24, Z
    1892:	91 81       	ldd	r25, Z+1	; 0x01
    1894:	9f 83       	std	Y+7, r25	; 0x07
    1896:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    1898:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    189a:	8e 81       	ldd	r24, Y+6	; 0x06
    189c:	9f 81       	ldd	r25, Y+7	; 0x07
    189e:	80 70       	andi	r24, 0x00	; 0
    18a0:	9d 83       	std	Y+5, r25	; 0x05
    18a2:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    18a4:	8e 81       	ldd	r24, Y+6	; 0x06
    18a6:	9f 81       	ldd	r25, Y+7	; 0x07
    18a8:	90 70       	andi	r25, 0x00	; 0
    18aa:	9f 83       	std	Y+7, r25	; 0x07
    18ac:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    18ae:	8c 81       	ldd	r24, Y+4	; 0x04
    18b0:	9d 81       	ldd	r25, Y+5	; 0x05
    18b2:	80 70       	andi	r24, 0x00	; 0
    18b4:	94 70       	andi	r25, 0x04	; 4
    18b6:	00 97       	sbiw	r24, 0x00	; 0
    18b8:	69 f4       	brne	.+26     	; 0x18d4 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    18ba:	ea 81       	ldd	r30, Y+2	; 0x02
    18bc:	fb 81       	ldd	r31, Y+3	; 0x03
    18be:	20 81       	ld	r18, Z
    18c0:	31 81       	ldd	r19, Z+1	; 0x01
    18c2:	8e 81       	ldd	r24, Y+6	; 0x06
    18c4:	9f 81       	ldd	r25, Y+7	; 0x07
    18c6:	82 23       	and	r24, r18
    18c8:	93 23       	and	r25, r19
    18ca:	00 97       	sbiw	r24, 0x00	; 0
    18cc:	91 f0       	breq	.+36     	; 0x18f2 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	89 83       	std	Y+1, r24	; 0x01
    18d2:	0f c0       	rjmp	.+30     	; 0x18f2 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    18d4:	ea 81       	ldd	r30, Y+2	; 0x02
    18d6:	fb 81       	ldd	r31, Y+3	; 0x03
    18d8:	20 81       	ld	r18, Z
    18da:	31 81       	ldd	r19, Z+1	; 0x01
    18dc:	8e 81       	ldd	r24, Y+6	; 0x06
    18de:	9f 81       	ldd	r25, Y+7	; 0x07
    18e0:	28 23       	and	r18, r24
    18e2:	39 23       	and	r19, r25
    18e4:	8e 81       	ldd	r24, Y+6	; 0x06
    18e6:	9f 81       	ldd	r25, Y+7	; 0x07
    18e8:	28 17       	cp	r18, r24
    18ea:	39 07       	cpc	r19, r25
    18ec:	11 f4       	brne	.+4      	; 0x18f2 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    18ee:	81 e0       	ldi	r24, 0x01	; 1
    18f0:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    18f2:	89 81       	ldd	r24, Y+1	; 0x01
    18f4:	88 23       	and	r24, r24
    18f6:	c9 f0       	breq	.+50     	; 0x192a <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    18f8:	8c 81       	ldd	r24, Y+4	; 0x04
    18fa:	9d 81       	ldd	r25, Y+5	; 0x05
    18fc:	80 70       	andi	r24, 0x00	; 0
    18fe:	91 70       	andi	r25, 0x01	; 1
    1900:	00 97       	sbiw	r24, 0x00	; 0
    1902:	41 f0       	breq	.+16     	; 0x1914 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    1904:	88 85       	ldd	r24, Y+8	; 0x08
    1906:	99 85       	ldd	r25, Y+9	; 0x09
    1908:	2e 81       	ldd	r18, Y+6	; 0x06
    190a:	3f 81       	ldd	r19, Y+7	; 0x07
    190c:	82 2b       	or	r24, r18
    190e:	93 2b       	or	r25, r19
    1910:	99 87       	std	Y+9, r25	; 0x09
    1912:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1914:	ea 81       	ldd	r30, Y+2	; 0x02
    1916:	fb 81       	ldd	r31, Y+3	; 0x03
    1918:	80 81       	ld	r24, Z
    191a:	91 81       	ldd	r25, Z+1	; 0x01
    191c:	9c 01       	movw	r18, r24
    191e:	32 60       	ori	r19, 0x02	; 2
    1920:	88 89       	ldd	r24, Y+16	; 0x10
    1922:	99 89       	ldd	r25, Y+17	; 0x11
    1924:	b9 01       	movw	r22, r18
    1926:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    192a:	8e 85       	ldd	r24, Y+14	; 0x0e
    192c:	9f 85       	ldd	r25, Y+15	; 0x0f
    192e:	99 8b       	std	Y+17, r25	; 0x11
    1930:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    1932:	28 89       	ldd	r18, Y+16	; 0x10
    1934:	39 89       	ldd	r19, Y+17	; 0x11
    1936:	8c 85       	ldd	r24, Y+12	; 0x0c
    1938:	9d 85       	ldd	r25, Y+13	; 0x0d
    193a:	28 17       	cp	r18, r24
    193c:	39 07       	cpc	r19, r25
    193e:	09 f0       	breq	.+2      	; 0x1942 <xEventGroupSetBits+0x12a>
    1940:	9f cf       	rjmp	.-194    	; 0x1880 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1942:	ea 81       	ldd	r30, Y+2	; 0x02
    1944:	fb 81       	ldd	r31, Y+3	; 0x03
    1946:	20 81       	ld	r18, Z
    1948:	31 81       	ldd	r19, Z+1	; 0x01
    194a:	88 85       	ldd	r24, Y+8	; 0x08
    194c:	99 85       	ldd	r25, Y+9	; 0x09
    194e:	80 95       	com	r24
    1950:	90 95       	com	r25
    1952:	82 23       	and	r24, r18
    1954:	93 23       	and	r25, r19
    1956:	ea 81       	ldd	r30, Y+2	; 0x02
    1958:	fb 81       	ldd	r31, Y+3	; 0x03
    195a:	91 83       	std	Z+1, r25	; 0x01
    195c:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    195e:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    1962:	ea 81       	ldd	r30, Y+2	; 0x02
    1964:	fb 81       	ldd	r31, Y+3	; 0x03
    1966:	80 81       	ld	r24, Z
    1968:	91 81       	ldd	r25, Z+1	; 0x01
}
    196a:	65 96       	adiw	r28, 0x15	; 21
    196c:	0f b6       	in	r0, 0x3f	; 63
    196e:	f8 94       	cli
    1970:	de bf       	out	0x3e, r29	; 62
    1972:	0f be       	out	0x3f, r0	; 63
    1974:	cd bf       	out	0x3d, r28	; 61
    1976:	cf 91       	pop	r28
    1978:	df 91       	pop	r29
    197a:	08 95       	ret

0000197c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    197c:	df 93       	push	r29
    197e:	cf 93       	push	r28
    1980:	00 d0       	rcall	.+0      	; 0x1982 <vEventGroupDelete+0x6>
    1982:	00 d0       	rcall	.+0      	; 0x1984 <vEventGroupDelete+0x8>
    1984:	00 d0       	rcall	.+0      	; 0x1986 <vEventGroupDelete+0xa>
    1986:	cd b7       	in	r28, 0x3d	; 61
    1988:	de b7       	in	r29, 0x3e	; 62
    198a:	9e 83       	std	Y+6, r25	; 0x06
    198c:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    198e:	8d 81       	ldd	r24, Y+5	; 0x05
    1990:	9e 81       	ldd	r25, Y+6	; 0x06
    1992:	9c 83       	std	Y+4, r25	; 0x04
    1994:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1996:	8b 81       	ldd	r24, Y+3	; 0x03
    1998:	9c 81       	ldd	r25, Y+4	; 0x04
    199a:	02 96       	adiw	r24, 0x02	; 2
    199c:	9a 83       	std	Y+2, r25	; 0x02
    199e:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    19a0:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
    19a4:	08 c0       	rjmp	.+16     	; 0x19b6 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    19a6:	e9 81       	ldd	r30, Y+1	; 0x01
    19a8:	fa 81       	ldd	r31, Y+2	; 0x02
    19aa:	85 81       	ldd	r24, Z+5	; 0x05
    19ac:	96 81       	ldd	r25, Z+6	; 0x06
    19ae:	60 e0       	ldi	r22, 0x00	; 0
    19b0:	72 e0       	ldi	r23, 0x02	; 2
    19b2:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    19b6:	e9 81       	ldd	r30, Y+1	; 0x01
    19b8:	fa 81       	ldd	r31, Y+2	; 0x02
    19ba:	80 81       	ld	r24, Z
    19bc:	88 23       	and	r24, r24
    19be:	99 f7       	brne	.-26     	; 0x19a6 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    19c0:	8b 81       	ldd	r24, Y+3	; 0x03
    19c2:	9c 81       	ldd	r25, Y+4	; 0x04
    19c4:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    19c8:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
}
    19cc:	26 96       	adiw	r28, 0x06	; 6
    19ce:	0f b6       	in	r0, 0x3f	; 63
    19d0:	f8 94       	cli
    19d2:	de bf       	out	0x3e, r29	; 62
    19d4:	0f be       	out	0x3f, r0	; 63
    19d6:	cd bf       	out	0x3d, r28	; 61
    19d8:	cf 91       	pop	r28
    19da:	df 91       	pop	r29
    19dc:	08 95       	ret

000019de <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    19de:	df 93       	push	r29
    19e0:	cf 93       	push	r28
    19e2:	00 d0       	rcall	.+0      	; 0x19e4 <vEventGroupSetBitsCallback+0x6>
    19e4:	00 d0       	rcall	.+0      	; 0x19e6 <vEventGroupSetBitsCallback+0x8>
    19e6:	00 d0       	rcall	.+0      	; 0x19e8 <vEventGroupSetBitsCallback+0xa>
    19e8:	cd b7       	in	r28, 0x3d	; 61
    19ea:	de b7       	in	r29, 0x3e	; 62
    19ec:	9a 83       	std	Y+2, r25	; 0x02
    19ee:	89 83       	std	Y+1, r24	; 0x01
    19f0:	4b 83       	std	Y+3, r20	; 0x03
    19f2:	5c 83       	std	Y+4, r21	; 0x04
    19f4:	6d 83       	std	Y+5, r22	; 0x05
    19f6:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    19f8:	89 81       	ldd	r24, Y+1	; 0x01
    19fa:	9a 81       	ldd	r25, Y+2	; 0x02
    19fc:	2b 81       	ldd	r18, Y+3	; 0x03
    19fe:	3c 81       	ldd	r19, Y+4	; 0x04
    1a00:	b9 01       	movw	r22, r18
    1a02:	0e 94 0c 0c 	call	0x1818	; 0x1818 <xEventGroupSetBits>
}
    1a06:	26 96       	adiw	r28, 0x06	; 6
    1a08:	0f b6       	in	r0, 0x3f	; 63
    1a0a:	f8 94       	cli
    1a0c:	de bf       	out	0x3e, r29	; 62
    1a0e:	0f be       	out	0x3f, r0	; 63
    1a10:	cd bf       	out	0x3d, r28	; 61
    1a12:	cf 91       	pop	r28
    1a14:	df 91       	pop	r29
    1a16:	08 95       	ret

00001a18 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    1a18:	df 93       	push	r29
    1a1a:	cf 93       	push	r28
    1a1c:	00 d0       	rcall	.+0      	; 0x1a1e <vEventGroupClearBitsCallback+0x6>
    1a1e:	00 d0       	rcall	.+0      	; 0x1a20 <vEventGroupClearBitsCallback+0x8>
    1a20:	00 d0       	rcall	.+0      	; 0x1a22 <vEventGroupClearBitsCallback+0xa>
    1a22:	cd b7       	in	r28, 0x3d	; 61
    1a24:	de b7       	in	r29, 0x3e	; 62
    1a26:	9a 83       	std	Y+2, r25	; 0x02
    1a28:	89 83       	std	Y+1, r24	; 0x01
    1a2a:	4b 83       	std	Y+3, r20	; 0x03
    1a2c:	5c 83       	std	Y+4, r21	; 0x04
    1a2e:	6d 83       	std	Y+5, r22	; 0x05
    1a30:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1a32:	89 81       	ldd	r24, Y+1	; 0x01
    1a34:	9a 81       	ldd	r25, Y+2	; 0x02
    1a36:	2b 81       	ldd	r18, Y+3	; 0x03
    1a38:	3c 81       	ldd	r19, Y+4	; 0x04
    1a3a:	b9 01       	movw	r22, r18
    1a3c:	0e 94 b4 0b 	call	0x1768	; 0x1768 <xEventGroupClearBits>
}
    1a40:	26 96       	adiw	r28, 0x06	; 6
    1a42:	0f b6       	in	r0, 0x3f	; 63
    1a44:	f8 94       	cli
    1a46:	de bf       	out	0x3e, r29	; 62
    1a48:	0f be       	out	0x3f, r0	; 63
    1a4a:	cd bf       	out	0x3d, r28	; 61
    1a4c:	cf 91       	pop	r28
    1a4e:	df 91       	pop	r29
    1a50:	08 95       	ret

00001a52 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    1a52:	df 93       	push	r29
    1a54:	cf 93       	push	r28
    1a56:	00 d0       	rcall	.+0      	; 0x1a58 <prvTestWaitCondition+0x6>
    1a58:	00 d0       	rcall	.+0      	; 0x1a5a <prvTestWaitCondition+0x8>
    1a5a:	00 d0       	rcall	.+0      	; 0x1a5c <prvTestWaitCondition+0xa>
    1a5c:	cd b7       	in	r28, 0x3d	; 61
    1a5e:	de b7       	in	r29, 0x3e	; 62
    1a60:	9b 83       	std	Y+3, r25	; 0x03
    1a62:	8a 83       	std	Y+2, r24	; 0x02
    1a64:	7d 83       	std	Y+5, r23	; 0x05
    1a66:	6c 83       	std	Y+4, r22	; 0x04
    1a68:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1a6a:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1a6c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a6e:	88 23       	and	r24, r24
    1a70:	59 f4       	brne	.+22     	; 0x1a88 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1a72:	8a 81       	ldd	r24, Y+2	; 0x02
    1a74:	9b 81       	ldd	r25, Y+3	; 0x03
    1a76:	2c 81       	ldd	r18, Y+4	; 0x04
    1a78:	3d 81       	ldd	r19, Y+5	; 0x05
    1a7a:	82 23       	and	r24, r18
    1a7c:	93 23       	and	r25, r19
    1a7e:	00 97       	sbiw	r24, 0x00	; 0
    1a80:	81 f0       	breq	.+32     	; 0x1aa2 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1a82:	81 e0       	ldi	r24, 0x01	; 1
    1a84:	89 83       	std	Y+1, r24	; 0x01
    1a86:	0d c0       	rjmp	.+26     	; 0x1aa2 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1a88:	2a 81       	ldd	r18, Y+2	; 0x02
    1a8a:	3b 81       	ldd	r19, Y+3	; 0x03
    1a8c:	8c 81       	ldd	r24, Y+4	; 0x04
    1a8e:	9d 81       	ldd	r25, Y+5	; 0x05
    1a90:	28 23       	and	r18, r24
    1a92:	39 23       	and	r19, r25
    1a94:	8c 81       	ldd	r24, Y+4	; 0x04
    1a96:	9d 81       	ldd	r25, Y+5	; 0x05
    1a98:	28 17       	cp	r18, r24
    1a9a:	39 07       	cpc	r19, r25
    1a9c:	11 f4       	brne	.+4      	; 0x1aa2 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1aa2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1aa4:	26 96       	adiw	r28, 0x06	; 6
    1aa6:	0f b6       	in	r0, 0x3f	; 63
    1aa8:	f8 94       	cli
    1aaa:	de bf       	out	0x3e, r29	; 62
    1aac:	0f be       	out	0x3f, r0	; 63
    1aae:	cd bf       	out	0x3d, r28	; 61
    1ab0:	cf 91       	pop	r28
    1ab2:	df 91       	pop	r29
    1ab4:	08 95       	ret

00001ab6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1ab6:	df 93       	push	r29
    1ab8:	cf 93       	push	r28
    1aba:	00 d0       	rcall	.+0      	; 0x1abc <pvPortMalloc+0x6>
    1abc:	00 d0       	rcall	.+0      	; 0x1abe <pvPortMalloc+0x8>
    1abe:	cd b7       	in	r28, 0x3d	; 61
    1ac0:	de b7       	in	r29, 0x3e	; 62
    1ac2:	9c 83       	std	Y+4, r25	; 0x04
    1ac4:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1ac6:	1a 82       	std	Y+2, r1	; 0x02
    1ac8:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1aca:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1ace:	80 91 1b 02 	lds	r24, 0x021B
    1ad2:	90 91 1c 02 	lds	r25, 0x021C
    1ad6:	00 97       	sbiw	r24, 0x00	; 0
    1ad8:	31 f4       	brne	.+12     	; 0x1ae6 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1ada:	8e e1       	ldi	r24, 0x1E	; 30
    1adc:	92 e0       	ldi	r25, 0x02	; 2
    1ade:	90 93 1c 02 	sts	0x021C, r25
    1ae2:	80 93 1b 02 	sts	0x021B, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1ae6:	80 91 19 02 	lds	r24, 0x0219
    1aea:	90 91 1a 02 	lds	r25, 0x021A
    1aee:	2b 81       	ldd	r18, Y+3	; 0x03
    1af0:	3c 81       	ldd	r19, Y+4	; 0x04
    1af2:	82 0f       	add	r24, r18
    1af4:	93 1f       	adc	r25, r19
    1af6:	22 e0       	ldi	r18, 0x02	; 2
    1af8:	87 35       	cpi	r24, 0x57	; 87
    1afa:	92 07       	cpc	r25, r18
    1afc:	38 f5       	brcc	.+78     	; 0x1b4c <pvPortMalloc+0x96>
    1afe:	20 91 19 02 	lds	r18, 0x0219
    1b02:	30 91 1a 02 	lds	r19, 0x021A
    1b06:	8b 81       	ldd	r24, Y+3	; 0x03
    1b08:	9c 81       	ldd	r25, Y+4	; 0x04
    1b0a:	28 0f       	add	r18, r24
    1b0c:	39 1f       	adc	r19, r25
    1b0e:	80 91 19 02 	lds	r24, 0x0219
    1b12:	90 91 1a 02 	lds	r25, 0x021A
    1b16:	82 17       	cp	r24, r18
    1b18:	93 07       	cpc	r25, r19
    1b1a:	c0 f4       	brcc	.+48     	; 0x1b4c <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1b1c:	20 91 1b 02 	lds	r18, 0x021B
    1b20:	30 91 1c 02 	lds	r19, 0x021C
    1b24:	80 91 19 02 	lds	r24, 0x0219
    1b28:	90 91 1a 02 	lds	r25, 0x021A
    1b2c:	82 0f       	add	r24, r18
    1b2e:	93 1f       	adc	r25, r19
    1b30:	9a 83       	std	Y+2, r25	; 0x02
    1b32:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1b34:	20 91 19 02 	lds	r18, 0x0219
    1b38:	30 91 1a 02 	lds	r19, 0x021A
    1b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b40:	82 0f       	add	r24, r18
    1b42:	93 1f       	adc	r25, r19
    1b44:	90 93 1a 02 	sts	0x021A, r25
    1b48:	80 93 19 02 	sts	0x0219, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1b4c:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1b50:	89 81       	ldd	r24, Y+1	; 0x01
    1b52:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1b54:	0f 90       	pop	r0
    1b56:	0f 90       	pop	r0
    1b58:	0f 90       	pop	r0
    1b5a:	0f 90       	pop	r0
    1b5c:	cf 91       	pop	r28
    1b5e:	df 91       	pop	r29
    1b60:	08 95       	ret

00001b62 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1b62:	df 93       	push	r29
    1b64:	cf 93       	push	r28
    1b66:	00 d0       	rcall	.+0      	; 0x1b68 <vPortFree+0x6>
    1b68:	cd b7       	in	r28, 0x3d	; 61
    1b6a:	de b7       	in	r29, 0x3e	; 62
    1b6c:	9a 83       	std	Y+2, r25	; 0x02
    1b6e:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1b70:	0f 90       	pop	r0
    1b72:	0f 90       	pop	r0
    1b74:	cf 91       	pop	r28
    1b76:	df 91       	pop	r29
    1b78:	08 95       	ret

00001b7a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1b7a:	df 93       	push	r29
    1b7c:	cf 93       	push	r28
    1b7e:	cd b7       	in	r28, 0x3d	; 61
    1b80:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1b82:	10 92 1a 02 	sts	0x021A, r1
    1b86:	10 92 19 02 	sts	0x0219, r1
}
    1b8a:	cf 91       	pop	r28
    1b8c:	df 91       	pop	r29
    1b8e:	08 95       	ret

00001b90 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1b90:	df 93       	push	r29
    1b92:	cf 93       	push	r28
    1b94:	cd b7       	in	r28, 0x3d	; 61
    1b96:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1b98:	20 91 19 02 	lds	r18, 0x0219
    1b9c:	30 91 1a 02 	lds	r19, 0x021A
    1ba0:	87 e5       	ldi	r24, 0x57	; 87
    1ba2:	92 e0       	ldi	r25, 0x02	; 2
    1ba4:	82 1b       	sub	r24, r18
    1ba6:	93 0b       	sbc	r25, r19
}
    1ba8:	cf 91       	pop	r28
    1baa:	df 91       	pop	r29
    1bac:	08 95       	ret

00001bae <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1bae:	df 93       	push	r29
    1bb0:	cf 93       	push	r28
    1bb2:	00 d0       	rcall	.+0      	; 0x1bb4 <vListInitialise+0x6>
    1bb4:	cd b7       	in	r28, 0x3d	; 61
    1bb6:	de b7       	in	r29, 0x3e	; 62
    1bb8:	9a 83       	std	Y+2, r25	; 0x02
    1bba:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bbc:	89 81       	ldd	r24, Y+1	; 0x01
    1bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc0:	03 96       	adiw	r24, 0x03	; 3
    1bc2:	e9 81       	ldd	r30, Y+1	; 0x01
    1bc4:	fa 81       	ldd	r31, Y+2	; 0x02
    1bc6:	92 83       	std	Z+2, r25	; 0x02
    1bc8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bca:	e9 81       	ldd	r30, Y+1	; 0x01
    1bcc:	fa 81       	ldd	r31, Y+2	; 0x02
    1bce:	8f ef       	ldi	r24, 0xFF	; 255
    1bd0:	9f ef       	ldi	r25, 0xFF	; 255
    1bd2:	94 83       	std	Z+4, r25	; 0x04
    1bd4:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bd6:	89 81       	ldd	r24, Y+1	; 0x01
    1bd8:	9a 81       	ldd	r25, Y+2	; 0x02
    1bda:	03 96       	adiw	r24, 0x03	; 3
    1bdc:	e9 81       	ldd	r30, Y+1	; 0x01
    1bde:	fa 81       	ldd	r31, Y+2	; 0x02
    1be0:	96 83       	std	Z+6, r25	; 0x06
    1be2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1be4:	89 81       	ldd	r24, Y+1	; 0x01
    1be6:	9a 81       	ldd	r25, Y+2	; 0x02
    1be8:	03 96       	adiw	r24, 0x03	; 3
    1bea:	e9 81       	ldd	r30, Y+1	; 0x01
    1bec:	fa 81       	ldd	r31, Y+2	; 0x02
    1bee:	90 87       	std	Z+8, r25	; 0x08
    1bf0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1bf2:	e9 81       	ldd	r30, Y+1	; 0x01
    1bf4:	fa 81       	ldd	r31, Y+2	; 0x02
    1bf6:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1bf8:	0f 90       	pop	r0
    1bfa:	0f 90       	pop	r0
    1bfc:	cf 91       	pop	r28
    1bfe:	df 91       	pop	r29
    1c00:	08 95       	ret

00001c02 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1c02:	df 93       	push	r29
    1c04:	cf 93       	push	r28
    1c06:	00 d0       	rcall	.+0      	; 0x1c08 <vListInitialiseItem+0x6>
    1c08:	cd b7       	in	r28, 0x3d	; 61
    1c0a:	de b7       	in	r29, 0x3e	; 62
    1c0c:	9a 83       	std	Y+2, r25	; 0x02
    1c0e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1c10:	e9 81       	ldd	r30, Y+1	; 0x01
    1c12:	fa 81       	ldd	r31, Y+2	; 0x02
    1c14:	11 86       	std	Z+9, r1	; 0x09
    1c16:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1c18:	0f 90       	pop	r0
    1c1a:	0f 90       	pop	r0
    1c1c:	cf 91       	pop	r28
    1c1e:	df 91       	pop	r29
    1c20:	08 95       	ret

00001c22 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c22:	df 93       	push	r29
    1c24:	cf 93       	push	r28
    1c26:	00 d0       	rcall	.+0      	; 0x1c28 <vListInsertEnd+0x6>
    1c28:	00 d0       	rcall	.+0      	; 0x1c2a <vListInsertEnd+0x8>
    1c2a:	00 d0       	rcall	.+0      	; 0x1c2c <vListInsertEnd+0xa>
    1c2c:	cd b7       	in	r28, 0x3d	; 61
    1c2e:	de b7       	in	r29, 0x3e	; 62
    1c30:	9c 83       	std	Y+4, r25	; 0x04
    1c32:	8b 83       	std	Y+3, r24	; 0x03
    1c34:	7e 83       	std	Y+6, r23	; 0x06
    1c36:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1c38:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3c:	81 81       	ldd	r24, Z+1	; 0x01
    1c3e:	92 81       	ldd	r25, Z+2	; 0x02
    1c40:	9a 83       	std	Y+2, r25	; 0x02
    1c42:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c44:	ed 81       	ldd	r30, Y+5	; 0x05
    1c46:	fe 81       	ldd	r31, Y+6	; 0x06
    1c48:	89 81       	ldd	r24, Y+1	; 0x01
    1c4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c4c:	93 83       	std	Z+3, r25	; 0x03
    1c4e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c50:	e9 81       	ldd	r30, Y+1	; 0x01
    1c52:	fa 81       	ldd	r31, Y+2	; 0x02
    1c54:	84 81       	ldd	r24, Z+4	; 0x04
    1c56:	95 81       	ldd	r25, Z+5	; 0x05
    1c58:	ed 81       	ldd	r30, Y+5	; 0x05
    1c5a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c5c:	95 83       	std	Z+5, r25	; 0x05
    1c5e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c60:	e9 81       	ldd	r30, Y+1	; 0x01
    1c62:	fa 81       	ldd	r31, Y+2	; 0x02
    1c64:	04 80       	ldd	r0, Z+4	; 0x04
    1c66:	f5 81       	ldd	r31, Z+5	; 0x05
    1c68:	e0 2d       	mov	r30, r0
    1c6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c6c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c6e:	93 83       	std	Z+3, r25	; 0x03
    1c70:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1c72:	e9 81       	ldd	r30, Y+1	; 0x01
    1c74:	fa 81       	ldd	r31, Y+2	; 0x02
    1c76:	8d 81       	ldd	r24, Y+5	; 0x05
    1c78:	9e 81       	ldd	r25, Y+6	; 0x06
    1c7a:	95 83       	std	Z+5, r25	; 0x05
    1c7c:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1c7e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c80:	fe 81       	ldd	r31, Y+6	; 0x06
    1c82:	8b 81       	ldd	r24, Y+3	; 0x03
    1c84:	9c 81       	ldd	r25, Y+4	; 0x04
    1c86:	91 87       	std	Z+9, r25	; 0x09
    1c88:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1c8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c8e:	80 81       	ld	r24, Z
    1c90:	8f 5f       	subi	r24, 0xFF	; 255
    1c92:	eb 81       	ldd	r30, Y+3	; 0x03
    1c94:	fc 81       	ldd	r31, Y+4	; 0x04
    1c96:	80 83       	st	Z, r24
}
    1c98:	26 96       	adiw	r28, 0x06	; 6
    1c9a:	0f b6       	in	r0, 0x3f	; 63
    1c9c:	f8 94       	cli
    1c9e:	de bf       	out	0x3e, r29	; 62
    1ca0:	0f be       	out	0x3f, r0	; 63
    1ca2:	cd bf       	out	0x3d, r28	; 61
    1ca4:	cf 91       	pop	r28
    1ca6:	df 91       	pop	r29
    1ca8:	08 95       	ret

00001caa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1caa:	df 93       	push	r29
    1cac:	cf 93       	push	r28
    1cae:	cd b7       	in	r28, 0x3d	; 61
    1cb0:	de b7       	in	r29, 0x3e	; 62
    1cb2:	28 97       	sbiw	r28, 0x08	; 8
    1cb4:	0f b6       	in	r0, 0x3f	; 63
    1cb6:	f8 94       	cli
    1cb8:	de bf       	out	0x3e, r29	; 62
    1cba:	0f be       	out	0x3f, r0	; 63
    1cbc:	cd bf       	out	0x3d, r28	; 61
    1cbe:	9e 83       	std	Y+6, r25	; 0x06
    1cc0:	8d 83       	std	Y+5, r24	; 0x05
    1cc2:	78 87       	std	Y+8, r23	; 0x08
    1cc4:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1cc6:	ef 81       	ldd	r30, Y+7	; 0x07
    1cc8:	f8 85       	ldd	r31, Y+8	; 0x08
    1cca:	80 81       	ld	r24, Z
    1ccc:	91 81       	ldd	r25, Z+1	; 0x01
    1cce:	9a 83       	std	Y+2, r25	; 0x02
    1cd0:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1cd2:	89 81       	ldd	r24, Y+1	; 0x01
    1cd4:	9a 81       	ldd	r25, Y+2	; 0x02
    1cd6:	2f ef       	ldi	r18, 0xFF	; 255
    1cd8:	8f 3f       	cpi	r24, 0xFF	; 255
    1cda:	92 07       	cpc	r25, r18
    1cdc:	39 f4       	brne	.+14     	; 0x1cec <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1cde:	ed 81       	ldd	r30, Y+5	; 0x05
    1ce0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ce2:	87 81       	ldd	r24, Z+7	; 0x07
    1ce4:	90 85       	ldd	r25, Z+8	; 0x08
    1ce6:	9c 83       	std	Y+4, r25	; 0x04
    1ce8:	8b 83       	std	Y+3, r24	; 0x03
    1cea:	18 c0       	rjmp	.+48     	; 0x1d1c <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1cec:	8d 81       	ldd	r24, Y+5	; 0x05
    1cee:	9e 81       	ldd	r25, Y+6	; 0x06
    1cf0:	03 96       	adiw	r24, 0x03	; 3
    1cf2:	9c 83       	std	Y+4, r25	; 0x04
    1cf4:	8b 83       	std	Y+3, r24	; 0x03
    1cf6:	06 c0       	rjmp	.+12     	; 0x1d04 <vListInsert+0x5a>
    1cf8:	eb 81       	ldd	r30, Y+3	; 0x03
    1cfa:	fc 81       	ldd	r31, Y+4	; 0x04
    1cfc:	82 81       	ldd	r24, Z+2	; 0x02
    1cfe:	93 81       	ldd	r25, Z+3	; 0x03
    1d00:	9c 83       	std	Y+4, r25	; 0x04
    1d02:	8b 83       	std	Y+3, r24	; 0x03
    1d04:	eb 81       	ldd	r30, Y+3	; 0x03
    1d06:	fc 81       	ldd	r31, Y+4	; 0x04
    1d08:	02 80       	ldd	r0, Z+2	; 0x02
    1d0a:	f3 81       	ldd	r31, Z+3	; 0x03
    1d0c:	e0 2d       	mov	r30, r0
    1d0e:	20 81       	ld	r18, Z
    1d10:	31 81       	ldd	r19, Z+1	; 0x01
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
    1d14:	9a 81       	ldd	r25, Y+2	; 0x02
    1d16:	82 17       	cp	r24, r18
    1d18:	93 07       	cpc	r25, r19
    1d1a:	70 f7       	brcc	.-36     	; 0x1cf8 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1d1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d20:	82 81       	ldd	r24, Z+2	; 0x02
    1d22:	93 81       	ldd	r25, Z+3	; 0x03
    1d24:	ef 81       	ldd	r30, Y+7	; 0x07
    1d26:	f8 85       	ldd	r31, Y+8	; 0x08
    1d28:	93 83       	std	Z+3, r25	; 0x03
    1d2a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1d2c:	ef 81       	ldd	r30, Y+7	; 0x07
    1d2e:	f8 85       	ldd	r31, Y+8	; 0x08
    1d30:	02 80       	ldd	r0, Z+2	; 0x02
    1d32:	f3 81       	ldd	r31, Z+3	; 0x03
    1d34:	e0 2d       	mov	r30, r0
    1d36:	8f 81       	ldd	r24, Y+7	; 0x07
    1d38:	98 85       	ldd	r25, Y+8	; 0x08
    1d3a:	95 83       	std	Z+5, r25	; 0x05
    1d3c:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1d3e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d40:	f8 85       	ldd	r31, Y+8	; 0x08
    1d42:	8b 81       	ldd	r24, Y+3	; 0x03
    1d44:	9c 81       	ldd	r25, Y+4	; 0x04
    1d46:	95 83       	std	Z+5, r25	; 0x05
    1d48:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1d4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d4e:	8f 81       	ldd	r24, Y+7	; 0x07
    1d50:	98 85       	ldd	r25, Y+8	; 0x08
    1d52:	93 83       	std	Z+3, r25	; 0x03
    1d54:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1d56:	ef 81       	ldd	r30, Y+7	; 0x07
    1d58:	f8 85       	ldd	r31, Y+8	; 0x08
    1d5a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d5c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d5e:	91 87       	std	Z+9, r25	; 0x09
    1d60:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1d62:	ed 81       	ldd	r30, Y+5	; 0x05
    1d64:	fe 81       	ldd	r31, Y+6	; 0x06
    1d66:	80 81       	ld	r24, Z
    1d68:	8f 5f       	subi	r24, 0xFF	; 255
    1d6a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d6c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d6e:	80 83       	st	Z, r24
}
    1d70:	28 96       	adiw	r28, 0x08	; 8
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	f8 94       	cli
    1d76:	de bf       	out	0x3e, r29	; 62
    1d78:	0f be       	out	0x3f, r0	; 63
    1d7a:	cd bf       	out	0x3d, r28	; 61
    1d7c:	cf 91       	pop	r28
    1d7e:	df 91       	pop	r29
    1d80:	08 95       	ret

00001d82 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d82:	df 93       	push	r29
    1d84:	cf 93       	push	r28
    1d86:	00 d0       	rcall	.+0      	; 0x1d88 <uxListRemove+0x6>
    1d88:	00 d0       	rcall	.+0      	; 0x1d8a <uxListRemove+0x8>
    1d8a:	cd b7       	in	r28, 0x3d	; 61
    1d8c:	de b7       	in	r29, 0x3e	; 62
    1d8e:	9c 83       	std	Y+4, r25	; 0x04
    1d90:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1d92:	eb 81       	ldd	r30, Y+3	; 0x03
    1d94:	fc 81       	ldd	r31, Y+4	; 0x04
    1d96:	80 85       	ldd	r24, Z+8	; 0x08
    1d98:	91 85       	ldd	r25, Z+9	; 0x09
    1d9a:	9a 83       	std	Y+2, r25	; 0x02
    1d9c:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d9e:	eb 81       	ldd	r30, Y+3	; 0x03
    1da0:	fc 81       	ldd	r31, Y+4	; 0x04
    1da2:	a2 81       	ldd	r26, Z+2	; 0x02
    1da4:	b3 81       	ldd	r27, Z+3	; 0x03
    1da6:	eb 81       	ldd	r30, Y+3	; 0x03
    1da8:	fc 81       	ldd	r31, Y+4	; 0x04
    1daa:	84 81       	ldd	r24, Z+4	; 0x04
    1dac:	95 81       	ldd	r25, Z+5	; 0x05
    1dae:	15 96       	adiw	r26, 0x05	; 5
    1db0:	9c 93       	st	X, r25
    1db2:	8e 93       	st	-X, r24
    1db4:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1db6:	eb 81       	ldd	r30, Y+3	; 0x03
    1db8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dba:	a4 81       	ldd	r26, Z+4	; 0x04
    1dbc:	b5 81       	ldd	r27, Z+5	; 0x05
    1dbe:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc0:	fc 81       	ldd	r31, Y+4	; 0x04
    1dc2:	82 81       	ldd	r24, Z+2	; 0x02
    1dc4:	93 81       	ldd	r25, Z+3	; 0x03
    1dc6:	13 96       	adiw	r26, 0x03	; 3
    1dc8:	9c 93       	st	X, r25
    1dca:	8e 93       	st	-X, r24
    1dcc:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1dce:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd0:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd2:	21 81       	ldd	r18, Z+1	; 0x01
    1dd4:	32 81       	ldd	r19, Z+2	; 0x02
    1dd6:	8b 81       	ldd	r24, Y+3	; 0x03
    1dd8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dda:	28 17       	cp	r18, r24
    1ddc:	39 07       	cpc	r19, r25
    1dde:	41 f4       	brne	.+16     	; 0x1df0 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1de0:	eb 81       	ldd	r30, Y+3	; 0x03
    1de2:	fc 81       	ldd	r31, Y+4	; 0x04
    1de4:	84 81       	ldd	r24, Z+4	; 0x04
    1de6:	95 81       	ldd	r25, Z+5	; 0x05
    1de8:	e9 81       	ldd	r30, Y+1	; 0x01
    1dea:	fa 81       	ldd	r31, Y+2	; 0x02
    1dec:	92 83       	std	Z+2, r25	; 0x02
    1dee:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1df0:	eb 81       	ldd	r30, Y+3	; 0x03
    1df2:	fc 81       	ldd	r31, Y+4	; 0x04
    1df4:	11 86       	std	Z+9, r1	; 0x09
    1df6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1df8:	e9 81       	ldd	r30, Y+1	; 0x01
    1dfa:	fa 81       	ldd	r31, Y+2	; 0x02
    1dfc:	80 81       	ld	r24, Z
    1dfe:	81 50       	subi	r24, 0x01	; 1
    1e00:	e9 81       	ldd	r30, Y+1	; 0x01
    1e02:	fa 81       	ldd	r31, Y+2	; 0x02
    1e04:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1e06:	e9 81       	ldd	r30, Y+1	; 0x01
    1e08:	fa 81       	ldd	r31, Y+2	; 0x02
    1e0a:	80 81       	ld	r24, Z
}
    1e0c:	0f 90       	pop	r0
    1e0e:	0f 90       	pop	r0
    1e10:	0f 90       	pop	r0
    1e12:	0f 90       	pop	r0
    1e14:	cf 91       	pop	r28
    1e16:	df 91       	pop	r29
    1e18:	08 95       	ret

00001e1a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1e1a:	df 93       	push	r29
    1e1c:	cf 93       	push	r28
    1e1e:	cd b7       	in	r28, 0x3d	; 61
    1e20:	de b7       	in	r29, 0x3e	; 62
    1e22:	28 97       	sbiw	r28, 0x08	; 8
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	de bf       	out	0x3e, r29	; 62
    1e2a:	0f be       	out	0x3f, r0	; 63
    1e2c:	cd bf       	out	0x3d, r28	; 61
    1e2e:	9c 83       	std	Y+4, r25	; 0x04
    1e30:	8b 83       	std	Y+3, r24	; 0x03
    1e32:	7e 83       	std	Y+6, r23	; 0x06
    1e34:	6d 83       	std	Y+5, r22	; 0x05
    1e36:	58 87       	std	Y+8, r21	; 0x08
    1e38:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1e3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e3e:	81 e1       	ldi	r24, 0x11	; 17
    1e40:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e42:	8b 81       	ldd	r24, Y+3	; 0x03
    1e44:	9c 81       	ldd	r25, Y+4	; 0x04
    1e46:	01 97       	sbiw	r24, 0x01	; 1
    1e48:	9c 83       	std	Y+4, r25	; 0x04
    1e4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1e4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e50:	82 e2       	ldi	r24, 0x22	; 34
    1e52:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e54:	8b 81       	ldd	r24, Y+3	; 0x03
    1e56:	9c 81       	ldd	r25, Y+4	; 0x04
    1e58:	01 97       	sbiw	r24, 0x01	; 1
    1e5a:	9c 83       	std	Y+4, r25	; 0x04
    1e5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1e5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e60:	fc 81       	ldd	r31, Y+4	; 0x04
    1e62:	83 e3       	ldi	r24, 0x33	; 51
    1e64:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e66:	8b 81       	ldd	r24, Y+3	; 0x03
    1e68:	9c 81       	ldd	r25, Y+4	; 0x04
    1e6a:	01 97       	sbiw	r24, 0x01	; 1
    1e6c:	9c 83       	std	Y+4, r25	; 0x04
    1e6e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1e70:	8d 81       	ldd	r24, Y+5	; 0x05
    1e72:	9e 81       	ldd	r25, Y+6	; 0x06
    1e74:	9a 83       	std	Y+2, r25	; 0x02
    1e76:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1e78:	89 81       	ldd	r24, Y+1	; 0x01
    1e7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e7e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e80:	8b 81       	ldd	r24, Y+3	; 0x03
    1e82:	9c 81       	ldd	r25, Y+4	; 0x04
    1e84:	01 97       	sbiw	r24, 0x01	; 1
    1e86:	9c 83       	std	Y+4, r25	; 0x04
    1e88:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1e8a:	89 81       	ldd	r24, Y+1	; 0x01
    1e8c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e8e:	89 2f       	mov	r24, r25
    1e90:	99 27       	eor	r25, r25
    1e92:	9a 83       	std	Y+2, r25	; 0x02
    1e94:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1e96:	89 81       	ldd	r24, Y+1	; 0x01
    1e98:	eb 81       	ldd	r30, Y+3	; 0x03
    1e9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea2:	01 97       	sbiw	r24, 0x01	; 1
    1ea4:	9c 83       	std	Y+4, r25	; 0x04
    1ea6:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1ea8:	eb 81       	ldd	r30, Y+3	; 0x03
    1eaa:	fc 81       	ldd	r31, Y+4	; 0x04
    1eac:	10 82       	st	Z, r1
	pxTopOfStack--;
    1eae:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb2:	01 97       	sbiw	r24, 0x01	; 1
    1eb4:	9c 83       	std	Y+4, r25	; 0x04
    1eb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1eb8:	eb 81       	ldd	r30, Y+3	; 0x03
    1eba:	fc 81       	ldd	r31, Y+4	; 0x04
    1ebc:	80 e8       	ldi	r24, 0x80	; 128
    1ebe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec4:	01 97       	sbiw	r24, 0x01	; 1
    1ec6:	9c 83       	std	Y+4, r25	; 0x04
    1ec8:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1eca:	eb 81       	ldd	r30, Y+3	; 0x03
    1ecc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ece:	10 82       	st	Z, r1
	pxTopOfStack--;
    1ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ed4:	01 97       	sbiw	r24, 0x01	; 1
    1ed6:	9c 83       	std	Y+4, r25	; 0x04
    1ed8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1eda:	eb 81       	ldd	r30, Y+3	; 0x03
    1edc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ede:	82 e0       	ldi	r24, 0x02	; 2
    1ee0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee6:	01 97       	sbiw	r24, 0x01	; 1
    1ee8:	9c 83       	std	Y+4, r25	; 0x04
    1eea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1eec:	eb 81       	ldd	r30, Y+3	; 0x03
    1eee:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef0:	83 e0       	ldi	r24, 0x03	; 3
    1ef2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ef4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef8:	01 97       	sbiw	r24, 0x01	; 1
    1efa:	9c 83       	std	Y+4, r25	; 0x04
    1efc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1efe:	eb 81       	ldd	r30, Y+3	; 0x03
    1f00:	fc 81       	ldd	r31, Y+4	; 0x04
    1f02:	84 e0       	ldi	r24, 0x04	; 4
    1f04:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f06:	8b 81       	ldd	r24, Y+3	; 0x03
    1f08:	9c 81       	ldd	r25, Y+4	; 0x04
    1f0a:	01 97       	sbiw	r24, 0x01	; 1
    1f0c:	9c 83       	std	Y+4, r25	; 0x04
    1f0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1f10:	eb 81       	ldd	r30, Y+3	; 0x03
    1f12:	fc 81       	ldd	r31, Y+4	; 0x04
    1f14:	85 e0       	ldi	r24, 0x05	; 5
    1f16:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f18:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1c:	01 97       	sbiw	r24, 0x01	; 1
    1f1e:	9c 83       	std	Y+4, r25	; 0x04
    1f20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1f22:	eb 81       	ldd	r30, Y+3	; 0x03
    1f24:	fc 81       	ldd	r31, Y+4	; 0x04
    1f26:	86 e0       	ldi	r24, 0x06	; 6
    1f28:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f2e:	01 97       	sbiw	r24, 0x01	; 1
    1f30:	9c 83       	std	Y+4, r25	; 0x04
    1f32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1f34:	eb 81       	ldd	r30, Y+3	; 0x03
    1f36:	fc 81       	ldd	r31, Y+4	; 0x04
    1f38:	87 e0       	ldi	r24, 0x07	; 7
    1f3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f40:	01 97       	sbiw	r24, 0x01	; 1
    1f42:	9c 83       	std	Y+4, r25	; 0x04
    1f44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1f46:	eb 81       	ldd	r30, Y+3	; 0x03
    1f48:	fc 81       	ldd	r31, Y+4	; 0x04
    1f4a:	88 e0       	ldi	r24, 0x08	; 8
    1f4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f50:	9c 81       	ldd	r25, Y+4	; 0x04
    1f52:	01 97       	sbiw	r24, 0x01	; 1
    1f54:	9c 83       	std	Y+4, r25	; 0x04
    1f56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1f58:	eb 81       	ldd	r30, Y+3	; 0x03
    1f5a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f5c:	89 e0       	ldi	r24, 0x09	; 9
    1f5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f60:	8b 81       	ldd	r24, Y+3	; 0x03
    1f62:	9c 81       	ldd	r25, Y+4	; 0x04
    1f64:	01 97       	sbiw	r24, 0x01	; 1
    1f66:	9c 83       	std	Y+4, r25	; 0x04
    1f68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1f6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f6e:	80 e1       	ldi	r24, 0x10	; 16
    1f70:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f72:	8b 81       	ldd	r24, Y+3	; 0x03
    1f74:	9c 81       	ldd	r25, Y+4	; 0x04
    1f76:	01 97       	sbiw	r24, 0x01	; 1
    1f78:	9c 83       	std	Y+4, r25	; 0x04
    1f7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1f7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f80:	81 e1       	ldi	r24, 0x11	; 17
    1f82:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f84:	8b 81       	ldd	r24, Y+3	; 0x03
    1f86:	9c 81       	ldd	r25, Y+4	; 0x04
    1f88:	01 97       	sbiw	r24, 0x01	; 1
    1f8a:	9c 83       	std	Y+4, r25	; 0x04
    1f8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1f8e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f90:	fc 81       	ldd	r31, Y+4	; 0x04
    1f92:	82 e1       	ldi	r24, 0x12	; 18
    1f94:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f96:	8b 81       	ldd	r24, Y+3	; 0x03
    1f98:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9a:	01 97       	sbiw	r24, 0x01	; 1
    1f9c:	9c 83       	std	Y+4, r25	; 0x04
    1f9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa4:	83 e1       	ldi	r24, 0x13	; 19
    1fa6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fa8:	8b 81       	ldd	r24, Y+3	; 0x03
    1faa:	9c 81       	ldd	r25, Y+4	; 0x04
    1fac:	01 97       	sbiw	r24, 0x01	; 1
    1fae:	9c 83       	std	Y+4, r25	; 0x04
    1fb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1fb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1fb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1fb6:	84 e1       	ldi	r24, 0x14	; 20
    1fb8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fba:	8b 81       	ldd	r24, Y+3	; 0x03
    1fbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1fbe:	01 97       	sbiw	r24, 0x01	; 1
    1fc0:	9c 83       	std	Y+4, r25	; 0x04
    1fc2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1fc4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fc6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fc8:	85 e1       	ldi	r24, 0x15	; 21
    1fca:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fce:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd0:	01 97       	sbiw	r24, 0x01	; 1
    1fd2:	9c 83       	std	Y+4, r25	; 0x04
    1fd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1fd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fda:	86 e1       	ldi	r24, 0x16	; 22
    1fdc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fde:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe2:	01 97       	sbiw	r24, 0x01	; 1
    1fe4:	9c 83       	std	Y+4, r25	; 0x04
    1fe6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    1fea:	fc 81       	ldd	r31, Y+4	; 0x04
    1fec:	87 e1       	ldi	r24, 0x17	; 23
    1fee:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ff0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff4:	01 97       	sbiw	r24, 0x01	; 1
    1ff6:	9c 83       	std	Y+4, r25	; 0x04
    1ff8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1ffa:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ffe:	88 e1       	ldi	r24, 0x18	; 24
    2000:	80 83       	st	Z, r24
	pxTopOfStack--;
    2002:	8b 81       	ldd	r24, Y+3	; 0x03
    2004:	9c 81       	ldd	r25, Y+4	; 0x04
    2006:	01 97       	sbiw	r24, 0x01	; 1
    2008:	9c 83       	std	Y+4, r25	; 0x04
    200a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    200c:	eb 81       	ldd	r30, Y+3	; 0x03
    200e:	fc 81       	ldd	r31, Y+4	; 0x04
    2010:	89 e1       	ldi	r24, 0x19	; 25
    2012:	80 83       	st	Z, r24
	pxTopOfStack--;
    2014:	8b 81       	ldd	r24, Y+3	; 0x03
    2016:	9c 81       	ldd	r25, Y+4	; 0x04
    2018:	01 97       	sbiw	r24, 0x01	; 1
    201a:	9c 83       	std	Y+4, r25	; 0x04
    201c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    201e:	eb 81       	ldd	r30, Y+3	; 0x03
    2020:	fc 81       	ldd	r31, Y+4	; 0x04
    2022:	80 e2       	ldi	r24, 0x20	; 32
    2024:	80 83       	st	Z, r24
	pxTopOfStack--;
    2026:	8b 81       	ldd	r24, Y+3	; 0x03
    2028:	9c 81       	ldd	r25, Y+4	; 0x04
    202a:	01 97       	sbiw	r24, 0x01	; 1
    202c:	9c 83       	std	Y+4, r25	; 0x04
    202e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2030:	eb 81       	ldd	r30, Y+3	; 0x03
    2032:	fc 81       	ldd	r31, Y+4	; 0x04
    2034:	81 e2       	ldi	r24, 0x21	; 33
    2036:	80 83       	st	Z, r24
	pxTopOfStack--;
    2038:	8b 81       	ldd	r24, Y+3	; 0x03
    203a:	9c 81       	ldd	r25, Y+4	; 0x04
    203c:	01 97       	sbiw	r24, 0x01	; 1
    203e:	9c 83       	std	Y+4, r25	; 0x04
    2040:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2042:	eb 81       	ldd	r30, Y+3	; 0x03
    2044:	fc 81       	ldd	r31, Y+4	; 0x04
    2046:	82 e2       	ldi	r24, 0x22	; 34
    2048:	80 83       	st	Z, r24
	pxTopOfStack--;
    204a:	8b 81       	ldd	r24, Y+3	; 0x03
    204c:	9c 81       	ldd	r25, Y+4	; 0x04
    204e:	01 97       	sbiw	r24, 0x01	; 1
    2050:	9c 83       	std	Y+4, r25	; 0x04
    2052:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2054:	eb 81       	ldd	r30, Y+3	; 0x03
    2056:	fc 81       	ldd	r31, Y+4	; 0x04
    2058:	83 e2       	ldi	r24, 0x23	; 35
    205a:	80 83       	st	Z, r24
	pxTopOfStack--;
    205c:	8b 81       	ldd	r24, Y+3	; 0x03
    205e:	9c 81       	ldd	r25, Y+4	; 0x04
    2060:	01 97       	sbiw	r24, 0x01	; 1
    2062:	9c 83       	std	Y+4, r25	; 0x04
    2064:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2066:	8f 81       	ldd	r24, Y+7	; 0x07
    2068:	98 85       	ldd	r25, Y+8	; 0x08
    206a:	9a 83       	std	Y+2, r25	; 0x02
    206c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    206e:	89 81       	ldd	r24, Y+1	; 0x01
    2070:	eb 81       	ldd	r30, Y+3	; 0x03
    2072:	fc 81       	ldd	r31, Y+4	; 0x04
    2074:	80 83       	st	Z, r24
	pxTopOfStack--;
    2076:	8b 81       	ldd	r24, Y+3	; 0x03
    2078:	9c 81       	ldd	r25, Y+4	; 0x04
    207a:	01 97       	sbiw	r24, 0x01	; 1
    207c:	9c 83       	std	Y+4, r25	; 0x04
    207e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2080:	89 81       	ldd	r24, Y+1	; 0x01
    2082:	9a 81       	ldd	r25, Y+2	; 0x02
    2084:	89 2f       	mov	r24, r25
    2086:	99 27       	eor	r25, r25
    2088:	9a 83       	std	Y+2, r25	; 0x02
    208a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    208c:	89 81       	ldd	r24, Y+1	; 0x01
    208e:	eb 81       	ldd	r30, Y+3	; 0x03
    2090:	fc 81       	ldd	r31, Y+4	; 0x04
    2092:	80 83       	st	Z, r24
	pxTopOfStack--;
    2094:	8b 81       	ldd	r24, Y+3	; 0x03
    2096:	9c 81       	ldd	r25, Y+4	; 0x04
    2098:	01 97       	sbiw	r24, 0x01	; 1
    209a:	9c 83       	std	Y+4, r25	; 0x04
    209c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    209e:	eb 81       	ldd	r30, Y+3	; 0x03
    20a0:	fc 81       	ldd	r31, Y+4	; 0x04
    20a2:	86 e2       	ldi	r24, 0x26	; 38
    20a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    20a6:	8b 81       	ldd	r24, Y+3	; 0x03
    20a8:	9c 81       	ldd	r25, Y+4	; 0x04
    20aa:	01 97       	sbiw	r24, 0x01	; 1
    20ac:	9c 83       	std	Y+4, r25	; 0x04
    20ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    20b0:	eb 81       	ldd	r30, Y+3	; 0x03
    20b2:	fc 81       	ldd	r31, Y+4	; 0x04
    20b4:	87 e2       	ldi	r24, 0x27	; 39
    20b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    20b8:	8b 81       	ldd	r24, Y+3	; 0x03
    20ba:	9c 81       	ldd	r25, Y+4	; 0x04
    20bc:	01 97       	sbiw	r24, 0x01	; 1
    20be:	9c 83       	std	Y+4, r25	; 0x04
    20c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    20c2:	eb 81       	ldd	r30, Y+3	; 0x03
    20c4:	fc 81       	ldd	r31, Y+4	; 0x04
    20c6:	88 e2       	ldi	r24, 0x28	; 40
    20c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ca:	8b 81       	ldd	r24, Y+3	; 0x03
    20cc:	9c 81       	ldd	r25, Y+4	; 0x04
    20ce:	01 97       	sbiw	r24, 0x01	; 1
    20d0:	9c 83       	std	Y+4, r25	; 0x04
    20d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    20d4:	eb 81       	ldd	r30, Y+3	; 0x03
    20d6:	fc 81       	ldd	r31, Y+4	; 0x04
    20d8:	89 e2       	ldi	r24, 0x29	; 41
    20da:	80 83       	st	Z, r24
	pxTopOfStack--;
    20dc:	8b 81       	ldd	r24, Y+3	; 0x03
    20de:	9c 81       	ldd	r25, Y+4	; 0x04
    20e0:	01 97       	sbiw	r24, 0x01	; 1
    20e2:	9c 83       	std	Y+4, r25	; 0x04
    20e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    20e6:	eb 81       	ldd	r30, Y+3	; 0x03
    20e8:	fc 81       	ldd	r31, Y+4	; 0x04
    20ea:	80 e3       	ldi	r24, 0x30	; 48
    20ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ee:	8b 81       	ldd	r24, Y+3	; 0x03
    20f0:	9c 81       	ldd	r25, Y+4	; 0x04
    20f2:	01 97       	sbiw	r24, 0x01	; 1
    20f4:	9c 83       	std	Y+4, r25	; 0x04
    20f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    20f8:	eb 81       	ldd	r30, Y+3	; 0x03
    20fa:	fc 81       	ldd	r31, Y+4	; 0x04
    20fc:	81 e3       	ldi	r24, 0x31	; 49
    20fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2100:	8b 81       	ldd	r24, Y+3	; 0x03
    2102:	9c 81       	ldd	r25, Y+4	; 0x04
    2104:	01 97       	sbiw	r24, 0x01	; 1
    2106:	9c 83       	std	Y+4, r25	; 0x04
    2108:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    210a:	8b 81       	ldd	r24, Y+3	; 0x03
    210c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    210e:	28 96       	adiw	r28, 0x08	; 8
    2110:	0f b6       	in	r0, 0x3f	; 63
    2112:	f8 94       	cli
    2114:	de bf       	out	0x3e, r29	; 62
    2116:	0f be       	out	0x3f, r0	; 63
    2118:	cd bf       	out	0x3d, r28	; 61
    211a:	cf 91       	pop	r28
    211c:	df 91       	pop	r29
    211e:	08 95       	ret

00002120 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2120:	df 93       	push	r29
    2122:	cf 93       	push	r28
    2124:	cd b7       	in	r28, 0x3d	; 61
    2126:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2128:	0e 94 82 11 	call	0x2304	; 0x2304 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    212c:	a0 91 75 04 	lds	r26, 0x0475
    2130:	b0 91 76 04 	lds	r27, 0x0476
    2134:	cd 91       	ld	r28, X+
    2136:	cd bf       	out	0x3d, r28	; 61
    2138:	dd 91       	ld	r29, X+
    213a:	de bf       	out	0x3e, r29	; 62
    213c:	ff 91       	pop	r31
    213e:	ef 91       	pop	r30
    2140:	df 91       	pop	r29
    2142:	cf 91       	pop	r28
    2144:	bf 91       	pop	r27
    2146:	af 91       	pop	r26
    2148:	9f 91       	pop	r25
    214a:	8f 91       	pop	r24
    214c:	7f 91       	pop	r23
    214e:	6f 91       	pop	r22
    2150:	5f 91       	pop	r21
    2152:	4f 91       	pop	r20
    2154:	3f 91       	pop	r19
    2156:	2f 91       	pop	r18
    2158:	1f 91       	pop	r17
    215a:	0f 91       	pop	r16
    215c:	ff 90       	pop	r15
    215e:	ef 90       	pop	r14
    2160:	df 90       	pop	r13
    2162:	cf 90       	pop	r12
    2164:	bf 90       	pop	r11
    2166:	af 90       	pop	r10
    2168:	9f 90       	pop	r9
    216a:	8f 90       	pop	r8
    216c:	7f 90       	pop	r7
    216e:	6f 90       	pop	r6
    2170:	5f 90       	pop	r5
    2172:	4f 90       	pop	r4
    2174:	3f 90       	pop	r3
    2176:	2f 90       	pop	r2
    2178:	1f 90       	pop	r1
    217a:	0f 90       	pop	r0
    217c:	0f be       	out	0x3f, r0	; 63
    217e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2180:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2182:	81 e0       	ldi	r24, 0x01	; 1
}
    2184:	cf 91       	pop	r28
    2186:	df 91       	pop	r29
    2188:	08 95       	ret

0000218a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    218a:	df 93       	push	r29
    218c:	cf 93       	push	r28
    218e:	cd b7       	in	r28, 0x3d	; 61
    2190:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2192:	cf 91       	pop	r28
    2194:	df 91       	pop	r29
    2196:	08 95       	ret

00002198 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2198:	0f 92       	push	r0
    219a:	0f b6       	in	r0, 0x3f	; 63
    219c:	f8 94       	cli
    219e:	0f 92       	push	r0
    21a0:	1f 92       	push	r1
    21a2:	11 24       	eor	r1, r1
    21a4:	2f 92       	push	r2
    21a6:	3f 92       	push	r3
    21a8:	4f 92       	push	r4
    21aa:	5f 92       	push	r5
    21ac:	6f 92       	push	r6
    21ae:	7f 92       	push	r7
    21b0:	8f 92       	push	r8
    21b2:	9f 92       	push	r9
    21b4:	af 92       	push	r10
    21b6:	bf 92       	push	r11
    21b8:	cf 92       	push	r12
    21ba:	df 92       	push	r13
    21bc:	ef 92       	push	r14
    21be:	ff 92       	push	r15
    21c0:	0f 93       	push	r16
    21c2:	1f 93       	push	r17
    21c4:	2f 93       	push	r18
    21c6:	3f 93       	push	r19
    21c8:	4f 93       	push	r20
    21ca:	5f 93       	push	r21
    21cc:	6f 93       	push	r22
    21ce:	7f 93       	push	r23
    21d0:	8f 93       	push	r24
    21d2:	9f 93       	push	r25
    21d4:	af 93       	push	r26
    21d6:	bf 93       	push	r27
    21d8:	cf 93       	push	r28
    21da:	df 93       	push	r29
    21dc:	ef 93       	push	r30
    21de:	ff 93       	push	r31
    21e0:	a0 91 75 04 	lds	r26, 0x0475
    21e4:	b0 91 76 04 	lds	r27, 0x0476
    21e8:	0d b6       	in	r0, 0x3d	; 61
    21ea:	0d 92       	st	X+, r0
    21ec:	0e b6       	in	r0, 0x3e	; 62
    21ee:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    21f0:	0e 94 62 1d 	call	0x3ac4	; 0x3ac4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    21f4:	a0 91 75 04 	lds	r26, 0x0475
    21f8:	b0 91 76 04 	lds	r27, 0x0476
    21fc:	cd 91       	ld	r28, X+
    21fe:	cd bf       	out	0x3d, r28	; 61
    2200:	dd 91       	ld	r29, X+
    2202:	de bf       	out	0x3e, r29	; 62
    2204:	ff 91       	pop	r31
    2206:	ef 91       	pop	r30
    2208:	df 91       	pop	r29
    220a:	cf 91       	pop	r28
    220c:	bf 91       	pop	r27
    220e:	af 91       	pop	r26
    2210:	9f 91       	pop	r25
    2212:	8f 91       	pop	r24
    2214:	7f 91       	pop	r23
    2216:	6f 91       	pop	r22
    2218:	5f 91       	pop	r21
    221a:	4f 91       	pop	r20
    221c:	3f 91       	pop	r19
    221e:	2f 91       	pop	r18
    2220:	1f 91       	pop	r17
    2222:	0f 91       	pop	r16
    2224:	ff 90       	pop	r15
    2226:	ef 90       	pop	r14
    2228:	df 90       	pop	r13
    222a:	cf 90       	pop	r12
    222c:	bf 90       	pop	r11
    222e:	af 90       	pop	r10
    2230:	9f 90       	pop	r9
    2232:	8f 90       	pop	r8
    2234:	7f 90       	pop	r7
    2236:	6f 90       	pop	r6
    2238:	5f 90       	pop	r5
    223a:	4f 90       	pop	r4
    223c:	3f 90       	pop	r3
    223e:	2f 90       	pop	r2
    2240:	1f 90       	pop	r1
    2242:	0f 90       	pop	r0
    2244:	0f be       	out	0x3f, r0	; 63
    2246:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2248:	08 95       	ret

0000224a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    224a:	0f 92       	push	r0
    224c:	0f b6       	in	r0, 0x3f	; 63
    224e:	f8 94       	cli
    2250:	0f 92       	push	r0
    2252:	1f 92       	push	r1
    2254:	11 24       	eor	r1, r1
    2256:	2f 92       	push	r2
    2258:	3f 92       	push	r3
    225a:	4f 92       	push	r4
    225c:	5f 92       	push	r5
    225e:	6f 92       	push	r6
    2260:	7f 92       	push	r7
    2262:	8f 92       	push	r8
    2264:	9f 92       	push	r9
    2266:	af 92       	push	r10
    2268:	bf 92       	push	r11
    226a:	cf 92       	push	r12
    226c:	df 92       	push	r13
    226e:	ef 92       	push	r14
    2270:	ff 92       	push	r15
    2272:	0f 93       	push	r16
    2274:	1f 93       	push	r17
    2276:	2f 93       	push	r18
    2278:	3f 93       	push	r19
    227a:	4f 93       	push	r20
    227c:	5f 93       	push	r21
    227e:	6f 93       	push	r22
    2280:	7f 93       	push	r23
    2282:	8f 93       	push	r24
    2284:	9f 93       	push	r25
    2286:	af 93       	push	r26
    2288:	bf 93       	push	r27
    228a:	cf 93       	push	r28
    228c:	df 93       	push	r29
    228e:	ef 93       	push	r30
    2290:	ff 93       	push	r31
    2292:	a0 91 75 04 	lds	r26, 0x0475
    2296:	b0 91 76 04 	lds	r27, 0x0476
    229a:	0d b6       	in	r0, 0x3d	; 61
    229c:	0d 92       	st	X+, r0
    229e:	0e b6       	in	r0, 0x3e	; 62
    22a0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    22a2:	0e 94 7d 1c 	call	0x38fa	; 0x38fa <xTaskIncrementTick>
    22a6:	88 23       	and	r24, r24
    22a8:	11 f0       	breq	.+4      	; 0x22ae <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    22aa:	0e 94 62 1d 	call	0x3ac4	; 0x3ac4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    22ae:	a0 91 75 04 	lds	r26, 0x0475
    22b2:	b0 91 76 04 	lds	r27, 0x0476
    22b6:	cd 91       	ld	r28, X+
    22b8:	cd bf       	out	0x3d, r28	; 61
    22ba:	dd 91       	ld	r29, X+
    22bc:	de bf       	out	0x3e, r29	; 62
    22be:	ff 91       	pop	r31
    22c0:	ef 91       	pop	r30
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	bf 91       	pop	r27
    22c8:	af 91       	pop	r26
    22ca:	9f 91       	pop	r25
    22cc:	8f 91       	pop	r24
    22ce:	7f 91       	pop	r23
    22d0:	6f 91       	pop	r22
    22d2:	5f 91       	pop	r21
    22d4:	4f 91       	pop	r20
    22d6:	3f 91       	pop	r19
    22d8:	2f 91       	pop	r18
    22da:	1f 91       	pop	r17
    22dc:	0f 91       	pop	r16
    22de:	ff 90       	pop	r15
    22e0:	ef 90       	pop	r14
    22e2:	df 90       	pop	r13
    22e4:	cf 90       	pop	r12
    22e6:	bf 90       	pop	r11
    22e8:	af 90       	pop	r10
    22ea:	9f 90       	pop	r9
    22ec:	8f 90       	pop	r8
    22ee:	7f 90       	pop	r7
    22f0:	6f 90       	pop	r6
    22f2:	5f 90       	pop	r5
    22f4:	4f 90       	pop	r4
    22f6:	3f 90       	pop	r3
    22f8:	2f 90       	pop	r2
    22fa:	1f 90       	pop	r1
    22fc:	0f 90       	pop	r0
    22fe:	0f be       	out	0x3f, r0	; 63
    2300:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2302:	08 95       	ret

00002304 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2304:	df 93       	push	r29
    2306:	cf 93       	push	r28
    2308:	00 d0       	rcall	.+0      	; 0x230a <prvSetupTimerInterrupt+0x6>
    230a:	00 d0       	rcall	.+0      	; 0x230c <prvSetupTimerInterrupt+0x8>
    230c:	00 d0       	rcall	.+0      	; 0x230e <prvSetupTimerInterrupt+0xa>
    230e:	cd b7       	in	r28, 0x3d	; 61
    2310:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2312:	80 e8       	ldi	r24, 0x80	; 128
    2314:	9e e3       	ldi	r25, 0x3E	; 62
    2316:	a0 e0       	ldi	r26, 0x00	; 0
    2318:	b0 e0       	ldi	r27, 0x00	; 0
    231a:	8b 83       	std	Y+3, r24	; 0x03
    231c:	9c 83       	std	Y+4, r25	; 0x04
    231e:	ad 83       	std	Y+5, r26	; 0x05
    2320:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2322:	8b 81       	ldd	r24, Y+3	; 0x03
    2324:	9c 81       	ldd	r25, Y+4	; 0x04
    2326:	ad 81       	ldd	r26, Y+5	; 0x05
    2328:	be 81       	ldd	r27, Y+6	; 0x06
    232a:	68 94       	set
    232c:	15 f8       	bld	r1, 5
    232e:	b6 95       	lsr	r27
    2330:	a7 95       	ror	r26
    2332:	97 95       	ror	r25
    2334:	87 95       	ror	r24
    2336:	16 94       	lsr	r1
    2338:	d1 f7       	brne	.-12     	; 0x232e <prvSetupTimerInterrupt+0x2a>
    233a:	8b 83       	std	Y+3, r24	; 0x03
    233c:	9c 83       	std	Y+4, r25	; 0x04
    233e:	ad 83       	std	Y+5, r26	; 0x05
    2340:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2342:	8b 81       	ldd	r24, Y+3	; 0x03
    2344:	9c 81       	ldd	r25, Y+4	; 0x04
    2346:	ad 81       	ldd	r26, Y+5	; 0x05
    2348:	be 81       	ldd	r27, Y+6	; 0x06
    234a:	01 97       	sbiw	r24, 0x01	; 1
    234c:	a1 09       	sbc	r26, r1
    234e:	b1 09       	sbc	r27, r1
    2350:	8b 83       	std	Y+3, r24	; 0x03
    2352:	9c 83       	std	Y+4, r25	; 0x04
    2354:	ad 83       	std	Y+5, r26	; 0x05
    2356:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2358:	8b 81       	ldd	r24, Y+3	; 0x03
    235a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    235c:	8b 81       	ldd	r24, Y+3	; 0x03
    235e:	9c 81       	ldd	r25, Y+4	; 0x04
    2360:	ad 81       	ldd	r26, Y+5	; 0x05
    2362:	be 81       	ldd	r27, Y+6	; 0x06
    2364:	89 2f       	mov	r24, r25
    2366:	9a 2f       	mov	r25, r26
    2368:	ab 2f       	mov	r26, r27
    236a:	bb 27       	eor	r27, r27
    236c:	8b 83       	std	Y+3, r24	; 0x03
    236e:	9c 83       	std	Y+4, r25	; 0x04
    2370:	ad 83       	std	Y+5, r26	; 0x05
    2372:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2374:	8b 81       	ldd	r24, Y+3	; 0x03
    2376:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2378:	eb e4       	ldi	r30, 0x4B	; 75
    237a:	f0 e0       	ldi	r31, 0x00	; 0
    237c:	8a 81       	ldd	r24, Y+2	; 0x02
    237e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2380:	ea e4       	ldi	r30, 0x4A	; 74
    2382:	f0 e0       	ldi	r31, 0x00	; 0
    2384:	89 81       	ldd	r24, Y+1	; 0x01
    2386:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2388:	8b e0       	ldi	r24, 0x0B	; 11
    238a:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    238c:	ee e4       	ldi	r30, 0x4E	; 78
    238e:	f0 e0       	ldi	r31, 0x00	; 0
    2390:	89 81       	ldd	r24, Y+1	; 0x01
    2392:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2394:	e9 e5       	ldi	r30, 0x59	; 89
    2396:	f0 e0       	ldi	r31, 0x00	; 0
    2398:	80 81       	ld	r24, Z
    239a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    239c:	89 81       	ldd	r24, Y+1	; 0x01
    239e:	80 61       	ori	r24, 0x10	; 16
    23a0:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    23a2:	e9 e5       	ldi	r30, 0x59	; 89
    23a4:	f0 e0       	ldi	r31, 0x00	; 0
    23a6:	89 81       	ldd	r24, Y+1	; 0x01
    23a8:	80 83       	st	Z, r24
}
    23aa:	26 96       	adiw	r28, 0x06	; 6
    23ac:	0f b6       	in	r0, 0x3f	; 63
    23ae:	f8 94       	cli
    23b0:	de bf       	out	0x3e, r29	; 62
    23b2:	0f be       	out	0x3f, r0	; 63
    23b4:	cd bf       	out	0x3d, r28	; 61
    23b6:	cf 91       	pop	r28
    23b8:	df 91       	pop	r29
    23ba:	08 95       	ret

000023bc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    23bc:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYieldFromTick>
		asm volatile ( "reti" );
    23c0:	18 95       	reti

000023c2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    23c2:	df 93       	push	r29
    23c4:	cf 93       	push	r28
    23c6:	00 d0       	rcall	.+0      	; 0x23c8 <xQueueGenericReset+0x6>
    23c8:	00 d0       	rcall	.+0      	; 0x23ca <xQueueGenericReset+0x8>
    23ca:	0f 92       	push	r0
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
    23d0:	9c 83       	std	Y+4, r25	; 0x04
    23d2:	8b 83       	std	Y+3, r24	; 0x03
    23d4:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    23d6:	8b 81       	ldd	r24, Y+3	; 0x03
    23d8:	9c 81       	ldd	r25, Y+4	; 0x04
    23da:	9a 83       	std	Y+2, r25	; 0x02
    23dc:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    23de:	0f b6       	in	r0, 0x3f	; 63
    23e0:	f8 94       	cli
    23e2:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    23e4:	e9 81       	ldd	r30, Y+1	; 0x01
    23e6:	fa 81       	ldd	r31, Y+2	; 0x02
    23e8:	40 81       	ld	r20, Z
    23ea:	51 81       	ldd	r21, Z+1	; 0x01
    23ec:	e9 81       	ldd	r30, Y+1	; 0x01
    23ee:	fa 81       	ldd	r31, Y+2	; 0x02
    23f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    23f2:	28 2f       	mov	r18, r24
    23f4:	30 e0       	ldi	r19, 0x00	; 0
    23f6:	e9 81       	ldd	r30, Y+1	; 0x01
    23f8:	fa 81       	ldd	r31, Y+2	; 0x02
    23fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    23fc:	88 2f       	mov	r24, r24
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	bc 01       	movw	r22, r24
    2402:	26 9f       	mul	r18, r22
    2404:	c0 01       	movw	r24, r0
    2406:	27 9f       	mul	r18, r23
    2408:	90 0d       	add	r25, r0
    240a:	36 9f       	mul	r19, r22
    240c:	90 0d       	add	r25, r0
    240e:	11 24       	eor	r1, r1
    2410:	84 0f       	add	r24, r20
    2412:	95 1f       	adc	r25, r21
    2414:	e9 81       	ldd	r30, Y+1	; 0x01
    2416:	fa 81       	ldd	r31, Y+2	; 0x02
    2418:	95 83       	std	Z+5, r25	; 0x05
    241a:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    241c:	e9 81       	ldd	r30, Y+1	; 0x01
    241e:	fa 81       	ldd	r31, Y+2	; 0x02
    2420:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2422:	e9 81       	ldd	r30, Y+1	; 0x01
    2424:	fa 81       	ldd	r31, Y+2	; 0x02
    2426:	80 81       	ld	r24, Z
    2428:	91 81       	ldd	r25, Z+1	; 0x01
    242a:	e9 81       	ldd	r30, Y+1	; 0x01
    242c:	fa 81       	ldd	r31, Y+2	; 0x02
    242e:	93 83       	std	Z+3, r25	; 0x03
    2430:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2432:	e9 81       	ldd	r30, Y+1	; 0x01
    2434:	fa 81       	ldd	r31, Y+2	; 0x02
    2436:	40 81       	ld	r20, Z
    2438:	51 81       	ldd	r21, Z+1	; 0x01
    243a:	e9 81       	ldd	r30, Y+1	; 0x01
    243c:	fa 81       	ldd	r31, Y+2	; 0x02
    243e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2440:	88 2f       	mov	r24, r24
    2442:	90 e0       	ldi	r25, 0x00	; 0
    2444:	9c 01       	movw	r18, r24
    2446:	21 50       	subi	r18, 0x01	; 1
    2448:	30 40       	sbci	r19, 0x00	; 0
    244a:	e9 81       	ldd	r30, Y+1	; 0x01
    244c:	fa 81       	ldd	r31, Y+2	; 0x02
    244e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2450:	88 2f       	mov	r24, r24
    2452:	90 e0       	ldi	r25, 0x00	; 0
    2454:	bc 01       	movw	r22, r24
    2456:	26 9f       	mul	r18, r22
    2458:	c0 01       	movw	r24, r0
    245a:	27 9f       	mul	r18, r23
    245c:	90 0d       	add	r25, r0
    245e:	36 9f       	mul	r19, r22
    2460:	90 0d       	add	r25, r0
    2462:	11 24       	eor	r1, r1
    2464:	84 0f       	add	r24, r20
    2466:	95 1f       	adc	r25, r21
    2468:	e9 81       	ldd	r30, Y+1	; 0x01
    246a:	fa 81       	ldd	r31, Y+2	; 0x02
    246c:	97 83       	std	Z+7, r25	; 0x07
    246e:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    2470:	e9 81       	ldd	r30, Y+1	; 0x01
    2472:	fa 81       	ldd	r31, Y+2	; 0x02
    2474:	8f ef       	ldi	r24, 0xFF	; 255
    2476:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    2478:	e9 81       	ldd	r30, Y+1	; 0x01
    247a:	fa 81       	ldd	r31, Y+2	; 0x02
    247c:	8f ef       	ldi	r24, 0xFF	; 255
    247e:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    2480:	8d 81       	ldd	r24, Y+5	; 0x05
    2482:	88 23       	and	r24, r24
    2484:	79 f4       	brne	.+30     	; 0x24a4 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2486:	e9 81       	ldd	r30, Y+1	; 0x01
    2488:	fa 81       	ldd	r31, Y+2	; 0x02
    248a:	80 85       	ldd	r24, Z+8	; 0x08
    248c:	88 23       	and	r24, r24
    248e:	a1 f0       	breq	.+40     	; 0x24b8 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2490:	89 81       	ldd	r24, Y+1	; 0x01
    2492:	9a 81       	ldd	r25, Y+2	; 0x02
    2494:	08 96       	adiw	r24, 0x08	; 8
    2496:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    249a:	88 23       	and	r24, r24
    249c:	69 f0       	breq	.+26     	; 0x24b8 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    249e:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
    24a2:	0a c0       	rjmp	.+20     	; 0x24b8 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    24a4:	89 81       	ldd	r24, Y+1	; 0x01
    24a6:	9a 81       	ldd	r25, Y+2	; 0x02
    24a8:	08 96       	adiw	r24, 0x08	; 8
    24aa:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    24ae:	89 81       	ldd	r24, Y+1	; 0x01
    24b0:	9a 81       	ldd	r25, Y+2	; 0x02
    24b2:	41 96       	adiw	r24, 0x11	; 17
    24b4:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    24b8:	0f 90       	pop	r0
    24ba:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    24bc:	81 e0       	ldi	r24, 0x01	; 1
}
    24be:	0f 90       	pop	r0
    24c0:	0f 90       	pop	r0
    24c2:	0f 90       	pop	r0
    24c4:	0f 90       	pop	r0
    24c6:	0f 90       	pop	r0
    24c8:	cf 91       	pop	r28
    24ca:	df 91       	pop	r29
    24cc:	08 95       	ret

000024ce <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    24ce:	0f 93       	push	r16
    24d0:	1f 93       	push	r17
    24d2:	df 93       	push	r29
    24d4:	cf 93       	push	r28
    24d6:	cd b7       	in	r28, 0x3d	; 61
    24d8:	de b7       	in	r29, 0x3e	; 62
    24da:	29 97       	sbiw	r28, 0x09	; 9
    24dc:	0f b6       	in	r0, 0x3f	; 63
    24de:	f8 94       	cli
    24e0:	de bf       	out	0x3e, r29	; 62
    24e2:	0f be       	out	0x3f, r0	; 63
    24e4:	cd bf       	out	0x3d, r28	; 61
    24e6:	8f 83       	std	Y+7, r24	; 0x07
    24e8:	68 87       	std	Y+8, r22	; 0x08
    24ea:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    24ec:	88 85       	ldd	r24, Y+8	; 0x08
    24ee:	88 23       	and	r24, r24
    24f0:	19 f4       	brne	.+6      	; 0x24f8 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    24f2:	1c 82       	std	Y+4, r1	; 0x04
    24f4:	1b 82       	std	Y+3, r1	; 0x03
    24f6:	10 c0       	rjmp	.+32     	; 0x2518 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    24f8:	8f 81       	ldd	r24, Y+7	; 0x07
    24fa:	28 2f       	mov	r18, r24
    24fc:	30 e0       	ldi	r19, 0x00	; 0
    24fe:	88 85       	ldd	r24, Y+8	; 0x08
    2500:	88 2f       	mov	r24, r24
    2502:	90 e0       	ldi	r25, 0x00	; 0
    2504:	ac 01       	movw	r20, r24
    2506:	24 9f       	mul	r18, r20
    2508:	c0 01       	movw	r24, r0
    250a:	25 9f       	mul	r18, r21
    250c:	90 0d       	add	r25, r0
    250e:	34 9f       	mul	r19, r20
    2510:	90 0d       	add	r25, r0
    2512:	11 24       	eor	r1, r1
    2514:	9c 83       	std	Y+4, r25	; 0x04
    2516:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2518:	8b 81       	ldd	r24, Y+3	; 0x03
    251a:	9c 81       	ldd	r25, Y+4	; 0x04
    251c:	4f 96       	adiw	r24, 0x1f	; 31
    251e:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <pvPortMalloc>
    2522:	9e 83       	std	Y+6, r25	; 0x06
    2524:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    2526:	8d 81       	ldd	r24, Y+5	; 0x05
    2528:	9e 81       	ldd	r25, Y+6	; 0x06
    252a:	00 97       	sbiw	r24, 0x00	; 0
    252c:	a1 f0       	breq	.+40     	; 0x2556 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    252e:	8d 81       	ldd	r24, Y+5	; 0x05
    2530:	9e 81       	ldd	r25, Y+6	; 0x06
    2532:	9a 83       	std	Y+2, r25	; 0x02
    2534:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2536:	89 81       	ldd	r24, Y+1	; 0x01
    2538:	9a 81       	ldd	r25, Y+2	; 0x02
    253a:	4f 96       	adiw	r24, 0x1f	; 31
    253c:	9a 83       	std	Y+2, r25	; 0x02
    253e:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2540:	29 81       	ldd	r18, Y+1	; 0x01
    2542:	3a 81       	ldd	r19, Y+2	; 0x02
    2544:	ed 81       	ldd	r30, Y+5	; 0x05
    2546:	fe 81       	ldd	r31, Y+6	; 0x06
    2548:	8f 81       	ldd	r24, Y+7	; 0x07
    254a:	68 85       	ldd	r22, Y+8	; 0x08
    254c:	a9 01       	movw	r20, r18
    254e:	29 85       	ldd	r18, Y+9	; 0x09
    2550:	8f 01       	movw	r16, r30
    2552:	0e 94 b8 12 	call	0x2570	; 0x2570 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    2556:	8d 81       	ldd	r24, Y+5	; 0x05
    2558:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    255a:	29 96       	adiw	r28, 0x09	; 9
    255c:	0f b6       	in	r0, 0x3f	; 63
    255e:	f8 94       	cli
    2560:	de bf       	out	0x3e, r29	; 62
    2562:	0f be       	out	0x3f, r0	; 63
    2564:	cd bf       	out	0x3d, r28	; 61
    2566:	cf 91       	pop	r28
    2568:	df 91       	pop	r29
    256a:	1f 91       	pop	r17
    256c:	0f 91       	pop	r16
    256e:	08 95       	ret

00002570 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    2570:	0f 93       	push	r16
    2572:	1f 93       	push	r17
    2574:	df 93       	push	r29
    2576:	cf 93       	push	r28
    2578:	cd b7       	in	r28, 0x3d	; 61
    257a:	de b7       	in	r29, 0x3e	; 62
    257c:	27 97       	sbiw	r28, 0x07	; 7
    257e:	0f b6       	in	r0, 0x3f	; 63
    2580:	f8 94       	cli
    2582:	de bf       	out	0x3e, r29	; 62
    2584:	0f be       	out	0x3f, r0	; 63
    2586:	cd bf       	out	0x3d, r28	; 61
    2588:	89 83       	std	Y+1, r24	; 0x01
    258a:	6a 83       	std	Y+2, r22	; 0x02
    258c:	5c 83       	std	Y+4, r21	; 0x04
    258e:	4b 83       	std	Y+3, r20	; 0x03
    2590:	2d 83       	std	Y+5, r18	; 0x05
    2592:	1f 83       	std	Y+7, r17	; 0x07
    2594:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    2596:	8a 81       	ldd	r24, Y+2	; 0x02
    2598:	88 23       	and	r24, r24
    259a:	39 f4       	brne	.+14     	; 0x25aa <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    259c:	8e 81       	ldd	r24, Y+6	; 0x06
    259e:	9f 81       	ldd	r25, Y+7	; 0x07
    25a0:	ee 81       	ldd	r30, Y+6	; 0x06
    25a2:	ff 81       	ldd	r31, Y+7	; 0x07
    25a4:	91 83       	std	Z+1, r25	; 0x01
    25a6:	80 83       	st	Z, r24
    25a8:	06 c0       	rjmp	.+12     	; 0x25b6 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    25aa:	8b 81       	ldd	r24, Y+3	; 0x03
    25ac:	9c 81       	ldd	r25, Y+4	; 0x04
    25ae:	ee 81       	ldd	r30, Y+6	; 0x06
    25b0:	ff 81       	ldd	r31, Y+7	; 0x07
    25b2:	91 83       	std	Z+1, r25	; 0x01
    25b4:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    25b6:	ee 81       	ldd	r30, Y+6	; 0x06
    25b8:	ff 81       	ldd	r31, Y+7	; 0x07
    25ba:	89 81       	ldd	r24, Y+1	; 0x01
    25bc:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    25be:	ee 81       	ldd	r30, Y+6	; 0x06
    25c0:	ff 81       	ldd	r31, Y+7	; 0x07
    25c2:	8a 81       	ldd	r24, Y+2	; 0x02
    25c4:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    25c6:	8e 81       	ldd	r24, Y+6	; 0x06
    25c8:	9f 81       	ldd	r25, Y+7	; 0x07
    25ca:	61 e0       	ldi	r22, 0x01	; 1
    25cc:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    25d0:	27 96       	adiw	r28, 0x07	; 7
    25d2:	0f b6       	in	r0, 0x3f	; 63
    25d4:	f8 94       	cli
    25d6:	de bf       	out	0x3e, r29	; 62
    25d8:	0f be       	out	0x3f, r0	; 63
    25da:	cd bf       	out	0x3d, r28	; 61
    25dc:	cf 91       	pop	r28
    25de:	df 91       	pop	r29
    25e0:	1f 91       	pop	r17
    25e2:	0f 91       	pop	r16
    25e4:	08 95       	ret

000025e6 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    25e6:	df 93       	push	r29
    25e8:	cf 93       	push	r28
    25ea:	cd b7       	in	r28, 0x3d	; 61
    25ec:	de b7       	in	r29, 0x3e	; 62
    25ee:	2f 97       	sbiw	r28, 0x0f	; 15
    25f0:	0f b6       	in	r0, 0x3f	; 63
    25f2:	f8 94       	cli
    25f4:	de bf       	out	0x3e, r29	; 62
    25f6:	0f be       	out	0x3f, r0	; 63
    25f8:	cd bf       	out	0x3d, r28	; 61
    25fa:	99 87       	std	Y+9, r25	; 0x09
    25fc:	88 87       	std	Y+8, r24	; 0x08
    25fe:	7b 87       	std	Y+11, r23	; 0x0b
    2600:	6a 87       	std	Y+10, r22	; 0x0a
    2602:	5d 87       	std	Y+13, r21	; 0x0d
    2604:	4c 87       	std	Y+12, r20	; 0x0c
    2606:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2608:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    260a:	88 85       	ldd	r24, Y+8	; 0x08
    260c:	99 85       	ldd	r25, Y+9	; 0x09
    260e:	9a 83       	std	Y+2, r25	; 0x02
    2610:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2612:	0f b6       	in	r0, 0x3f	; 63
    2614:	f8 94       	cli
    2616:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2618:	e9 81       	ldd	r30, Y+1	; 0x01
    261a:	fa 81       	ldd	r31, Y+2	; 0x02
    261c:	92 8d       	ldd	r25, Z+26	; 0x1a
    261e:	e9 81       	ldd	r30, Y+1	; 0x01
    2620:	fa 81       	ldd	r31, Y+2	; 0x02
    2622:	83 8d       	ldd	r24, Z+27	; 0x1b
    2624:	98 17       	cp	r25, r24
    2626:	18 f0       	brcs	.+6      	; 0x262e <xQueueGenericSend+0x48>
    2628:	8e 85       	ldd	r24, Y+14	; 0x0e
    262a:	82 30       	cpi	r24, 0x02	; 2
    262c:	11 f5       	brne	.+68     	; 0x2672 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    262e:	89 81       	ldd	r24, Y+1	; 0x01
    2630:	9a 81       	ldd	r25, Y+2	; 0x02
    2632:	2a 85       	ldd	r18, Y+10	; 0x0a
    2634:	3b 85       	ldd	r19, Y+11	; 0x0b
    2636:	b9 01       	movw	r22, r18
    2638:	4e 85       	ldd	r20, Y+14	; 0x0e
    263a:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <prvCopyDataToQueue>
    263e:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2640:	e9 81       	ldd	r30, Y+1	; 0x01
    2642:	fa 81       	ldd	r31, Y+2	; 0x02
    2644:	81 89       	ldd	r24, Z+17	; 0x11
    2646:	88 23       	and	r24, r24
    2648:	51 f0       	breq	.+20     	; 0x265e <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    264a:	89 81       	ldd	r24, Y+1	; 0x01
    264c:	9a 81       	ldd	r25, Y+2	; 0x02
    264e:	41 96       	adiw	r24, 0x11	; 17
    2650:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    2654:	88 23       	and	r24, r24
    2656:	41 f0       	breq	.+16     	; 0x2668 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2658:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
    265c:	05 c0       	rjmp	.+10     	; 0x2668 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    265e:	8b 81       	ldd	r24, Y+3	; 0x03
    2660:	88 23       	and	r24, r24
    2662:	11 f0       	breq	.+4      	; 0x2668 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2664:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2668:	0f 90       	pop	r0
    266a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    266c:	81 e0       	ldi	r24, 0x01	; 1
    266e:	8f 87       	std	Y+15, r24	; 0x0f
    2670:	5c c0       	rjmp	.+184    	; 0x272a <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2672:	8c 85       	ldd	r24, Y+12	; 0x0c
    2674:	9d 85       	ldd	r25, Y+13	; 0x0d
    2676:	00 97       	sbiw	r24, 0x00	; 0
    2678:	21 f4       	brne	.+8      	; 0x2682 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    267a:	0f 90       	pop	r0
    267c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    267e:	1f 86       	std	Y+15, r1	; 0x0f
    2680:	54 c0       	rjmp	.+168    	; 0x272a <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    2682:	8c 81       	ldd	r24, Y+4	; 0x04
    2684:	88 23       	and	r24, r24
    2686:	31 f4       	brne	.+12     	; 0x2694 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2688:	ce 01       	movw	r24, r28
    268a:	05 96       	adiw	r24, 0x05	; 5
    268c:	0e 94 07 1f 	call	0x3e0e	; 0x3e0e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2690:	81 e0       	ldi	r24, 0x01	; 1
    2692:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2694:	0f 90       	pop	r0
    2696:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2698:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    269c:	0f b6       	in	r0, 0x3f	; 63
    269e:	f8 94       	cli
    26a0:	0f 92       	push	r0
    26a2:	e9 81       	ldd	r30, Y+1	; 0x01
    26a4:	fa 81       	ldd	r31, Y+2	; 0x02
    26a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    26a8:	8f 3f       	cpi	r24, 0xFF	; 255
    26aa:	19 f4       	brne	.+6      	; 0x26b2 <xQueueGenericSend+0xcc>
    26ac:	e9 81       	ldd	r30, Y+1	; 0x01
    26ae:	fa 81       	ldd	r31, Y+2	; 0x02
    26b0:	15 8e       	std	Z+29, r1	; 0x1d
    26b2:	e9 81       	ldd	r30, Y+1	; 0x01
    26b4:	fa 81       	ldd	r31, Y+2	; 0x02
    26b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    26b8:	8f 3f       	cpi	r24, 0xFF	; 255
    26ba:	19 f4       	brne	.+6      	; 0x26c2 <xQueueGenericSend+0xdc>
    26bc:	e9 81       	ldd	r30, Y+1	; 0x01
    26be:	fa 81       	ldd	r31, Y+2	; 0x02
    26c0:	16 8e       	std	Z+30, r1	; 0x1e
    26c2:	0f 90       	pop	r0
    26c4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    26c6:	ce 01       	movw	r24, r28
    26c8:	05 96       	adiw	r24, 0x05	; 5
    26ca:	9e 01       	movw	r18, r28
    26cc:	24 5f       	subi	r18, 0xF4	; 244
    26ce:	3f 4f       	sbci	r19, 0xFF	; 255
    26d0:	b9 01       	movw	r22, r18
    26d2:	0e 94 20 1f 	call	0x3e40	; 0x3e40 <xTaskCheckForTimeOut>
    26d6:	88 23       	and	r24, r24
    26d8:	09 f5       	brne	.+66     	; 0x271c <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    26da:	89 81       	ldd	r24, Y+1	; 0x01
    26dc:	9a 81       	ldd	r25, Y+2	; 0x02
    26de:	0e 94 c1 18 	call	0x3182	; 0x3182 <prvIsQueueFull>
    26e2:	88 23       	and	r24, r24
    26e4:	a1 f0       	breq	.+40     	; 0x270e <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    26e6:	89 81       	ldd	r24, Y+1	; 0x01
    26e8:	9a 81       	ldd	r25, Y+2	; 0x02
    26ea:	08 96       	adiw	r24, 0x08	; 8
    26ec:	2c 85       	ldd	r18, Y+12	; 0x0c
    26ee:	3d 85       	ldd	r19, Y+13	; 0x0d
    26f0:	b9 01       	movw	r22, r18
    26f2:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    26f6:	89 81       	ldd	r24, Y+1	; 0x01
    26f8:	9a 81       	ldd	r25, Y+2	; 0x02
    26fa:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    26fe:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    2702:	88 23       	and	r24, r24
    2704:	09 f0       	breq	.+2      	; 0x2708 <xQueueGenericSend+0x122>
    2706:	85 cf       	rjmp	.-246    	; 0x2612 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2708:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
    270c:	82 cf       	rjmp	.-252    	; 0x2612 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    270e:	89 81       	ldd	r24, Y+1	; 0x01
    2710:	9a 81       	ldd	r25, Y+2	; 0x02
    2712:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2716:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    271a:	7b cf       	rjmp	.-266    	; 0x2612 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    271c:	89 81       	ldd	r24, Y+1	; 0x01
    271e:	9a 81       	ldd	r25, Y+2	; 0x02
    2720:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2724:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2728:	1f 86       	std	Y+15, r1	; 0x0f
    272a:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    272c:	2f 96       	adiw	r28, 0x0f	; 15
    272e:	0f b6       	in	r0, 0x3f	; 63
    2730:	f8 94       	cli
    2732:	de bf       	out	0x3e, r29	; 62
    2734:	0f be       	out	0x3f, r0	; 63
    2736:	cd bf       	out	0x3d, r28	; 61
    2738:	cf 91       	pop	r28
    273a:	df 91       	pop	r29
    273c:	08 95       	ret

0000273e <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    273e:	df 93       	push	r29
    2740:	cf 93       	push	r28
    2742:	cd b7       	in	r28, 0x3d	; 61
    2744:	de b7       	in	r29, 0x3e	; 62
    2746:	2c 97       	sbiw	r28, 0x0c	; 12
    2748:	0f b6       	in	r0, 0x3f	; 63
    274a:	f8 94       	cli
    274c:	de bf       	out	0x3e, r29	; 62
    274e:	0f be       	out	0x3f, r0	; 63
    2750:	cd bf       	out	0x3d, r28	; 61
    2752:	9f 83       	std	Y+7, r25	; 0x07
    2754:	8e 83       	std	Y+6, r24	; 0x06
    2756:	79 87       	std	Y+9, r23	; 0x09
    2758:	68 87       	std	Y+8, r22	; 0x08
    275a:	5b 87       	std	Y+11, r21	; 0x0b
    275c:	4a 87       	std	Y+10, r20	; 0x0a
    275e:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2760:	8e 81       	ldd	r24, Y+6	; 0x06
    2762:	9f 81       	ldd	r25, Y+7	; 0x07
    2764:	9b 83       	std	Y+3, r25	; 0x03
    2766:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2768:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    276a:	ea 81       	ldd	r30, Y+2	; 0x02
    276c:	fb 81       	ldd	r31, Y+3	; 0x03
    276e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2770:	ea 81       	ldd	r30, Y+2	; 0x02
    2772:	fb 81       	ldd	r31, Y+3	; 0x03
    2774:	83 8d       	ldd	r24, Z+27	; 0x1b
    2776:	98 17       	cp	r25, r24
    2778:	18 f0       	brcs	.+6      	; 0x2780 <xQueueGenericSendFromISR+0x42>
    277a:	8c 85       	ldd	r24, Y+12	; 0x0c
    277c:	82 30       	cpi	r24, 0x02	; 2
    277e:	61 f5       	brne	.+88     	; 0x27d8 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2780:	ea 81       	ldd	r30, Y+2	; 0x02
    2782:	fb 81       	ldd	r31, Y+3	; 0x03
    2784:	86 8d       	ldd	r24, Z+30	; 0x1e
    2786:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2788:	8a 81       	ldd	r24, Y+2	; 0x02
    278a:	9b 81       	ldd	r25, Y+3	; 0x03
    278c:	28 85       	ldd	r18, Y+8	; 0x08
    278e:	39 85       	ldd	r19, Y+9	; 0x09
    2790:	b9 01       	movw	r22, r18
    2792:	4c 85       	ldd	r20, Y+12	; 0x0c
    2794:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2798:	89 81       	ldd	r24, Y+1	; 0x01
    279a:	8f 3f       	cpi	r24, 0xFF	; 255
    279c:	a9 f4       	brne	.+42     	; 0x27c8 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    279e:	ea 81       	ldd	r30, Y+2	; 0x02
    27a0:	fb 81       	ldd	r31, Y+3	; 0x03
    27a2:	81 89       	ldd	r24, Z+17	; 0x11
    27a4:	88 23       	and	r24, r24
    27a6:	a9 f0       	breq	.+42     	; 0x27d2 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    27a8:	8a 81       	ldd	r24, Y+2	; 0x02
    27aa:	9b 81       	ldd	r25, Y+3	; 0x03
    27ac:	41 96       	adiw	r24, 0x11	; 17
    27ae:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    27b2:	88 23       	and	r24, r24
    27b4:	71 f0       	breq	.+28     	; 0x27d2 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    27b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    27b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    27ba:	00 97       	sbiw	r24, 0x00	; 0
    27bc:	51 f0       	breq	.+20     	; 0x27d2 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    27be:	ea 85       	ldd	r30, Y+10	; 0x0a
    27c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    27c2:	81 e0       	ldi	r24, 0x01	; 1
    27c4:	80 83       	st	Z, r24
    27c6:	05 c0       	rjmp	.+10     	; 0x27d2 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    27c8:	89 81       	ldd	r24, Y+1	; 0x01
    27ca:	8f 5f       	subi	r24, 0xFF	; 255
    27cc:	ea 81       	ldd	r30, Y+2	; 0x02
    27ce:	fb 81       	ldd	r31, Y+3	; 0x03
    27d0:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    27d2:	81 e0       	ldi	r24, 0x01	; 1
    27d4:	8d 83       	std	Y+5, r24	; 0x05
    27d6:	01 c0       	rjmp	.+2      	; 0x27da <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    27d8:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    27da:	8d 81       	ldd	r24, Y+5	; 0x05
}
    27dc:	2c 96       	adiw	r28, 0x0c	; 12
    27de:	0f b6       	in	r0, 0x3f	; 63
    27e0:	f8 94       	cli
    27e2:	de bf       	out	0x3e, r29	; 62
    27e4:	0f be       	out	0x3f, r0	; 63
    27e6:	cd bf       	out	0x3d, r28	; 61
    27e8:	cf 91       	pop	r28
    27ea:	df 91       	pop	r29
    27ec:	08 95       	ret

000027ee <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    27ee:	df 93       	push	r29
    27f0:	cf 93       	push	r28
    27f2:	cd b7       	in	r28, 0x3d	; 61
    27f4:	de b7       	in	r29, 0x3e	; 62
    27f6:	2a 97       	sbiw	r28, 0x0a	; 10
    27f8:	0f b6       	in	r0, 0x3f	; 63
    27fa:	f8 94       	cli
    27fc:	de bf       	out	0x3e, r29	; 62
    27fe:	0f be       	out	0x3f, r0	; 63
    2800:	cd bf       	out	0x3d, r28	; 61
    2802:	98 87       	std	Y+8, r25	; 0x08
    2804:	8f 83       	std	Y+7, r24	; 0x07
    2806:	7a 87       	std	Y+10, r23	; 0x0a
    2808:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    280a:	8f 81       	ldd	r24, Y+7	; 0x07
    280c:	98 85       	ldd	r25, Y+8	; 0x08
    280e:	9c 83       	std	Y+4, r25	; 0x04
    2810:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2812:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2814:	eb 81       	ldd	r30, Y+3	; 0x03
    2816:	fc 81       	ldd	r31, Y+4	; 0x04
    2818:	82 8d       	ldd	r24, Z+26	; 0x1a
    281a:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    281c:	eb 81       	ldd	r30, Y+3	; 0x03
    281e:	fc 81       	ldd	r31, Y+4	; 0x04
    2820:	93 8d       	ldd	r25, Z+27	; 0x1b
    2822:	8a 81       	ldd	r24, Y+2	; 0x02
    2824:	89 17       	cp	r24, r25
    2826:	48 f5       	brcc	.+82     	; 0x287a <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2828:	eb 81       	ldd	r30, Y+3	; 0x03
    282a:	fc 81       	ldd	r31, Y+4	; 0x04
    282c:	86 8d       	ldd	r24, Z+30	; 0x1e
    282e:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2830:	8a 81       	ldd	r24, Y+2	; 0x02
    2832:	8f 5f       	subi	r24, 0xFF	; 255
    2834:	eb 81       	ldd	r30, Y+3	; 0x03
    2836:	fc 81       	ldd	r31, Y+4	; 0x04
    2838:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    283a:	89 81       	ldd	r24, Y+1	; 0x01
    283c:	8f 3f       	cpi	r24, 0xFF	; 255
    283e:	a9 f4       	brne	.+42     	; 0x286a <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2840:	eb 81       	ldd	r30, Y+3	; 0x03
    2842:	fc 81       	ldd	r31, Y+4	; 0x04
    2844:	81 89       	ldd	r24, Z+17	; 0x11
    2846:	88 23       	and	r24, r24
    2848:	a9 f0       	breq	.+42     	; 0x2874 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    284a:	8b 81       	ldd	r24, Y+3	; 0x03
    284c:	9c 81       	ldd	r25, Y+4	; 0x04
    284e:	41 96       	adiw	r24, 0x11	; 17
    2850:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    2854:	88 23       	and	r24, r24
    2856:	71 f0       	breq	.+28     	; 0x2874 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2858:	89 85       	ldd	r24, Y+9	; 0x09
    285a:	9a 85       	ldd	r25, Y+10	; 0x0a
    285c:	00 97       	sbiw	r24, 0x00	; 0
    285e:	51 f0       	breq	.+20     	; 0x2874 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2860:	e9 85       	ldd	r30, Y+9	; 0x09
    2862:	fa 85       	ldd	r31, Y+10	; 0x0a
    2864:	81 e0       	ldi	r24, 0x01	; 1
    2866:	80 83       	st	Z, r24
    2868:	05 c0       	rjmp	.+10     	; 0x2874 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    286a:	89 81       	ldd	r24, Y+1	; 0x01
    286c:	8f 5f       	subi	r24, 0xFF	; 255
    286e:	eb 81       	ldd	r30, Y+3	; 0x03
    2870:	fc 81       	ldd	r31, Y+4	; 0x04
    2872:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2874:	81 e0       	ldi	r24, 0x01	; 1
    2876:	8e 83       	std	Y+6, r24	; 0x06
    2878:	01 c0       	rjmp	.+2      	; 0x287c <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    287a:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    287c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    287e:	2a 96       	adiw	r28, 0x0a	; 10
    2880:	0f b6       	in	r0, 0x3f	; 63
    2882:	f8 94       	cli
    2884:	de bf       	out	0x3e, r29	; 62
    2886:	0f be       	out	0x3f, r0	; 63
    2888:	cd bf       	out	0x3d, r28	; 61
    288a:	cf 91       	pop	r28
    288c:	df 91       	pop	r29
    288e:	08 95       	ret

00002890 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2890:	df 93       	push	r29
    2892:	cf 93       	push	r28
    2894:	cd b7       	in	r28, 0x3d	; 61
    2896:	de b7       	in	r29, 0x3e	; 62
    2898:	2e 97       	sbiw	r28, 0x0e	; 14
    289a:	0f b6       	in	r0, 0x3f	; 63
    289c:	f8 94       	cli
    289e:	de bf       	out	0x3e, r29	; 62
    28a0:	0f be       	out	0x3f, r0	; 63
    28a2:	cd bf       	out	0x3d, r28	; 61
    28a4:	99 87       	std	Y+9, r25	; 0x09
    28a6:	88 87       	std	Y+8, r24	; 0x08
    28a8:	7b 87       	std	Y+11, r23	; 0x0b
    28aa:	6a 87       	std	Y+10, r22	; 0x0a
    28ac:	5d 87       	std	Y+13, r21	; 0x0d
    28ae:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    28b0:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    28b2:	88 85       	ldd	r24, Y+8	; 0x08
    28b4:	99 85       	ldd	r25, Y+9	; 0x09
    28b6:	9b 83       	std	Y+3, r25	; 0x03
    28b8:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    28ba:	0f b6       	in	r0, 0x3f	; 63
    28bc:	f8 94       	cli
    28be:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    28c0:	ea 81       	ldd	r30, Y+2	; 0x02
    28c2:	fb 81       	ldd	r31, Y+3	; 0x03
    28c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    28c6:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    28c8:	89 81       	ldd	r24, Y+1	; 0x01
    28ca:	88 23       	and	r24, r24
    28cc:	f9 f0       	breq	.+62     	; 0x290c <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    28ce:	8a 81       	ldd	r24, Y+2	; 0x02
    28d0:	9b 81       	ldd	r25, Y+3	; 0x03
    28d2:	2a 85       	ldd	r18, Y+10	; 0x0a
    28d4:	3b 85       	ldd	r19, Y+11	; 0x0b
    28d6:	b9 01       	movw	r22, r18
    28d8:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    28dc:	89 81       	ldd	r24, Y+1	; 0x01
    28de:	81 50       	subi	r24, 0x01	; 1
    28e0:	ea 81       	ldd	r30, Y+2	; 0x02
    28e2:	fb 81       	ldd	r31, Y+3	; 0x03
    28e4:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28e6:	ea 81       	ldd	r30, Y+2	; 0x02
    28e8:	fb 81       	ldd	r31, Y+3	; 0x03
    28ea:	80 85       	ldd	r24, Z+8	; 0x08
    28ec:	88 23       	and	r24, r24
    28ee:	49 f0       	breq	.+18     	; 0x2902 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    28f0:	8a 81       	ldd	r24, Y+2	; 0x02
    28f2:	9b 81       	ldd	r25, Y+3	; 0x03
    28f4:	08 96       	adiw	r24, 0x08	; 8
    28f6:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    28fa:	88 23       	and	r24, r24
    28fc:	11 f0       	breq	.+4      	; 0x2902 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    28fe:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2902:	0f 90       	pop	r0
    2904:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2906:	81 e0       	ldi	r24, 0x01	; 1
    2908:	8e 87       	std	Y+14, r24	; 0x0e
    290a:	63 c0       	rjmp	.+198    	; 0x29d2 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    290c:	8c 85       	ldd	r24, Y+12	; 0x0c
    290e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2910:	00 97       	sbiw	r24, 0x00	; 0
    2912:	21 f4       	brne	.+8      	; 0x291c <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2914:	0f 90       	pop	r0
    2916:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2918:	1e 86       	std	Y+14, r1	; 0x0e
    291a:	5b c0       	rjmp	.+182    	; 0x29d2 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    291c:	8c 81       	ldd	r24, Y+4	; 0x04
    291e:	88 23       	and	r24, r24
    2920:	31 f4       	brne	.+12     	; 0x292e <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2922:	ce 01       	movw	r24, r28
    2924:	05 96       	adiw	r24, 0x05	; 5
    2926:	0e 94 07 1f 	call	0x3e0e	; 0x3e0e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    292a:	81 e0       	ldi	r24, 0x01	; 1
    292c:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    292e:	0f 90       	pop	r0
    2930:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2932:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2936:	0f b6       	in	r0, 0x3f	; 63
    2938:	f8 94       	cli
    293a:	0f 92       	push	r0
    293c:	ea 81       	ldd	r30, Y+2	; 0x02
    293e:	fb 81       	ldd	r31, Y+3	; 0x03
    2940:	85 8d       	ldd	r24, Z+29	; 0x1d
    2942:	8f 3f       	cpi	r24, 0xFF	; 255
    2944:	19 f4       	brne	.+6      	; 0x294c <xQueueReceive+0xbc>
    2946:	ea 81       	ldd	r30, Y+2	; 0x02
    2948:	fb 81       	ldd	r31, Y+3	; 0x03
    294a:	15 8e       	std	Z+29, r1	; 0x1d
    294c:	ea 81       	ldd	r30, Y+2	; 0x02
    294e:	fb 81       	ldd	r31, Y+3	; 0x03
    2950:	86 8d       	ldd	r24, Z+30	; 0x1e
    2952:	8f 3f       	cpi	r24, 0xFF	; 255
    2954:	19 f4       	brne	.+6      	; 0x295c <xQueueReceive+0xcc>
    2956:	ea 81       	ldd	r30, Y+2	; 0x02
    2958:	fb 81       	ldd	r31, Y+3	; 0x03
    295a:	16 8e       	std	Z+30, r1	; 0x1e
    295c:	0f 90       	pop	r0
    295e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2960:	ce 01       	movw	r24, r28
    2962:	05 96       	adiw	r24, 0x05	; 5
    2964:	9e 01       	movw	r18, r28
    2966:	24 5f       	subi	r18, 0xF4	; 244
    2968:	3f 4f       	sbci	r19, 0xFF	; 255
    296a:	b9 01       	movw	r22, r18
    296c:	0e 94 20 1f 	call	0x3e40	; 0x3e40 <xTaskCheckForTimeOut>
    2970:	88 23       	and	r24, r24
    2972:	09 f5       	brne	.+66     	; 0x29b6 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2974:	8a 81       	ldd	r24, Y+2	; 0x02
    2976:	9b 81       	ldd	r25, Y+3	; 0x03
    2978:	0e 94 85 18 	call	0x310a	; 0x310a <prvIsQueueEmpty>
    297c:	88 23       	and	r24, r24
    297e:	a1 f0       	breq	.+40     	; 0x29a8 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2980:	8a 81       	ldd	r24, Y+2	; 0x02
    2982:	9b 81       	ldd	r25, Y+3	; 0x03
    2984:	41 96       	adiw	r24, 0x11	; 17
    2986:	2c 85       	ldd	r18, Y+12	; 0x0c
    2988:	3d 85       	ldd	r19, Y+13	; 0x0d
    298a:	b9 01       	movw	r22, r18
    298c:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2990:	8a 81       	ldd	r24, Y+2	; 0x02
    2992:	9b 81       	ldd	r25, Y+3	; 0x03
    2994:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2998:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    299c:	88 23       	and	r24, r24
    299e:	09 f0       	breq	.+2      	; 0x29a2 <xQueueReceive+0x112>
    29a0:	8c cf       	rjmp	.-232    	; 0x28ba <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    29a2:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
    29a6:	89 cf       	rjmp	.-238    	; 0x28ba <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    29a8:	8a 81       	ldd	r24, Y+2	; 0x02
    29aa:	9b 81       	ldd	r25, Y+3	; 0x03
    29ac:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    29b0:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    29b4:	82 cf       	rjmp	.-252    	; 0x28ba <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    29b6:	8a 81       	ldd	r24, Y+2	; 0x02
    29b8:	9b 81       	ldd	r25, Y+3	; 0x03
    29ba:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    29be:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    29c2:	8a 81       	ldd	r24, Y+2	; 0x02
    29c4:	9b 81       	ldd	r25, Y+3	; 0x03
    29c6:	0e 94 85 18 	call	0x310a	; 0x310a <prvIsQueueEmpty>
    29ca:	88 23       	and	r24, r24
    29cc:	09 f4       	brne	.+2      	; 0x29d0 <xQueueReceive+0x140>
    29ce:	75 cf       	rjmp	.-278    	; 0x28ba <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    29d0:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    29d2:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    29d4:	2e 96       	adiw	r28, 0x0e	; 14
    29d6:	0f b6       	in	r0, 0x3f	; 63
    29d8:	f8 94       	cli
    29da:	de bf       	out	0x3e, r29	; 62
    29dc:	0f be       	out	0x3f, r0	; 63
    29de:	cd bf       	out	0x3d, r28	; 61
    29e0:	cf 91       	pop	r28
    29e2:	df 91       	pop	r29
    29e4:	08 95       	ret

000029e6 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    29e6:	df 93       	push	r29
    29e8:	cf 93       	push	r28
    29ea:	cd b7       	in	r28, 0x3d	; 61
    29ec:	de b7       	in	r29, 0x3e	; 62
    29ee:	2c 97       	sbiw	r28, 0x0c	; 12
    29f0:	0f b6       	in	r0, 0x3f	; 63
    29f2:	f8 94       	cli
    29f4:	de bf       	out	0x3e, r29	; 62
    29f6:	0f be       	out	0x3f, r0	; 63
    29f8:	cd bf       	out	0x3d, r28	; 61
    29fa:	99 87       	std	Y+9, r25	; 0x09
    29fc:	88 87       	std	Y+8, r24	; 0x08
    29fe:	7b 87       	std	Y+11, r23	; 0x0b
    2a00:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    2a02:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2a04:	88 85       	ldd	r24, Y+8	; 0x08
    2a06:	99 85       	ldd	r25, Y+9	; 0x09
    2a08:	9b 83       	std	Y+3, r25	; 0x03
    2a0a:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2a0c:	0f b6       	in	r0, 0x3f	; 63
    2a0e:	f8 94       	cli
    2a10:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2a12:	ea 81       	ldd	r30, Y+2	; 0x02
    2a14:	fb 81       	ldd	r31, Y+3	; 0x03
    2a16:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a18:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2a1a:	89 81       	ldd	r24, Y+1	; 0x01
    2a1c:	88 23       	and	r24, r24
    2a1e:	c1 f0       	breq	.+48     	; 0x2a50 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2a20:	89 81       	ldd	r24, Y+1	; 0x01
    2a22:	81 50       	subi	r24, 0x01	; 1
    2a24:	ea 81       	ldd	r30, Y+2	; 0x02
    2a26:	fb 81       	ldd	r31, Y+3	; 0x03
    2a28:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a2a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a2c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a2e:	80 85       	ldd	r24, Z+8	; 0x08
    2a30:	88 23       	and	r24, r24
    2a32:	49 f0       	breq	.+18     	; 0x2a46 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a34:	8a 81       	ldd	r24, Y+2	; 0x02
    2a36:	9b 81       	ldd	r25, Y+3	; 0x03
    2a38:	08 96       	adiw	r24, 0x08	; 8
    2a3a:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    2a3e:	88 23       	and	r24, r24
    2a40:	11 f0       	breq	.+4      	; 0x2a46 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2a42:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2a46:	0f 90       	pop	r0
    2a48:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2a4a:	81 e0       	ldi	r24, 0x01	; 1
    2a4c:	8c 87       	std	Y+12, r24	; 0x0c
    2a4e:	63 c0       	rjmp	.+198    	; 0x2b16 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2a50:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a52:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a54:	00 97       	sbiw	r24, 0x00	; 0
    2a56:	21 f4       	brne	.+8      	; 0x2a60 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    2a58:	0f 90       	pop	r0
    2a5a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2a5c:	1c 86       	std	Y+12, r1	; 0x0c
    2a5e:	5b c0       	rjmp	.+182    	; 0x2b16 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    2a60:	8c 81       	ldd	r24, Y+4	; 0x04
    2a62:	88 23       	and	r24, r24
    2a64:	31 f4       	brne	.+12     	; 0x2a72 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2a66:	ce 01       	movw	r24, r28
    2a68:	05 96       	adiw	r24, 0x05	; 5
    2a6a:	0e 94 07 1f 	call	0x3e0e	; 0x3e0e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2a6e:	81 e0       	ldi	r24, 0x01	; 1
    2a70:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2a72:	0f 90       	pop	r0
    2a74:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2a76:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2a7a:	0f b6       	in	r0, 0x3f	; 63
    2a7c:	f8 94       	cli
    2a7e:	0f 92       	push	r0
    2a80:	ea 81       	ldd	r30, Y+2	; 0x02
    2a82:	fb 81       	ldd	r31, Y+3	; 0x03
    2a84:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a86:	8f 3f       	cpi	r24, 0xFF	; 255
    2a88:	19 f4       	brne	.+6      	; 0x2a90 <xQueueSemaphoreTake+0xaa>
    2a8a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a8c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a8e:	15 8e       	std	Z+29, r1	; 0x1d
    2a90:	ea 81       	ldd	r30, Y+2	; 0x02
    2a92:	fb 81       	ldd	r31, Y+3	; 0x03
    2a94:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a96:	8f 3f       	cpi	r24, 0xFF	; 255
    2a98:	19 f4       	brne	.+6      	; 0x2aa0 <xQueueSemaphoreTake+0xba>
    2a9a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a9c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a9e:	16 8e       	std	Z+30, r1	; 0x1e
    2aa0:	0f 90       	pop	r0
    2aa2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2aa4:	ce 01       	movw	r24, r28
    2aa6:	05 96       	adiw	r24, 0x05	; 5
    2aa8:	9e 01       	movw	r18, r28
    2aaa:	26 5f       	subi	r18, 0xF6	; 246
    2aac:	3f 4f       	sbci	r19, 0xFF	; 255
    2aae:	b9 01       	movw	r22, r18
    2ab0:	0e 94 20 1f 	call	0x3e40	; 0x3e40 <xTaskCheckForTimeOut>
    2ab4:	88 23       	and	r24, r24
    2ab6:	09 f5       	brne	.+66     	; 0x2afa <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2ab8:	8a 81       	ldd	r24, Y+2	; 0x02
    2aba:	9b 81       	ldd	r25, Y+3	; 0x03
    2abc:	0e 94 85 18 	call	0x310a	; 0x310a <prvIsQueueEmpty>
    2ac0:	88 23       	and	r24, r24
    2ac2:	a1 f0       	breq	.+40     	; 0x2aec <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2ac4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac8:	41 96       	adiw	r24, 0x11	; 17
    2aca:	2a 85       	ldd	r18, Y+10	; 0x0a
    2acc:	3b 85       	ldd	r19, Y+11	; 0x0b
    2ace:	b9 01       	movw	r22, r18
    2ad0:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2ad4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ad8:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2adc:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    2ae0:	88 23       	and	r24, r24
    2ae2:	09 f0       	breq	.+2      	; 0x2ae6 <xQueueSemaphoreTake+0x100>
    2ae4:	93 cf       	rjmp	.-218    	; 0x2a0c <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    2ae6:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
    2aea:	90 cf       	rjmp	.-224    	; 0x2a0c <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2aec:	8a 81       	ldd	r24, Y+2	; 0x02
    2aee:	9b 81       	ldd	r25, Y+3	; 0x03
    2af0:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2af4:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    2af8:	89 cf       	rjmp	.-238    	; 0x2a0c <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2afa:	8a 81       	ldd	r24, Y+2	; 0x02
    2afc:	9b 81       	ldd	r25, Y+3	; 0x03
    2afe:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2b02:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b06:	8a 81       	ldd	r24, Y+2	; 0x02
    2b08:	9b 81       	ldd	r25, Y+3	; 0x03
    2b0a:	0e 94 85 18 	call	0x310a	; 0x310a <prvIsQueueEmpty>
    2b0e:	88 23       	and	r24, r24
    2b10:	09 f4       	brne	.+2      	; 0x2b14 <xQueueSemaphoreTake+0x12e>
    2b12:	7c cf       	rjmp	.-264    	; 0x2a0c <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2b14:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2b16:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2b18:	2c 96       	adiw	r28, 0x0c	; 12
    2b1a:	0f b6       	in	r0, 0x3f	; 63
    2b1c:	f8 94       	cli
    2b1e:	de bf       	out	0x3e, r29	; 62
    2b20:	0f be       	out	0x3f, r0	; 63
    2b22:	cd bf       	out	0x3d, r28	; 61
    2b24:	cf 91       	pop	r28
    2b26:	df 91       	pop	r29
    2b28:	08 95       	ret

00002b2a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2b2a:	df 93       	push	r29
    2b2c:	cf 93       	push	r28
    2b2e:	cd b7       	in	r28, 0x3d	; 61
    2b30:	de b7       	in	r29, 0x3e	; 62
    2b32:	60 97       	sbiw	r28, 0x10	; 16
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	de bf       	out	0x3e, r29	; 62
    2b3a:	0f be       	out	0x3f, r0	; 63
    2b3c:	cd bf       	out	0x3d, r28	; 61
    2b3e:	9b 87       	std	Y+11, r25	; 0x0b
    2b40:	8a 87       	std	Y+10, r24	; 0x0a
    2b42:	7d 87       	std	Y+13, r23	; 0x0d
    2b44:	6c 87       	std	Y+12, r22	; 0x0c
    2b46:	5f 87       	std	Y+15, r21	; 0x0f
    2b48:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    2b4a:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2b4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b50:	9b 83       	std	Y+3, r25	; 0x03
    2b52:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2b54:	0f b6       	in	r0, 0x3f	; 63
    2b56:	f8 94       	cli
    2b58:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2b5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b60:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b62:	89 81       	ldd	r24, Y+1	; 0x01
    2b64:	88 23       	and	r24, r24
    2b66:	31 f1       	breq	.+76     	; 0x2bb4 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2b68:	ea 81       	ldd	r30, Y+2	; 0x02
    2b6a:	fb 81       	ldd	r31, Y+3	; 0x03
    2b6c:	86 81       	ldd	r24, Z+6	; 0x06
    2b6e:	97 81       	ldd	r25, Z+7	; 0x07
    2b70:	9d 83       	std	Y+5, r25	; 0x05
    2b72:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2b74:	8a 81       	ldd	r24, Y+2	; 0x02
    2b76:	9b 81       	ldd	r25, Y+3	; 0x03
    2b78:	2c 85       	ldd	r18, Y+12	; 0x0c
    2b7a:	3d 85       	ldd	r19, Y+13	; 0x0d
    2b7c:	b9 01       	movw	r22, r18
    2b7e:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2b82:	ea 81       	ldd	r30, Y+2	; 0x02
    2b84:	fb 81       	ldd	r31, Y+3	; 0x03
    2b86:	8c 81       	ldd	r24, Y+4	; 0x04
    2b88:	9d 81       	ldd	r25, Y+5	; 0x05
    2b8a:	97 83       	std	Z+7, r25	; 0x07
    2b8c:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b8e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b90:	fb 81       	ldd	r31, Y+3	; 0x03
    2b92:	81 89       	ldd	r24, Z+17	; 0x11
    2b94:	88 23       	and	r24, r24
    2b96:	49 f0       	breq	.+18     	; 0x2baa <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b98:	8a 81       	ldd	r24, Y+2	; 0x02
    2b9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b9c:	41 96       	adiw	r24, 0x11	; 17
    2b9e:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    2ba2:	88 23       	and	r24, r24
    2ba4:	11 f0       	breq	.+4      	; 0x2baa <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    2ba6:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2baa:	0f 90       	pop	r0
    2bac:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2bae:	81 e0       	ldi	r24, 0x01	; 1
    2bb0:	88 8b       	std	Y+16, r24	; 0x10
    2bb2:	63 c0       	rjmp	.+198    	; 0x2c7a <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2bb4:	8e 85       	ldd	r24, Y+14	; 0x0e
    2bb6:	9f 85       	ldd	r25, Y+15	; 0x0f
    2bb8:	00 97       	sbiw	r24, 0x00	; 0
    2bba:	21 f4       	brne	.+8      	; 0x2bc4 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2bbc:	0f 90       	pop	r0
    2bbe:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2bc0:	18 8a       	std	Y+16, r1	; 0x10
    2bc2:	5b c0       	rjmp	.+182    	; 0x2c7a <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    2bc4:	8e 81       	ldd	r24, Y+6	; 0x06
    2bc6:	88 23       	and	r24, r24
    2bc8:	31 f4       	brne	.+12     	; 0x2bd6 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2bca:	ce 01       	movw	r24, r28
    2bcc:	07 96       	adiw	r24, 0x07	; 7
    2bce:	0e 94 07 1f 	call	0x3e0e	; 0x3e0e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2bd2:	81 e0       	ldi	r24, 0x01	; 1
    2bd4:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2bd6:	0f 90       	pop	r0
    2bd8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2bda:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2bde:	0f b6       	in	r0, 0x3f	; 63
    2be0:	f8 94       	cli
    2be2:	0f 92       	push	r0
    2be4:	ea 81       	ldd	r30, Y+2	; 0x02
    2be6:	fb 81       	ldd	r31, Y+3	; 0x03
    2be8:	85 8d       	ldd	r24, Z+29	; 0x1d
    2bea:	8f 3f       	cpi	r24, 0xFF	; 255
    2bec:	19 f4       	brne	.+6      	; 0x2bf4 <xQueuePeek+0xca>
    2bee:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf0:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf2:	15 8e       	std	Z+29, r1	; 0x1d
    2bf4:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf6:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf8:	86 8d       	ldd	r24, Z+30	; 0x1e
    2bfa:	8f 3f       	cpi	r24, 0xFF	; 255
    2bfc:	19 f4       	brne	.+6      	; 0x2c04 <xQueuePeek+0xda>
    2bfe:	ea 81       	ldd	r30, Y+2	; 0x02
    2c00:	fb 81       	ldd	r31, Y+3	; 0x03
    2c02:	16 8e       	std	Z+30, r1	; 0x1e
    2c04:	0f 90       	pop	r0
    2c06:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2c08:	ce 01       	movw	r24, r28
    2c0a:	07 96       	adiw	r24, 0x07	; 7
    2c0c:	9e 01       	movw	r18, r28
    2c0e:	22 5f       	subi	r18, 0xF2	; 242
    2c10:	3f 4f       	sbci	r19, 0xFF	; 255
    2c12:	b9 01       	movw	r22, r18
    2c14:	0e 94 20 1f 	call	0x3e40	; 0x3e40 <xTaskCheckForTimeOut>
    2c18:	88 23       	and	r24, r24
    2c1a:	09 f5       	brne	.+66     	; 0x2c5e <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c20:	0e 94 85 18 	call	0x310a	; 0x310a <prvIsQueueEmpty>
    2c24:	88 23       	and	r24, r24
    2c26:	a1 f0       	breq	.+40     	; 0x2c50 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2c28:	8a 81       	ldd	r24, Y+2	; 0x02
    2c2a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c2c:	41 96       	adiw	r24, 0x11	; 17
    2c2e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2c30:	3f 85       	ldd	r19, Y+15	; 0x0f
    2c32:	b9 01       	movw	r22, r18
    2c34:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2c38:	8a 81       	ldd	r24, Y+2	; 0x02
    2c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c3c:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2c40:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    2c44:	88 23       	and	r24, r24
    2c46:	09 f0       	breq	.+2      	; 0x2c4a <xQueuePeek+0x120>
    2c48:	85 cf       	rjmp	.-246    	; 0x2b54 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2c4a:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
    2c4e:	82 cf       	rjmp	.-252    	; 0x2b54 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2c50:	8a 81       	ldd	r24, Y+2	; 0x02
    2c52:	9b 81       	ldd	r25, Y+3	; 0x03
    2c54:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2c58:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    2c5c:	7b cf       	rjmp	.-266    	; 0x2b54 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2c5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c60:	9b 81       	ldd	r25, Y+3	; 0x03
    2c62:	0e 94 32 18 	call	0x3064	; 0x3064 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2c66:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c6c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c6e:	0e 94 85 18 	call	0x310a	; 0x310a <prvIsQueueEmpty>
    2c72:	88 23       	and	r24, r24
    2c74:	09 f4       	brne	.+2      	; 0x2c78 <xQueuePeek+0x14e>
    2c76:	6e cf       	rjmp	.-292    	; 0x2b54 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2c78:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2c7a:	88 89       	ldd	r24, Y+16	; 0x10
}
    2c7c:	60 96       	adiw	r28, 0x10	; 16
    2c7e:	0f b6       	in	r0, 0x3f	; 63
    2c80:	f8 94       	cli
    2c82:	de bf       	out	0x3e, r29	; 62
    2c84:	0f be       	out	0x3f, r0	; 63
    2c86:	cd bf       	out	0x3d, r28	; 61
    2c88:	cf 91       	pop	r28
    2c8a:	df 91       	pop	r29
    2c8c:	08 95       	ret

00002c8e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2c8e:	df 93       	push	r29
    2c90:	cf 93       	push	r28
    2c92:	cd b7       	in	r28, 0x3d	; 61
    2c94:	de b7       	in	r29, 0x3e	; 62
    2c96:	2c 97       	sbiw	r28, 0x0c	; 12
    2c98:	0f b6       	in	r0, 0x3f	; 63
    2c9a:	f8 94       	cli
    2c9c:	de bf       	out	0x3e, r29	; 62
    2c9e:	0f be       	out	0x3f, r0	; 63
    2ca0:	cd bf       	out	0x3d, r28	; 61
    2ca2:	98 87       	std	Y+8, r25	; 0x08
    2ca4:	8f 83       	std	Y+7, r24	; 0x07
    2ca6:	7a 87       	std	Y+10, r23	; 0x0a
    2ca8:	69 87       	std	Y+9, r22	; 0x09
    2caa:	5c 87       	std	Y+12, r21	; 0x0c
    2cac:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2cae:	8f 81       	ldd	r24, Y+7	; 0x07
    2cb0:	98 85       	ldd	r25, Y+8	; 0x08
    2cb2:	9c 83       	std	Y+4, r25	; 0x04
    2cb4:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2cb6:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2cb8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cba:	fc 81       	ldd	r31, Y+4	; 0x04
    2cbc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cbe:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cc2:	88 23       	and	r24, r24
    2cc4:	81 f1       	breq	.+96     	; 0x2d26 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    2cc6:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc8:	fc 81       	ldd	r31, Y+4	; 0x04
    2cca:	85 8d       	ldd	r24, Z+29	; 0x1d
    2ccc:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2cce:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd2:	29 85       	ldd	r18, Y+9	; 0x09
    2cd4:	3a 85       	ldd	r19, Y+10	; 0x0a
    2cd6:	b9 01       	movw	r22, r18
    2cd8:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    2cde:	81 50       	subi	r24, 0x01	; 1
    2ce0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce4:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    2ce6:	89 81       	ldd	r24, Y+1	; 0x01
    2ce8:	8f 3f       	cpi	r24, 0xFF	; 255
    2cea:	a9 f4       	brne	.+42     	; 0x2d16 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2cec:	eb 81       	ldd	r30, Y+3	; 0x03
    2cee:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf0:	80 85       	ldd	r24, Z+8	; 0x08
    2cf2:	88 23       	and	r24, r24
    2cf4:	a9 f0       	breq	.+42     	; 0x2d20 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cfa:	08 96       	adiw	r24, 0x08	; 8
    2cfc:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    2d00:	88 23       	and	r24, r24
    2d02:	71 f0       	breq	.+28     	; 0x2d20 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2d04:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d06:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d08:	00 97       	sbiw	r24, 0x00	; 0
    2d0a:	51 f0       	breq	.+20     	; 0x2d20 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2d0c:	eb 85       	ldd	r30, Y+11	; 0x0b
    2d0e:	fc 85       	ldd	r31, Y+12	; 0x0c
    2d10:	81 e0       	ldi	r24, 0x01	; 1
    2d12:	80 83       	st	Z, r24
    2d14:	05 c0       	rjmp	.+10     	; 0x2d20 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2d16:	89 81       	ldd	r24, Y+1	; 0x01
    2d18:	8f 5f       	subi	r24, 0xFF	; 255
    2d1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d1e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2d20:	81 e0       	ldi	r24, 0x01	; 1
    2d22:	8e 83       	std	Y+6, r24	; 0x06
    2d24:	01 c0       	rjmp	.+2      	; 0x2d28 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2d26:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d28:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2d2a:	2c 96       	adiw	r28, 0x0c	; 12
    2d2c:	0f b6       	in	r0, 0x3f	; 63
    2d2e:	f8 94       	cli
    2d30:	de bf       	out	0x3e, r29	; 62
    2d32:	0f be       	out	0x3f, r0	; 63
    2d34:	cd bf       	out	0x3d, r28	; 61
    2d36:	cf 91       	pop	r28
    2d38:	df 91       	pop	r29
    2d3a:	08 95       	ret

00002d3c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2d3c:	df 93       	push	r29
    2d3e:	cf 93       	push	r28
    2d40:	cd b7       	in	r28, 0x3d	; 61
    2d42:	de b7       	in	r29, 0x3e	; 62
    2d44:	2a 97       	sbiw	r28, 0x0a	; 10
    2d46:	0f b6       	in	r0, 0x3f	; 63
    2d48:	f8 94       	cli
    2d4a:	de bf       	out	0x3e, r29	; 62
    2d4c:	0f be       	out	0x3f, r0	; 63
    2d4e:	cd bf       	out	0x3d, r28	; 61
    2d50:	98 87       	std	Y+8, r25	; 0x08
    2d52:	8f 83       	std	Y+7, r24	; 0x07
    2d54:	7a 87       	std	Y+10, r23	; 0x0a
    2d56:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2d58:	8f 81       	ldd	r24, Y+7	; 0x07
    2d5a:	98 85       	ldd	r25, Y+8	; 0x08
    2d5c:	9a 83       	std	Y+2, r25	; 0x02
    2d5e:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d60:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d62:	e9 81       	ldd	r30, Y+1	; 0x01
    2d64:	fa 81       	ldd	r31, Y+2	; 0x02
    2d66:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d68:	88 23       	and	r24, r24
    2d6a:	b1 f0       	breq	.+44     	; 0x2d98 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d70:	86 81       	ldd	r24, Z+6	; 0x06
    2d72:	97 81       	ldd	r25, Z+7	; 0x07
    2d74:	9c 83       	std	Y+4, r25	; 0x04
    2d76:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2d78:	89 81       	ldd	r24, Y+1	; 0x01
    2d7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d7c:	29 85       	ldd	r18, Y+9	; 0x09
    2d7e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d80:	b9 01       	movw	r22, r18
    2d82:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2d86:	e9 81       	ldd	r30, Y+1	; 0x01
    2d88:	fa 81       	ldd	r31, Y+2	; 0x02
    2d8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8e:	97 83       	std	Z+7, r25	; 0x07
    2d90:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2d92:	81 e0       	ldi	r24, 0x01	; 1
    2d94:	8e 83       	std	Y+6, r24	; 0x06
    2d96:	01 c0       	rjmp	.+2      	; 0x2d9a <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2d98:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d9a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2d9c:	2a 96       	adiw	r28, 0x0a	; 10
    2d9e:	0f b6       	in	r0, 0x3f	; 63
    2da0:	f8 94       	cli
    2da2:	de bf       	out	0x3e, r29	; 62
    2da4:	0f be       	out	0x3f, r0	; 63
    2da6:	cd bf       	out	0x3d, r28	; 61
    2da8:	cf 91       	pop	r28
    2daa:	df 91       	pop	r29
    2dac:	08 95       	ret

00002dae <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2dae:	df 93       	push	r29
    2db0:	cf 93       	push	r28
    2db2:	00 d0       	rcall	.+0      	; 0x2db4 <uxQueueMessagesWaiting+0x6>
    2db4:	0f 92       	push	r0
    2db6:	cd b7       	in	r28, 0x3d	; 61
    2db8:	de b7       	in	r29, 0x3e	; 62
    2dba:	9b 83       	std	Y+3, r25	; 0x03
    2dbc:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2dbe:	0f b6       	in	r0, 0x3f	; 63
    2dc0:	f8 94       	cli
    2dc2:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2dc4:	ea 81       	ldd	r30, Y+2	; 0x02
    2dc6:	fb 81       	ldd	r31, Y+3	; 0x03
    2dc8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dca:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2dcc:	0f 90       	pop	r0
    2dce:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2dd0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2dd2:	0f 90       	pop	r0
    2dd4:	0f 90       	pop	r0
    2dd6:	0f 90       	pop	r0
    2dd8:	cf 91       	pop	r28
    2dda:	df 91       	pop	r29
    2ddc:	08 95       	ret

00002dde <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2dde:	df 93       	push	r29
    2de0:	cf 93       	push	r28
    2de2:	00 d0       	rcall	.+0      	; 0x2de4 <uxQueueSpacesAvailable+0x6>
    2de4:	00 d0       	rcall	.+0      	; 0x2de6 <uxQueueSpacesAvailable+0x8>
    2de6:	0f 92       	push	r0
    2de8:	cd b7       	in	r28, 0x3d	; 61
    2dea:	de b7       	in	r29, 0x3e	; 62
    2dec:	9d 83       	std	Y+5, r25	; 0x05
    2dee:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2df0:	8c 81       	ldd	r24, Y+4	; 0x04
    2df2:	9d 81       	ldd	r25, Y+5	; 0x05
    2df4:	9a 83       	std	Y+2, r25	; 0x02
    2df6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2df8:	0f b6       	in	r0, 0x3f	; 63
    2dfa:	f8 94       	cli
    2dfc:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2dfe:	e9 81       	ldd	r30, Y+1	; 0x01
    2e00:	fa 81       	ldd	r31, Y+2	; 0x02
    2e02:	93 8d       	ldd	r25, Z+27	; 0x1b
    2e04:	e9 81       	ldd	r30, Y+1	; 0x01
    2e06:	fa 81       	ldd	r31, Y+2	; 0x02
    2e08:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e0a:	29 2f       	mov	r18, r25
    2e0c:	28 1b       	sub	r18, r24
    2e0e:	82 2f       	mov	r24, r18
    2e10:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2e12:	0f 90       	pop	r0
    2e14:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2e16:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e18:	0f 90       	pop	r0
    2e1a:	0f 90       	pop	r0
    2e1c:	0f 90       	pop	r0
    2e1e:	0f 90       	pop	r0
    2e20:	0f 90       	pop	r0
    2e22:	cf 91       	pop	r28
    2e24:	df 91       	pop	r29
    2e26:	08 95       	ret

00002e28 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2e28:	df 93       	push	r29
    2e2a:	cf 93       	push	r28
    2e2c:	00 d0       	rcall	.+0      	; 0x2e2e <uxQueueMessagesWaitingFromISR+0x6>
    2e2e:	00 d0       	rcall	.+0      	; 0x2e30 <uxQueueMessagesWaitingFromISR+0x8>
    2e30:	0f 92       	push	r0
    2e32:	cd b7       	in	r28, 0x3d	; 61
    2e34:	de b7       	in	r29, 0x3e	; 62
    2e36:	9d 83       	std	Y+5, r25	; 0x05
    2e38:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2e3a:	8c 81       	ldd	r24, Y+4	; 0x04
    2e3c:	9d 81       	ldd	r25, Y+5	; 0x05
    2e3e:	9a 83       	std	Y+2, r25	; 0x02
    2e40:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2e42:	e9 81       	ldd	r30, Y+1	; 0x01
    2e44:	fa 81       	ldd	r31, Y+2	; 0x02
    2e46:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e48:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2e4a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e4c:	0f 90       	pop	r0
    2e4e:	0f 90       	pop	r0
    2e50:	0f 90       	pop	r0
    2e52:	0f 90       	pop	r0
    2e54:	0f 90       	pop	r0
    2e56:	cf 91       	pop	r28
    2e58:	df 91       	pop	r29
    2e5a:	08 95       	ret

00002e5c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2e5c:	df 93       	push	r29
    2e5e:	cf 93       	push	r28
    2e60:	00 d0       	rcall	.+0      	; 0x2e62 <vQueueDelete+0x6>
    2e62:	00 d0       	rcall	.+0      	; 0x2e64 <vQueueDelete+0x8>
    2e64:	cd b7       	in	r28, 0x3d	; 61
    2e66:	de b7       	in	r29, 0x3e	; 62
    2e68:	9c 83       	std	Y+4, r25	; 0x04
    2e6a:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e70:	9a 83       	std	Y+2, r25	; 0x02
    2e72:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2e74:	89 81       	ldd	r24, Y+1	; 0x01
    2e76:	9a 81       	ldd	r25, Y+2	; 0x02
    2e78:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2e7c:	0f 90       	pop	r0
    2e7e:	0f 90       	pop	r0
    2e80:	0f 90       	pop	r0
    2e82:	0f 90       	pop	r0
    2e84:	cf 91       	pop	r28
    2e86:	df 91       	pop	r29
    2e88:	08 95       	ret

00002e8a <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2e8a:	df 93       	push	r29
    2e8c:	cf 93       	push	r28
    2e8e:	cd b7       	in	r28, 0x3d	; 61
    2e90:	de b7       	in	r29, 0x3e	; 62
    2e92:	27 97       	sbiw	r28, 0x07	; 7
    2e94:	0f b6       	in	r0, 0x3f	; 63
    2e96:	f8 94       	cli
    2e98:	de bf       	out	0x3e, r29	; 62
    2e9a:	0f be       	out	0x3f, r0	; 63
    2e9c:	cd bf       	out	0x3d, r28	; 61
    2e9e:	9c 83       	std	Y+4, r25	; 0x04
    2ea0:	8b 83       	std	Y+3, r24	; 0x03
    2ea2:	7e 83       	std	Y+6, r23	; 0x06
    2ea4:	6d 83       	std	Y+5, r22	; 0x05
    2ea6:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    2ea8:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2eaa:	eb 81       	ldd	r30, Y+3	; 0x03
    2eac:	fc 81       	ldd	r31, Y+4	; 0x04
    2eae:	82 8d       	ldd	r24, Z+26	; 0x1a
    2eb0:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2eb2:	eb 81       	ldd	r30, Y+3	; 0x03
    2eb4:	fc 81       	ldd	r31, Y+4	; 0x04
    2eb6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2eb8:	88 23       	and	r24, r24
    2eba:	09 f4       	brne	.+2      	; 0x2ebe <prvCopyDataToQueue+0x34>
    2ebc:	7d c0       	rjmp	.+250    	; 0x2fb8 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2ebe:	8f 81       	ldd	r24, Y+7	; 0x07
    2ec0:	88 23       	and	r24, r24
    2ec2:	99 f5       	brne	.+102    	; 0x2f2a <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2ec4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ec6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ec8:	62 81       	ldd	r22, Z+2	; 0x02
    2eca:	73 81       	ldd	r23, Z+3	; 0x03
    2ecc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ece:	fc 81       	ldd	r31, Y+4	; 0x04
    2ed0:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ed2:	48 2f       	mov	r20, r24
    2ed4:	50 e0       	ldi	r21, 0x00	; 0
    2ed6:	2d 81       	ldd	r18, Y+5	; 0x05
    2ed8:	3e 81       	ldd	r19, Y+6	; 0x06
    2eda:	cb 01       	movw	r24, r22
    2edc:	b9 01       	movw	r22, r18
    2ede:	0e 94 0e 4d 	call	0x9a1c	; 0x9a1c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2ee2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ee4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ee6:	22 81       	ldd	r18, Z+2	; 0x02
    2ee8:	33 81       	ldd	r19, Z+3	; 0x03
    2eea:	eb 81       	ldd	r30, Y+3	; 0x03
    2eec:	fc 81       	ldd	r31, Y+4	; 0x04
    2eee:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ef0:	88 2f       	mov	r24, r24
    2ef2:	90 e0       	ldi	r25, 0x00	; 0
    2ef4:	82 0f       	add	r24, r18
    2ef6:	93 1f       	adc	r25, r19
    2ef8:	eb 81       	ldd	r30, Y+3	; 0x03
    2efa:	fc 81       	ldd	r31, Y+4	; 0x04
    2efc:	93 83       	std	Z+3, r25	; 0x03
    2efe:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2f00:	eb 81       	ldd	r30, Y+3	; 0x03
    2f02:	fc 81       	ldd	r31, Y+4	; 0x04
    2f04:	22 81       	ldd	r18, Z+2	; 0x02
    2f06:	33 81       	ldd	r19, Z+3	; 0x03
    2f08:	eb 81       	ldd	r30, Y+3	; 0x03
    2f0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f0c:	84 81       	ldd	r24, Z+4	; 0x04
    2f0e:	95 81       	ldd	r25, Z+5	; 0x05
    2f10:	28 17       	cp	r18, r24
    2f12:	39 07       	cpc	r19, r25
    2f14:	08 f4       	brcc	.+2      	; 0x2f18 <prvCopyDataToQueue+0x8e>
    2f16:	50 c0       	rjmp	.+160    	; 0x2fb8 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2f18:	eb 81       	ldd	r30, Y+3	; 0x03
    2f1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f1c:	80 81       	ld	r24, Z
    2f1e:	91 81       	ldd	r25, Z+1	; 0x01
    2f20:	eb 81       	ldd	r30, Y+3	; 0x03
    2f22:	fc 81       	ldd	r31, Y+4	; 0x04
    2f24:	93 83       	std	Z+3, r25	; 0x03
    2f26:	82 83       	std	Z+2, r24	; 0x02
    2f28:	47 c0       	rjmp	.+142    	; 0x2fb8 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2f2a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f2c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f2e:	66 81       	ldd	r22, Z+6	; 0x06
    2f30:	77 81       	ldd	r23, Z+7	; 0x07
    2f32:	eb 81       	ldd	r30, Y+3	; 0x03
    2f34:	fc 81       	ldd	r31, Y+4	; 0x04
    2f36:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f38:	48 2f       	mov	r20, r24
    2f3a:	50 e0       	ldi	r21, 0x00	; 0
    2f3c:	2d 81       	ldd	r18, Y+5	; 0x05
    2f3e:	3e 81       	ldd	r19, Y+6	; 0x06
    2f40:	cb 01       	movw	r24, r22
    2f42:	b9 01       	movw	r22, r18
    2f44:	0e 94 0e 4d 	call	0x9a1c	; 0x9a1c <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2f48:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f4c:	26 81       	ldd	r18, Z+6	; 0x06
    2f4e:	37 81       	ldd	r19, Z+7	; 0x07
    2f50:	eb 81       	ldd	r30, Y+3	; 0x03
    2f52:	fc 81       	ldd	r31, Y+4	; 0x04
    2f54:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f56:	88 2f       	mov	r24, r24
    2f58:	90 e0       	ldi	r25, 0x00	; 0
    2f5a:	90 95       	com	r25
    2f5c:	81 95       	neg	r24
    2f5e:	9f 4f       	sbci	r25, 0xFF	; 255
    2f60:	82 0f       	add	r24, r18
    2f62:	93 1f       	adc	r25, r19
    2f64:	eb 81       	ldd	r30, Y+3	; 0x03
    2f66:	fc 81       	ldd	r31, Y+4	; 0x04
    2f68:	97 83       	std	Z+7, r25	; 0x07
    2f6a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2f6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f70:	26 81       	ldd	r18, Z+6	; 0x06
    2f72:	37 81       	ldd	r19, Z+7	; 0x07
    2f74:	eb 81       	ldd	r30, Y+3	; 0x03
    2f76:	fc 81       	ldd	r31, Y+4	; 0x04
    2f78:	80 81       	ld	r24, Z
    2f7a:	91 81       	ldd	r25, Z+1	; 0x01
    2f7c:	28 17       	cp	r18, r24
    2f7e:	39 07       	cpc	r19, r25
    2f80:	90 f4       	brcc	.+36     	; 0x2fa6 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2f82:	eb 81       	ldd	r30, Y+3	; 0x03
    2f84:	fc 81       	ldd	r31, Y+4	; 0x04
    2f86:	24 81       	ldd	r18, Z+4	; 0x04
    2f88:	35 81       	ldd	r19, Z+5	; 0x05
    2f8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f90:	88 2f       	mov	r24, r24
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	90 95       	com	r25
    2f96:	81 95       	neg	r24
    2f98:	9f 4f       	sbci	r25, 0xFF	; 255
    2f9a:	82 0f       	add	r24, r18
    2f9c:	93 1f       	adc	r25, r19
    2f9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2fa0:	fc 81       	ldd	r31, Y+4	; 0x04
    2fa2:	97 83       	std	Z+7, r25	; 0x07
    2fa4:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2fa6:	8f 81       	ldd	r24, Y+7	; 0x07
    2fa8:	82 30       	cpi	r24, 0x02	; 2
    2faa:	31 f4       	brne	.+12     	; 0x2fb8 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2fac:	89 81       	ldd	r24, Y+1	; 0x01
    2fae:	88 23       	and	r24, r24
    2fb0:	19 f0       	breq	.+6      	; 0x2fb8 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2fb2:	89 81       	ldd	r24, Y+1	; 0x01
    2fb4:	81 50       	subi	r24, 0x01	; 1
    2fb6:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2fb8:	89 81       	ldd	r24, Y+1	; 0x01
    2fba:	8f 5f       	subi	r24, 0xFF	; 255
    2fbc:	eb 81       	ldd	r30, Y+3	; 0x03
    2fbe:	fc 81       	ldd	r31, Y+4	; 0x04
    2fc0:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2fc2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2fc4:	27 96       	adiw	r28, 0x07	; 7
    2fc6:	0f b6       	in	r0, 0x3f	; 63
    2fc8:	f8 94       	cli
    2fca:	de bf       	out	0x3e, r29	; 62
    2fcc:	0f be       	out	0x3f, r0	; 63
    2fce:	cd bf       	out	0x3d, r28	; 61
    2fd0:	cf 91       	pop	r28
    2fd2:	df 91       	pop	r29
    2fd4:	08 95       	ret

00002fd6 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2fd6:	df 93       	push	r29
    2fd8:	cf 93       	push	r28
    2fda:	00 d0       	rcall	.+0      	; 0x2fdc <prvCopyDataFromQueue+0x6>
    2fdc:	00 d0       	rcall	.+0      	; 0x2fde <prvCopyDataFromQueue+0x8>
    2fde:	cd b7       	in	r28, 0x3d	; 61
    2fe0:	de b7       	in	r29, 0x3e	; 62
    2fe2:	9a 83       	std	Y+2, r25	; 0x02
    2fe4:	89 83       	std	Y+1, r24	; 0x01
    2fe6:	7c 83       	std	Y+4, r23	; 0x04
    2fe8:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2fea:	e9 81       	ldd	r30, Y+1	; 0x01
    2fec:	fa 81       	ldd	r31, Y+2	; 0x02
    2fee:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ff0:	88 23       	and	r24, r24
    2ff2:	89 f1       	breq	.+98     	; 0x3056 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2ff4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff8:	26 81       	ldd	r18, Z+6	; 0x06
    2ffa:	37 81       	ldd	r19, Z+7	; 0x07
    2ffc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ffe:	fa 81       	ldd	r31, Y+2	; 0x02
    3000:	84 8d       	ldd	r24, Z+28	; 0x1c
    3002:	88 2f       	mov	r24, r24
    3004:	90 e0       	ldi	r25, 0x00	; 0
    3006:	82 0f       	add	r24, r18
    3008:	93 1f       	adc	r25, r19
    300a:	e9 81       	ldd	r30, Y+1	; 0x01
    300c:	fa 81       	ldd	r31, Y+2	; 0x02
    300e:	97 83       	std	Z+7, r25	; 0x07
    3010:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3012:	e9 81       	ldd	r30, Y+1	; 0x01
    3014:	fa 81       	ldd	r31, Y+2	; 0x02
    3016:	26 81       	ldd	r18, Z+6	; 0x06
    3018:	37 81       	ldd	r19, Z+7	; 0x07
    301a:	e9 81       	ldd	r30, Y+1	; 0x01
    301c:	fa 81       	ldd	r31, Y+2	; 0x02
    301e:	84 81       	ldd	r24, Z+4	; 0x04
    3020:	95 81       	ldd	r25, Z+5	; 0x05
    3022:	28 17       	cp	r18, r24
    3024:	39 07       	cpc	r19, r25
    3026:	40 f0       	brcs	.+16     	; 0x3038 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3028:	e9 81       	ldd	r30, Y+1	; 0x01
    302a:	fa 81       	ldd	r31, Y+2	; 0x02
    302c:	80 81       	ld	r24, Z
    302e:	91 81       	ldd	r25, Z+1	; 0x01
    3030:	e9 81       	ldd	r30, Y+1	; 0x01
    3032:	fa 81       	ldd	r31, Y+2	; 0x02
    3034:	97 83       	std	Z+7, r25	; 0x07
    3036:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3038:	e9 81       	ldd	r30, Y+1	; 0x01
    303a:	fa 81       	ldd	r31, Y+2	; 0x02
    303c:	46 81       	ldd	r20, Z+6	; 0x06
    303e:	57 81       	ldd	r21, Z+7	; 0x07
    3040:	e9 81       	ldd	r30, Y+1	; 0x01
    3042:	fa 81       	ldd	r31, Y+2	; 0x02
    3044:	84 8d       	ldd	r24, Z+28	; 0x1c
    3046:	28 2f       	mov	r18, r24
    3048:	30 e0       	ldi	r19, 0x00	; 0
    304a:	8b 81       	ldd	r24, Y+3	; 0x03
    304c:	9c 81       	ldd	r25, Y+4	; 0x04
    304e:	ba 01       	movw	r22, r20
    3050:	a9 01       	movw	r20, r18
    3052:	0e 94 0e 4d 	call	0x9a1c	; 0x9a1c <memcpy>
	}
}
    3056:	0f 90       	pop	r0
    3058:	0f 90       	pop	r0
    305a:	0f 90       	pop	r0
    305c:	0f 90       	pop	r0
    305e:	cf 91       	pop	r28
    3060:	df 91       	pop	r29
    3062:	08 95       	ret

00003064 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3064:	df 93       	push	r29
    3066:	cf 93       	push	r28
    3068:	00 d0       	rcall	.+0      	; 0x306a <prvUnlockQueue+0x6>
    306a:	00 d0       	rcall	.+0      	; 0x306c <prvUnlockQueue+0x8>
    306c:	cd b7       	in	r28, 0x3d	; 61
    306e:	de b7       	in	r29, 0x3e	; 62
    3070:	9c 83       	std	Y+4, r25	; 0x04
    3072:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3074:	0f b6       	in	r0, 0x3f	; 63
    3076:	f8 94       	cli
    3078:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    307a:	eb 81       	ldd	r30, Y+3	; 0x03
    307c:	fc 81       	ldd	r31, Y+4	; 0x04
    307e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3080:	8a 83       	std	Y+2, r24	; 0x02
    3082:	11 c0       	rjmp	.+34     	; 0x30a6 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3084:	eb 81       	ldd	r30, Y+3	; 0x03
    3086:	fc 81       	ldd	r31, Y+4	; 0x04
    3088:	81 89       	ldd	r24, Z+17	; 0x11
    308a:	88 23       	and	r24, r24
    308c:	79 f0       	breq	.+30     	; 0x30ac <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    308e:	8b 81       	ldd	r24, Y+3	; 0x03
    3090:	9c 81       	ldd	r25, Y+4	; 0x04
    3092:	41 96       	adiw	r24, 0x11	; 17
    3094:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    3098:	88 23       	and	r24, r24
    309a:	11 f0       	breq	.+4      	; 0x30a0 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    309c:	0e 94 83 1f 	call	0x3f06	; 0x3f06 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    30a0:	8a 81       	ldd	r24, Y+2	; 0x02
    30a2:	81 50       	subi	r24, 0x01	; 1
    30a4:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    30a6:	8a 81       	ldd	r24, Y+2	; 0x02
    30a8:	18 16       	cp	r1, r24
    30aa:	64 f3       	brlt	.-40     	; 0x3084 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    30ac:	eb 81       	ldd	r30, Y+3	; 0x03
    30ae:	fc 81       	ldd	r31, Y+4	; 0x04
    30b0:	8f ef       	ldi	r24, 0xFF	; 255
    30b2:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    30b4:	0f 90       	pop	r0
    30b6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    30b8:	0f b6       	in	r0, 0x3f	; 63
    30ba:	f8 94       	cli
    30bc:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    30be:	eb 81       	ldd	r30, Y+3	; 0x03
    30c0:	fc 81       	ldd	r31, Y+4	; 0x04
    30c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    30c4:	89 83       	std	Y+1, r24	; 0x01
    30c6:	11 c0       	rjmp	.+34     	; 0x30ea <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    30c8:	eb 81       	ldd	r30, Y+3	; 0x03
    30ca:	fc 81       	ldd	r31, Y+4	; 0x04
    30cc:	80 85       	ldd	r24, Z+8	; 0x08
    30ce:	88 23       	and	r24, r24
    30d0:	79 f0       	breq	.+30     	; 0x30f0 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    30d2:	8b 81       	ldd	r24, Y+3	; 0x03
    30d4:	9c 81       	ldd	r25, Y+4	; 0x04
    30d6:	08 96       	adiw	r24, 0x08	; 8
    30d8:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <xTaskRemoveFromEventList>
    30dc:	88 23       	and	r24, r24
    30de:	11 f0       	breq	.+4      	; 0x30e4 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    30e0:	0e 94 83 1f 	call	0x3f06	; 0x3f06 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    30e4:	89 81       	ldd	r24, Y+1	; 0x01
    30e6:	81 50       	subi	r24, 0x01	; 1
    30e8:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    30ea:	89 81       	ldd	r24, Y+1	; 0x01
    30ec:	18 16       	cp	r1, r24
    30ee:	64 f3       	brlt	.-40     	; 0x30c8 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    30f0:	eb 81       	ldd	r30, Y+3	; 0x03
    30f2:	fc 81       	ldd	r31, Y+4	; 0x04
    30f4:	8f ef       	ldi	r24, 0xFF	; 255
    30f6:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    30f8:	0f 90       	pop	r0
    30fa:	0f be       	out	0x3f, r0	; 63
}
    30fc:	0f 90       	pop	r0
    30fe:	0f 90       	pop	r0
    3100:	0f 90       	pop	r0
    3102:	0f 90       	pop	r0
    3104:	cf 91       	pop	r28
    3106:	df 91       	pop	r29
    3108:	08 95       	ret

0000310a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    310a:	df 93       	push	r29
    310c:	cf 93       	push	r28
    310e:	00 d0       	rcall	.+0      	; 0x3110 <prvIsQueueEmpty+0x6>
    3110:	0f 92       	push	r0
    3112:	cd b7       	in	r28, 0x3d	; 61
    3114:	de b7       	in	r29, 0x3e	; 62
    3116:	9b 83       	std	Y+3, r25	; 0x03
    3118:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    311a:	0f b6       	in	r0, 0x3f	; 63
    311c:	f8 94       	cli
    311e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3120:	ea 81       	ldd	r30, Y+2	; 0x02
    3122:	fb 81       	ldd	r31, Y+3	; 0x03
    3124:	82 8d       	ldd	r24, Z+26	; 0x1a
    3126:	88 23       	and	r24, r24
    3128:	19 f4       	brne	.+6      	; 0x3130 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    312a:	81 e0       	ldi	r24, 0x01	; 1
    312c:	89 83       	std	Y+1, r24	; 0x01
    312e:	01 c0       	rjmp	.+2      	; 0x3132 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    3130:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3132:	0f 90       	pop	r0
    3134:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3136:	89 81       	ldd	r24, Y+1	; 0x01
}
    3138:	0f 90       	pop	r0
    313a:	0f 90       	pop	r0
    313c:	0f 90       	pop	r0
    313e:	cf 91       	pop	r28
    3140:	df 91       	pop	r29
    3142:	08 95       	ret

00003144 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3144:	df 93       	push	r29
    3146:	cf 93       	push	r28
    3148:	00 d0       	rcall	.+0      	; 0x314a <xQueueIsQueueEmptyFromISR+0x6>
    314a:	00 d0       	rcall	.+0      	; 0x314c <xQueueIsQueueEmptyFromISR+0x8>
    314c:	0f 92       	push	r0
    314e:	cd b7       	in	r28, 0x3d	; 61
    3150:	de b7       	in	r29, 0x3e	; 62
    3152:	9d 83       	std	Y+5, r25	; 0x05
    3154:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3156:	8c 81       	ldd	r24, Y+4	; 0x04
    3158:	9d 81       	ldd	r25, Y+5	; 0x05
    315a:	9a 83       	std	Y+2, r25	; 0x02
    315c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    315e:	e9 81       	ldd	r30, Y+1	; 0x01
    3160:	fa 81       	ldd	r31, Y+2	; 0x02
    3162:	82 8d       	ldd	r24, Z+26	; 0x1a
    3164:	88 23       	and	r24, r24
    3166:	19 f4       	brne	.+6      	; 0x316e <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    3168:	81 e0       	ldi	r24, 0x01	; 1
    316a:	8b 83       	std	Y+3, r24	; 0x03
    316c:	01 c0       	rjmp	.+2      	; 0x3170 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    316e:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3170:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3172:	0f 90       	pop	r0
    3174:	0f 90       	pop	r0
    3176:	0f 90       	pop	r0
    3178:	0f 90       	pop	r0
    317a:	0f 90       	pop	r0
    317c:	cf 91       	pop	r28
    317e:	df 91       	pop	r29
    3180:	08 95       	ret

00003182 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3182:	df 93       	push	r29
    3184:	cf 93       	push	r28
    3186:	00 d0       	rcall	.+0      	; 0x3188 <prvIsQueueFull+0x6>
    3188:	0f 92       	push	r0
    318a:	cd b7       	in	r28, 0x3d	; 61
    318c:	de b7       	in	r29, 0x3e	; 62
    318e:	9b 83       	std	Y+3, r25	; 0x03
    3190:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3192:	0f b6       	in	r0, 0x3f	; 63
    3194:	f8 94       	cli
    3196:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3198:	ea 81       	ldd	r30, Y+2	; 0x02
    319a:	fb 81       	ldd	r31, Y+3	; 0x03
    319c:	92 8d       	ldd	r25, Z+26	; 0x1a
    319e:	ea 81       	ldd	r30, Y+2	; 0x02
    31a0:	fb 81       	ldd	r31, Y+3	; 0x03
    31a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    31a4:	98 17       	cp	r25, r24
    31a6:	19 f4       	brne	.+6      	; 0x31ae <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    31a8:	81 e0       	ldi	r24, 0x01	; 1
    31aa:	89 83       	std	Y+1, r24	; 0x01
    31ac:	01 c0       	rjmp	.+2      	; 0x31b0 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    31ae:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    31b0:	0f 90       	pop	r0
    31b2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    31b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    31b6:	0f 90       	pop	r0
    31b8:	0f 90       	pop	r0
    31ba:	0f 90       	pop	r0
    31bc:	cf 91       	pop	r28
    31be:	df 91       	pop	r29
    31c0:	08 95       	ret

000031c2 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    31c2:	df 93       	push	r29
    31c4:	cf 93       	push	r28
    31c6:	00 d0       	rcall	.+0      	; 0x31c8 <xQueueIsQueueFullFromISR+0x6>
    31c8:	00 d0       	rcall	.+0      	; 0x31ca <xQueueIsQueueFullFromISR+0x8>
    31ca:	0f 92       	push	r0
    31cc:	cd b7       	in	r28, 0x3d	; 61
    31ce:	de b7       	in	r29, 0x3e	; 62
    31d0:	9d 83       	std	Y+5, r25	; 0x05
    31d2:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    31d4:	8c 81       	ldd	r24, Y+4	; 0x04
    31d6:	9d 81       	ldd	r25, Y+5	; 0x05
    31d8:	9a 83       	std	Y+2, r25	; 0x02
    31da:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    31dc:	e9 81       	ldd	r30, Y+1	; 0x01
    31de:	fa 81       	ldd	r31, Y+2	; 0x02
    31e0:	92 8d       	ldd	r25, Z+26	; 0x1a
    31e2:	e9 81       	ldd	r30, Y+1	; 0x01
    31e4:	fa 81       	ldd	r31, Y+2	; 0x02
    31e6:	83 8d       	ldd	r24, Z+27	; 0x1b
    31e8:	98 17       	cp	r25, r24
    31ea:	19 f4       	brne	.+6      	; 0x31f2 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    31ec:	81 e0       	ldi	r24, 0x01	; 1
    31ee:	8b 83       	std	Y+3, r24	; 0x03
    31f0:	01 c0       	rjmp	.+2      	; 0x31f4 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    31f2:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    31f4:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    31f6:	0f 90       	pop	r0
    31f8:	0f 90       	pop	r0
    31fa:	0f 90       	pop	r0
    31fc:	0f 90       	pop	r0
    31fe:	0f 90       	pop	r0
    3200:	cf 91       	pop	r28
    3202:	df 91       	pop	r29
    3204:	08 95       	ret

00003206 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3206:	8f 92       	push	r8
    3208:	9f 92       	push	r9
    320a:	af 92       	push	r10
    320c:	bf 92       	push	r11
    320e:	cf 92       	push	r12
    3210:	df 92       	push	r13
    3212:	ef 92       	push	r14
    3214:	ff 92       	push	r15
    3216:	0f 93       	push	r16
    3218:	1f 93       	push	r17
    321a:	df 93       	push	r29
    321c:	cf 93       	push	r28
    321e:	cd b7       	in	r28, 0x3d	; 61
    3220:	de b7       	in	r29, 0x3e	; 62
    3222:	60 97       	sbiw	r28, 0x10	; 16
    3224:	0f b6       	in	r0, 0x3f	; 63
    3226:	f8 94       	cli
    3228:	de bf       	out	0x3e, r29	; 62
    322a:	0f be       	out	0x3f, r0	; 63
    322c:	cd bf       	out	0x3d, r28	; 61
    322e:	9f 83       	std	Y+7, r25	; 0x07
    3230:	8e 83       	std	Y+6, r24	; 0x06
    3232:	79 87       	std	Y+9, r23	; 0x09
    3234:	68 87       	std	Y+8, r22	; 0x08
    3236:	5b 87       	std	Y+11, r21	; 0x0b
    3238:	4a 87       	std	Y+10, r20	; 0x0a
    323a:	3d 87       	std	Y+13, r19	; 0x0d
    323c:	2c 87       	std	Y+12, r18	; 0x0c
    323e:	0e 87       	std	Y+14, r16	; 0x0e
    3240:	f8 8a       	std	Y+16, r15	; 0x10
    3242:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3244:	8a 85       	ldd	r24, Y+10	; 0x0a
    3246:	9b 85       	ldd	r25, Y+11	; 0x0b
    3248:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <pvPortMalloc>
    324c:	9a 83       	std	Y+2, r25	; 0x02
    324e:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3250:	89 81       	ldd	r24, Y+1	; 0x01
    3252:	9a 81       	ldd	r25, Y+2	; 0x02
    3254:	00 97       	sbiw	r24, 0x00	; 0
    3256:	b1 f0       	breq	.+44     	; 0x3284 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3258:	86 e2       	ldi	r24, 0x26	; 38
    325a:	90 e0       	ldi	r25, 0x00	; 0
    325c:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <pvPortMalloc>
    3260:	9d 83       	std	Y+5, r25	; 0x05
    3262:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3264:	8c 81       	ldd	r24, Y+4	; 0x04
    3266:	9d 81       	ldd	r25, Y+5	; 0x05
    3268:	00 97       	sbiw	r24, 0x00	; 0
    326a:	39 f0       	breq	.+14     	; 0x327a <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    326c:	ec 81       	ldd	r30, Y+4	; 0x04
    326e:	fd 81       	ldd	r31, Y+5	; 0x05
    3270:	89 81       	ldd	r24, Y+1	; 0x01
    3272:	9a 81       	ldd	r25, Y+2	; 0x02
    3274:	90 8f       	std	Z+24, r25	; 0x18
    3276:	87 8b       	std	Z+23, r24	; 0x17
    3278:	07 c0       	rjmp	.+14     	; 0x3288 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    327a:	89 81       	ldd	r24, Y+1	; 0x01
    327c:	9a 81       	ldd	r25, Y+2	; 0x02
    327e:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <vPortFree>
    3282:	02 c0       	rjmp	.+4      	; 0x3288 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3284:	1d 82       	std	Y+5, r1	; 0x05
    3286:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3288:	8c 81       	ldd	r24, Y+4	; 0x04
    328a:	9d 81       	ldd	r25, Y+5	; 0x05
    328c:	00 97       	sbiw	r24, 0x00	; 0
    328e:	e9 f0       	breq	.+58     	; 0x32ca <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3290:	8a 85       	ldd	r24, Y+10	; 0x0a
    3292:	9b 85       	ldd	r25, Y+11	; 0x0b
    3294:	9c 01       	movw	r18, r24
    3296:	40 e0       	ldi	r20, 0x00	; 0
    3298:	50 e0       	ldi	r21, 0x00	; 0
    329a:	8e 81       	ldd	r24, Y+6	; 0x06
    329c:	9f 81       	ldd	r25, Y+7	; 0x07
    329e:	68 85       	ldd	r22, Y+8	; 0x08
    32a0:	79 85       	ldd	r23, Y+9	; 0x09
    32a2:	ec 85       	ldd	r30, Y+12	; 0x0c
    32a4:	fd 85       	ldd	r31, Y+13	; 0x0d
    32a6:	af 85       	ldd	r26, Y+15	; 0x0f
    32a8:	b8 89       	ldd	r27, Y+16	; 0x10
    32aa:	ac 80       	ldd	r10, Y+4	; 0x04
    32ac:	bd 80       	ldd	r11, Y+5	; 0x05
    32ae:	8f 01       	movw	r16, r30
    32b0:	ee 84       	ldd	r14, Y+14	; 0x0e
    32b2:	6d 01       	movw	r12, r26
    32b4:	88 24       	eor	r8, r8
    32b6:	99 24       	eor	r9, r9
    32b8:	0e 94 7b 19 	call	0x32f6	; 0x32f6 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    32bc:	8c 81       	ldd	r24, Y+4	; 0x04
    32be:	9d 81       	ldd	r25, Y+5	; 0x05
    32c0:	0e 94 37 1a 	call	0x346e	; 0x346e <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    32c4:	81 e0       	ldi	r24, 0x01	; 1
    32c6:	8b 83       	std	Y+3, r24	; 0x03
    32c8:	02 c0       	rjmp	.+4      	; 0x32ce <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    32ca:	8f ef       	ldi	r24, 0xFF	; 255
    32cc:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    32ce:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    32d0:	60 96       	adiw	r28, 0x10	; 16
    32d2:	0f b6       	in	r0, 0x3f	; 63
    32d4:	f8 94       	cli
    32d6:	de bf       	out	0x3e, r29	; 62
    32d8:	0f be       	out	0x3f, r0	; 63
    32da:	cd bf       	out	0x3d, r28	; 61
    32dc:	cf 91       	pop	r28
    32de:	df 91       	pop	r29
    32e0:	1f 91       	pop	r17
    32e2:	0f 91       	pop	r16
    32e4:	ff 90       	pop	r15
    32e6:	ef 90       	pop	r14
    32e8:	df 90       	pop	r13
    32ea:	cf 90       	pop	r12
    32ec:	bf 90       	pop	r11
    32ee:	af 90       	pop	r10
    32f0:	9f 90       	pop	r9
    32f2:	8f 90       	pop	r8
    32f4:	08 95       	ret

000032f6 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    32f6:	8f 92       	push	r8
    32f8:	9f 92       	push	r9
    32fa:	af 92       	push	r10
    32fc:	bf 92       	push	r11
    32fe:	cf 92       	push	r12
    3300:	df 92       	push	r13
    3302:	ef 92       	push	r14
    3304:	0f 93       	push	r16
    3306:	1f 93       	push	r17
    3308:	df 93       	push	r29
    330a:	cf 93       	push	r28
    330c:	cd b7       	in	r28, 0x3d	; 61
    330e:	de b7       	in	r29, 0x3e	; 62
    3310:	64 97       	sbiw	r28, 0x14	; 20
    3312:	0f b6       	in	r0, 0x3f	; 63
    3314:	f8 94       	cli
    3316:	de bf       	out	0x3e, r29	; 62
    3318:	0f be       	out	0x3f, r0	; 63
    331a:	cd bf       	out	0x3d, r28	; 61
    331c:	9d 83       	std	Y+5, r25	; 0x05
    331e:	8c 83       	std	Y+4, r24	; 0x04
    3320:	7f 83       	std	Y+7, r23	; 0x07
    3322:	6e 83       	std	Y+6, r22	; 0x06
    3324:	28 87       	std	Y+8, r18	; 0x08
    3326:	39 87       	std	Y+9, r19	; 0x09
    3328:	4a 87       	std	Y+10, r20	; 0x0a
    332a:	5b 87       	std	Y+11, r21	; 0x0b
    332c:	1d 87       	std	Y+13, r17	; 0x0d
    332e:	0c 87       	std	Y+12, r16	; 0x0c
    3330:	ee 86       	std	Y+14, r14	; 0x0e
    3332:	d8 8a       	std	Y+16, r13	; 0x10
    3334:	cf 86       	std	Y+15, r12	; 0x0f
    3336:	ba 8a       	std	Y+18, r11	; 0x12
    3338:	a9 8a       	std	Y+17, r10	; 0x11
    333a:	9c 8a       	std	Y+20, r9	; 0x14
    333c:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    333e:	e9 89       	ldd	r30, Y+17	; 0x11
    3340:	fa 89       	ldd	r31, Y+18	; 0x12
    3342:	27 89       	ldd	r18, Z+23	; 0x17
    3344:	30 8d       	ldd	r19, Z+24	; 0x18
    3346:	88 85       	ldd	r24, Y+8	; 0x08
    3348:	99 85       	ldd	r25, Y+9	; 0x09
    334a:	01 97       	sbiw	r24, 0x01	; 1
    334c:	82 0f       	add	r24, r18
    334e:	93 1f       	adc	r25, r19
    3350:	9b 83       	std	Y+3, r25	; 0x03
    3352:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3354:	8e 81       	ldd	r24, Y+6	; 0x06
    3356:	9f 81       	ldd	r25, Y+7	; 0x07
    3358:	00 97       	sbiw	r24, 0x00	; 0
    335a:	51 f1       	breq	.+84     	; 0x33b0 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    335c:	19 82       	std	Y+1, r1	; 0x01
    335e:	21 c0       	rjmp	.+66     	; 0x33a2 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3360:	89 81       	ldd	r24, Y+1	; 0x01
    3362:	48 2f       	mov	r20, r24
    3364:	50 e0       	ldi	r21, 0x00	; 0
    3366:	89 81       	ldd	r24, Y+1	; 0x01
    3368:	28 2f       	mov	r18, r24
    336a:	30 e0       	ldi	r19, 0x00	; 0
    336c:	8e 81       	ldd	r24, Y+6	; 0x06
    336e:	9f 81       	ldd	r25, Y+7	; 0x07
    3370:	fc 01       	movw	r30, r24
    3372:	e2 0f       	add	r30, r18
    3374:	f3 1f       	adc	r31, r19
    3376:	20 81       	ld	r18, Z
    3378:	89 89       	ldd	r24, Y+17	; 0x11
    337a:	9a 89       	ldd	r25, Y+18	; 0x12
    337c:	84 0f       	add	r24, r20
    337e:	95 1f       	adc	r25, r21
    3380:	fc 01       	movw	r30, r24
    3382:	79 96       	adiw	r30, 0x19	; 25
    3384:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3386:	89 81       	ldd	r24, Y+1	; 0x01
    3388:	28 2f       	mov	r18, r24
    338a:	30 e0       	ldi	r19, 0x00	; 0
    338c:	8e 81       	ldd	r24, Y+6	; 0x06
    338e:	9f 81       	ldd	r25, Y+7	; 0x07
    3390:	fc 01       	movw	r30, r24
    3392:	e2 0f       	add	r30, r18
    3394:	f3 1f       	adc	r31, r19
    3396:	80 81       	ld	r24, Z
    3398:	88 23       	and	r24, r24
    339a:	31 f0       	breq	.+12     	; 0x33a8 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    339c:	89 81       	ldd	r24, Y+1	; 0x01
    339e:	8f 5f       	subi	r24, 0xFF	; 255
    33a0:	89 83       	std	Y+1, r24	; 0x01
    33a2:	89 81       	ldd	r24, Y+1	; 0x01
    33a4:	88 30       	cpi	r24, 0x08	; 8
    33a6:	e0 f2       	brcs	.-72     	; 0x3360 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    33a8:	e9 89       	ldd	r30, Y+17	; 0x11
    33aa:	fa 89       	ldd	r31, Y+18	; 0x12
    33ac:	10 a2       	std	Z+32, r1	; 0x20
    33ae:	03 c0       	rjmp	.+6      	; 0x33b6 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    33b0:	e9 89       	ldd	r30, Y+17	; 0x11
    33b2:	fa 89       	ldd	r31, Y+18	; 0x12
    33b4:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    33b6:	8e 85       	ldd	r24, Y+14	; 0x0e
    33b8:	84 30       	cpi	r24, 0x04	; 4
    33ba:	10 f0       	brcs	.+4      	; 0x33c0 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    33bc:	83 e0       	ldi	r24, 0x03	; 3
    33be:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    33c0:	e9 89       	ldd	r30, Y+17	; 0x11
    33c2:	fa 89       	ldd	r31, Y+18	; 0x12
    33c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    33c6:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    33c8:	89 89       	ldd	r24, Y+17	; 0x11
    33ca:	9a 89       	ldd	r25, Y+18	; 0x12
    33cc:	02 96       	adiw	r24, 0x02	; 2
    33ce:	0e 94 01 0e 	call	0x1c02	; 0x1c02 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    33d2:	89 89       	ldd	r24, Y+17	; 0x11
    33d4:	9a 89       	ldd	r25, Y+18	; 0x12
    33d6:	0c 96       	adiw	r24, 0x0c	; 12
    33d8:	0e 94 01 0e 	call	0x1c02	; 0x1c02 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    33dc:	e9 89       	ldd	r30, Y+17	; 0x11
    33de:	fa 89       	ldd	r31, Y+18	; 0x12
    33e0:	89 89       	ldd	r24, Y+17	; 0x11
    33e2:	9a 89       	ldd	r25, Y+18	; 0x12
    33e4:	91 87       	std	Z+9, r25	; 0x09
    33e6:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    33e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    33ea:	28 2f       	mov	r18, r24
    33ec:	30 e0       	ldi	r19, 0x00	; 0
    33ee:	84 e0       	ldi	r24, 0x04	; 4
    33f0:	90 e0       	ldi	r25, 0x00	; 0
    33f2:	82 1b       	sub	r24, r18
    33f4:	93 0b       	sbc	r25, r19
    33f6:	e9 89       	ldd	r30, Y+17	; 0x11
    33f8:	fa 89       	ldd	r31, Y+18	; 0x12
    33fa:	95 87       	std	Z+13, r25	; 0x0d
    33fc:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    33fe:	e9 89       	ldd	r30, Y+17	; 0x11
    3400:	fa 89       	ldd	r31, Y+18	; 0x12
    3402:	89 89       	ldd	r24, Y+17	; 0x11
    3404:	9a 89       	ldd	r25, Y+18	; 0x12
    3406:	93 8b       	std	Z+19, r25	; 0x13
    3408:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    340a:	e9 89       	ldd	r30, Y+17	; 0x11
    340c:	fa 89       	ldd	r31, Y+18	; 0x12
    340e:	11 a2       	std	Z+33, r1	; 0x21
    3410:	12 a2       	std	Z+34, r1	; 0x22
    3412:	13 a2       	std	Z+35, r1	; 0x23
    3414:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3416:	e9 89       	ldd	r30, Y+17	; 0x11
    3418:	fa 89       	ldd	r31, Y+18	; 0x12
    341a:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    341c:	8a 81       	ldd	r24, Y+2	; 0x02
    341e:	9b 81       	ldd	r25, Y+3	; 0x03
    3420:	2c 81       	ldd	r18, Y+4	; 0x04
    3422:	3d 81       	ldd	r19, Y+5	; 0x05
    3424:	4c 85       	ldd	r20, Y+12	; 0x0c
    3426:	5d 85       	ldd	r21, Y+13	; 0x0d
    3428:	b9 01       	movw	r22, r18
    342a:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <pxPortInitialiseStack>
    342e:	e9 89       	ldd	r30, Y+17	; 0x11
    3430:	fa 89       	ldd	r31, Y+18	; 0x12
    3432:	91 83       	std	Z+1, r25	; 0x01
    3434:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3436:	8f 85       	ldd	r24, Y+15	; 0x0f
    3438:	98 89       	ldd	r25, Y+16	; 0x10
    343a:	00 97       	sbiw	r24, 0x00	; 0
    343c:	31 f0       	breq	.+12     	; 0x344a <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    343e:	ef 85       	ldd	r30, Y+15	; 0x0f
    3440:	f8 89       	ldd	r31, Y+16	; 0x10
    3442:	89 89       	ldd	r24, Y+17	; 0x11
    3444:	9a 89       	ldd	r25, Y+18	; 0x12
    3446:	91 83       	std	Z+1, r25	; 0x01
    3448:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    344a:	64 96       	adiw	r28, 0x14	; 20
    344c:	0f b6       	in	r0, 0x3f	; 63
    344e:	f8 94       	cli
    3450:	de bf       	out	0x3e, r29	; 62
    3452:	0f be       	out	0x3f, r0	; 63
    3454:	cd bf       	out	0x3d, r28	; 61
    3456:	cf 91       	pop	r28
    3458:	df 91       	pop	r29
    345a:	1f 91       	pop	r17
    345c:	0f 91       	pop	r16
    345e:	ef 90       	pop	r14
    3460:	df 90       	pop	r13
    3462:	cf 90       	pop	r12
    3464:	bf 90       	pop	r11
    3466:	af 90       	pop	r10
    3468:	9f 90       	pop	r9
    346a:	8f 90       	pop	r8
    346c:	08 95       	ret

0000346e <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    346e:	df 93       	push	r29
    3470:	cf 93       	push	r28
    3472:	00 d0       	rcall	.+0      	; 0x3474 <prvAddNewTaskToReadyList+0x6>
    3474:	cd b7       	in	r28, 0x3d	; 61
    3476:	de b7       	in	r29, 0x3e	; 62
    3478:	9a 83       	std	Y+2, r25	; 0x02
    347a:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    347c:	0f b6       	in	r0, 0x3f	; 63
    347e:	f8 94       	cli
    3480:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3482:	80 91 77 04 	lds	r24, 0x0477
    3486:	8f 5f       	subi	r24, 0xFF	; 255
    3488:	80 93 77 04 	sts	0x0477, r24
		if( pxCurrentTCB == NULL )
    348c:	80 91 75 04 	lds	r24, 0x0475
    3490:	90 91 76 04 	lds	r25, 0x0476
    3494:	00 97       	sbiw	r24, 0x00	; 0
    3496:	69 f4       	brne	.+26     	; 0x34b2 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3498:	89 81       	ldd	r24, Y+1	; 0x01
    349a:	9a 81       	ldd	r25, Y+2	; 0x02
    349c:	90 93 76 04 	sts	0x0476, r25
    34a0:	80 93 75 04 	sts	0x0475, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    34a4:	80 91 77 04 	lds	r24, 0x0477
    34a8:	81 30       	cpi	r24, 0x01	; 1
    34aa:	b9 f4       	brne	.+46     	; 0x34da <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    34ac:	0e 94 97 1f 	call	0x3f2e	; 0x3f2e <prvInitialiseTaskLists>
    34b0:	14 c0       	rjmp	.+40     	; 0x34da <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    34b2:	80 91 7b 04 	lds	r24, 0x047B
    34b6:	88 23       	and	r24, r24
    34b8:	81 f4       	brne	.+32     	; 0x34da <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    34ba:	e0 91 75 04 	lds	r30, 0x0475
    34be:	f0 91 76 04 	lds	r31, 0x0476
    34c2:	96 89       	ldd	r25, Z+22	; 0x16
    34c4:	e9 81       	ldd	r30, Y+1	; 0x01
    34c6:	fa 81       	ldd	r31, Y+2	; 0x02
    34c8:	86 89       	ldd	r24, Z+22	; 0x16
    34ca:	89 17       	cp	r24, r25
    34cc:	30 f0       	brcs	.+12     	; 0x34da <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    34ce:	89 81       	ldd	r24, Y+1	; 0x01
    34d0:	9a 81       	ldd	r25, Y+2	; 0x02
    34d2:	90 93 76 04 	sts	0x0476, r25
    34d6:	80 93 75 04 	sts	0x0475, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    34da:	80 91 7f 04 	lds	r24, 0x047F
    34de:	8f 5f       	subi	r24, 0xFF	; 255
    34e0:	80 93 7f 04 	sts	0x047F, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    34e4:	e9 81       	ldd	r30, Y+1	; 0x01
    34e6:	fa 81       	ldd	r31, Y+2	; 0x02
    34e8:	96 89       	ldd	r25, Z+22	; 0x16
    34ea:	80 91 7a 04 	lds	r24, 0x047A
    34ee:	89 17       	cp	r24, r25
    34f0:	28 f4       	brcc	.+10     	; 0x34fc <prvAddNewTaskToReadyList+0x8e>
    34f2:	e9 81       	ldd	r30, Y+1	; 0x01
    34f4:	fa 81       	ldd	r31, Y+2	; 0x02
    34f6:	86 89       	ldd	r24, Z+22	; 0x16
    34f8:	80 93 7a 04 	sts	0x047A, r24
    34fc:	e9 81       	ldd	r30, Y+1	; 0x01
    34fe:	fa 81       	ldd	r31, Y+2	; 0x02
    3500:	86 89       	ldd	r24, Z+22	; 0x16
    3502:	28 2f       	mov	r18, r24
    3504:	30 e0       	ldi	r19, 0x00	; 0
    3506:	c9 01       	movw	r24, r18
    3508:	88 0f       	add	r24, r24
    350a:	99 1f       	adc	r25, r25
    350c:	88 0f       	add	r24, r24
    350e:	99 1f       	adc	r25, r25
    3510:	88 0f       	add	r24, r24
    3512:	99 1f       	adc	r25, r25
    3514:	82 0f       	add	r24, r18
    3516:	93 1f       	adc	r25, r19
    3518:	ac 01       	movw	r20, r24
    351a:	4b 57       	subi	r20, 0x7B	; 123
    351c:	5b 4f       	sbci	r21, 0xFB	; 251
    351e:	89 81       	ldd	r24, Y+1	; 0x01
    3520:	9a 81       	ldd	r25, Y+2	; 0x02
    3522:	9c 01       	movw	r18, r24
    3524:	2e 5f       	subi	r18, 0xFE	; 254
    3526:	3f 4f       	sbci	r19, 0xFF	; 255
    3528:	ca 01       	movw	r24, r20
    352a:	b9 01       	movw	r22, r18
    352c:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3530:	0f 90       	pop	r0
    3532:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3534:	80 91 7b 04 	lds	r24, 0x047B
    3538:	88 23       	and	r24, r24
    353a:	61 f0       	breq	.+24     	; 0x3554 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    353c:	e0 91 75 04 	lds	r30, 0x0475
    3540:	f0 91 76 04 	lds	r31, 0x0476
    3544:	96 89       	ldd	r25, Z+22	; 0x16
    3546:	e9 81       	ldd	r30, Y+1	; 0x01
    3548:	fa 81       	ldd	r31, Y+2	; 0x02
    354a:	86 89       	ldd	r24, Z+22	; 0x16
    354c:	98 17       	cp	r25, r24
    354e:	10 f4       	brcc	.+4      	; 0x3554 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3550:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3554:	0f 90       	pop	r0
    3556:	0f 90       	pop	r0
    3558:	cf 91       	pop	r28
    355a:	df 91       	pop	r29
    355c:	08 95       	ret

0000355e <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    355e:	df 93       	push	r29
    3560:	cf 93       	push	r28
    3562:	cd b7       	in	r28, 0x3d	; 61
    3564:	de b7       	in	r29, 0x3e	; 62
    3566:	2a 97       	sbiw	r28, 0x0a	; 10
    3568:	0f b6       	in	r0, 0x3f	; 63
    356a:	f8 94       	cli
    356c:	de bf       	out	0x3e, r29	; 62
    356e:	0f be       	out	0x3f, r0	; 63
    3570:	cd bf       	out	0x3d, r28	; 61
    3572:	98 87       	std	Y+8, r25	; 0x08
    3574:	8f 83       	std	Y+7, r24	; 0x07
    3576:	7a 87       	std	Y+10, r23	; 0x0a
    3578:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    357a:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    357c:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3580:	80 91 78 04 	lds	r24, 0x0478
    3584:	90 91 79 04 	lds	r25, 0x0479
    3588:	9a 83       	std	Y+2, r25	; 0x02
    358a:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    358c:	ef 81       	ldd	r30, Y+7	; 0x07
    358e:	f8 85       	ldd	r31, Y+8	; 0x08
    3590:	20 81       	ld	r18, Z
    3592:	31 81       	ldd	r19, Z+1	; 0x01
    3594:	89 85       	ldd	r24, Y+9	; 0x09
    3596:	9a 85       	ldd	r25, Y+10	; 0x0a
    3598:	82 0f       	add	r24, r18
    359a:	93 1f       	adc	r25, r19
    359c:	9e 83       	std	Y+6, r25	; 0x06
    359e:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    35a0:	ef 81       	ldd	r30, Y+7	; 0x07
    35a2:	f8 85       	ldd	r31, Y+8	; 0x08
    35a4:	20 81       	ld	r18, Z
    35a6:	31 81       	ldd	r19, Z+1	; 0x01
    35a8:	89 81       	ldd	r24, Y+1	; 0x01
    35aa:	9a 81       	ldd	r25, Y+2	; 0x02
    35ac:	82 17       	cp	r24, r18
    35ae:	93 07       	cpc	r25, r19
    35b0:	98 f4       	brcc	.+38     	; 0x35d8 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    35b2:	ef 81       	ldd	r30, Y+7	; 0x07
    35b4:	f8 85       	ldd	r31, Y+8	; 0x08
    35b6:	20 81       	ld	r18, Z
    35b8:	31 81       	ldd	r19, Z+1	; 0x01
    35ba:	8d 81       	ldd	r24, Y+5	; 0x05
    35bc:	9e 81       	ldd	r25, Y+6	; 0x06
    35be:	82 17       	cp	r24, r18
    35c0:	93 07       	cpc	r25, r19
    35c2:	e0 f4       	brcc	.+56     	; 0x35fc <vTaskDelayUntil+0x9e>
    35c4:	2d 81       	ldd	r18, Y+5	; 0x05
    35c6:	3e 81       	ldd	r19, Y+6	; 0x06
    35c8:	89 81       	ldd	r24, Y+1	; 0x01
    35ca:	9a 81       	ldd	r25, Y+2	; 0x02
    35cc:	82 17       	cp	r24, r18
    35ce:	93 07       	cpc	r25, r19
    35d0:	a8 f4       	brcc	.+42     	; 0x35fc <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    35d2:	81 e0       	ldi	r24, 0x01	; 1
    35d4:	8b 83       	std	Y+3, r24	; 0x03
    35d6:	12 c0       	rjmp	.+36     	; 0x35fc <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    35d8:	ef 81       	ldd	r30, Y+7	; 0x07
    35da:	f8 85       	ldd	r31, Y+8	; 0x08
    35dc:	20 81       	ld	r18, Z
    35de:	31 81       	ldd	r19, Z+1	; 0x01
    35e0:	8d 81       	ldd	r24, Y+5	; 0x05
    35e2:	9e 81       	ldd	r25, Y+6	; 0x06
    35e4:	82 17       	cp	r24, r18
    35e6:	93 07       	cpc	r25, r19
    35e8:	38 f0       	brcs	.+14     	; 0x35f8 <vTaskDelayUntil+0x9a>
    35ea:	2d 81       	ldd	r18, Y+5	; 0x05
    35ec:	3e 81       	ldd	r19, Y+6	; 0x06
    35ee:	89 81       	ldd	r24, Y+1	; 0x01
    35f0:	9a 81       	ldd	r25, Y+2	; 0x02
    35f2:	82 17       	cp	r24, r18
    35f4:	93 07       	cpc	r25, r19
    35f6:	10 f4       	brcc	.+4      	; 0x35fc <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    35f8:	81 e0       	ldi	r24, 0x01	; 1
    35fa:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    35fc:	ef 81       	ldd	r30, Y+7	; 0x07
    35fe:	f8 85       	ldd	r31, Y+8	; 0x08
    3600:	8d 81       	ldd	r24, Y+5	; 0x05
    3602:	9e 81       	ldd	r25, Y+6	; 0x06
    3604:	91 83       	std	Z+1, r25	; 0x01
    3606:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    3608:	8b 81       	ldd	r24, Y+3	; 0x03
    360a:	88 23       	and	r24, r24
    360c:	49 f0       	breq	.+18     	; 0x3620 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    360e:	8d 81       	ldd	r24, Y+5	; 0x05
    3610:	9e 81       	ldd	r25, Y+6	; 0x06
    3612:	29 81       	ldd	r18, Y+1	; 0x01
    3614:	3a 81       	ldd	r19, Y+2	; 0x02
    3616:	82 1b       	sub	r24, r18
    3618:	93 0b       	sbc	r25, r19
    361a:	60 e0       	ldi	r22, 0x00	; 0
    361c:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3620:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    3624:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3626:	8c 81       	ldd	r24, Y+4	; 0x04
    3628:	88 23       	and	r24, r24
    362a:	11 f4       	brne	.+4      	; 0x3630 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    362c:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3630:	2a 96       	adiw	r28, 0x0a	; 10
    3632:	0f b6       	in	r0, 0x3f	; 63
    3634:	f8 94       	cli
    3636:	de bf       	out	0x3e, r29	; 62
    3638:	0f be       	out	0x3f, r0	; 63
    363a:	cd bf       	out	0x3d, r28	; 61
    363c:	cf 91       	pop	r28
    363e:	df 91       	pop	r29
    3640:	08 95       	ret

00003642 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3642:	df 93       	push	r29
    3644:	cf 93       	push	r28
    3646:	00 d0       	rcall	.+0      	; 0x3648 <vTaskDelay+0x6>
    3648:	0f 92       	push	r0
    364a:	cd b7       	in	r28, 0x3d	; 61
    364c:	de b7       	in	r29, 0x3e	; 62
    364e:	9b 83       	std	Y+3, r25	; 0x03
    3650:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3652:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3654:	8a 81       	ldd	r24, Y+2	; 0x02
    3656:	9b 81       	ldd	r25, Y+3	; 0x03
    3658:	00 97       	sbiw	r24, 0x00	; 0
    365a:	51 f0       	breq	.+20     	; 0x3670 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    365c:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3660:	8a 81       	ldd	r24, Y+2	; 0x02
    3662:	9b 81       	ldd	r25, Y+3	; 0x03
    3664:	60 e0       	ldi	r22, 0x00	; 0
    3666:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    366a:	0e 94 8d 1b 	call	0x371a	; 0x371a <xTaskResumeAll>
    366e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3670:	89 81       	ldd	r24, Y+1	; 0x01
    3672:	88 23       	and	r24, r24
    3674:	11 f4       	brne	.+4      	; 0x367a <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3676:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    367a:	0f 90       	pop	r0
    367c:	0f 90       	pop	r0
    367e:	0f 90       	pop	r0
    3680:	cf 91       	pop	r28
    3682:	df 91       	pop	r29
    3684:	08 95       	ret

00003686 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3686:	ef 92       	push	r14
    3688:	ff 92       	push	r15
    368a:	0f 93       	push	r16
    368c:	df 93       	push	r29
    368e:	cf 93       	push	r28
    3690:	0f 92       	push	r0
    3692:	cd b7       	in	r28, 0x3d	; 61
    3694:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    3696:	8d e8       	ldi	r24, 0x8D	; 141
    3698:	9f e1       	ldi	r25, 0x1F	; 31
    369a:	21 ee       	ldi	r18, 0xE1	; 225
    369c:	30 e0       	ldi	r19, 0x00	; 0
    369e:	e2 e8       	ldi	r30, 0x82	; 130
    36a0:	f4 e0       	ldi	r31, 0x04	; 4
    36a2:	b9 01       	movw	r22, r18
    36a4:	45 e5       	ldi	r20, 0x55	; 85
    36a6:	50 e0       	ldi	r21, 0x00	; 0
    36a8:	20 e0       	ldi	r18, 0x00	; 0
    36aa:	30 e0       	ldi	r19, 0x00	; 0
    36ac:	00 e0       	ldi	r16, 0x00	; 0
    36ae:	7f 01       	movw	r14, r30
    36b0:	0e 94 03 19 	call	0x3206	; 0x3206 <xTaskCreate>
    36b4:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    36b6:	89 81       	ldd	r24, Y+1	; 0x01
    36b8:	81 30       	cpi	r24, 0x01	; 1
    36ba:	81 f4       	brne	.+32     	; 0x36dc <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    36bc:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    36be:	8f ef       	ldi	r24, 0xFF	; 255
    36c0:	9f ef       	ldi	r25, 0xFF	; 255
    36c2:	90 93 81 04 	sts	0x0481, r25
    36c6:	80 93 80 04 	sts	0x0480, r24
		xSchedulerRunning = pdTRUE;
    36ca:	81 e0       	ldi	r24, 0x01	; 1
    36cc:	80 93 7b 04 	sts	0x047B, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    36d0:	10 92 79 04 	sts	0x0479, r1
    36d4:	10 92 78 04 	sts	0x0478, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    36d8:	0e 94 90 10 	call	0x2120	; 0x2120 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    36dc:	0f 90       	pop	r0
    36de:	cf 91       	pop	r28
    36e0:	df 91       	pop	r29
    36e2:	0f 91       	pop	r16
    36e4:	ff 90       	pop	r15
    36e6:	ef 90       	pop	r14
    36e8:	08 95       	ret

000036ea <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    36ea:	df 93       	push	r29
    36ec:	cf 93       	push	r28
    36ee:	cd b7       	in	r28, 0x3d	; 61
    36f0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    36f2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    36f4:	10 92 7b 04 	sts	0x047B, r1
	vPortEndScheduler();
    36f8:	0e 94 c5 10 	call	0x218a	; 0x218a <vPortEndScheduler>
}
    36fc:	cf 91       	pop	r28
    36fe:	df 91       	pop	r29
    3700:	08 95       	ret

00003702 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3702:	df 93       	push	r29
    3704:	cf 93       	push	r28
    3706:	cd b7       	in	r28, 0x3d	; 61
    3708:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    370a:	80 91 84 04 	lds	r24, 0x0484
    370e:	8f 5f       	subi	r24, 0xFF	; 255
    3710:	80 93 84 04 	sts	0x0484, r24
	portMEMORY_BARRIER();
}
    3714:	cf 91       	pop	r28
    3716:	df 91       	pop	r29
    3718:	08 95       	ret

0000371a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    371a:	df 93       	push	r29
    371c:	cf 93       	push	r28
    371e:	00 d0       	rcall	.+0      	; 0x3720 <xTaskResumeAll+0x6>
    3720:	00 d0       	rcall	.+0      	; 0x3722 <xTaskResumeAll+0x8>
    3722:	cd b7       	in	r28, 0x3d	; 61
    3724:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    3726:	1c 82       	std	Y+4, r1	; 0x04
    3728:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    372a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    372c:	0f b6       	in	r0, 0x3f	; 63
    372e:	f8 94       	cli
    3730:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3732:	80 91 84 04 	lds	r24, 0x0484
    3736:	81 50       	subi	r24, 0x01	; 1
    3738:	80 93 84 04 	sts	0x0484, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    373c:	80 91 84 04 	lds	r24, 0x0484
    3740:	88 23       	and	r24, r24
    3742:	09 f0       	breq	.+2      	; 0x3746 <xTaskResumeAll+0x2c>
    3744:	73 c0       	rjmp	.+230    	; 0x382c <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3746:	80 91 77 04 	lds	r24, 0x0477
    374a:	88 23       	and	r24, r24
    374c:	09 f4       	brne	.+2      	; 0x3750 <xTaskResumeAll+0x36>
    374e:	6e c0       	rjmp	.+220    	; 0x382c <xTaskResumeAll+0x112>
    3750:	45 c0       	rjmp	.+138    	; 0x37dc <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3752:	e0 91 c4 04 	lds	r30, 0x04C4
    3756:	f0 91 c5 04 	lds	r31, 0x04C5
    375a:	86 81       	ldd	r24, Z+6	; 0x06
    375c:	97 81       	ldd	r25, Z+7	; 0x07
    375e:	9c 83       	std	Y+4, r25	; 0x04
    3760:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3762:	8b 81       	ldd	r24, Y+3	; 0x03
    3764:	9c 81       	ldd	r25, Y+4	; 0x04
    3766:	0c 96       	adiw	r24, 0x0c	; 12
    3768:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    376c:	8b 81       	ldd	r24, Y+3	; 0x03
    376e:	9c 81       	ldd	r25, Y+4	; 0x04
    3770:	02 96       	adiw	r24, 0x02	; 2
    3772:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3776:	eb 81       	ldd	r30, Y+3	; 0x03
    3778:	fc 81       	ldd	r31, Y+4	; 0x04
    377a:	96 89       	ldd	r25, Z+22	; 0x16
    377c:	80 91 7a 04 	lds	r24, 0x047A
    3780:	89 17       	cp	r24, r25
    3782:	28 f4       	brcc	.+10     	; 0x378e <xTaskResumeAll+0x74>
    3784:	eb 81       	ldd	r30, Y+3	; 0x03
    3786:	fc 81       	ldd	r31, Y+4	; 0x04
    3788:	86 89       	ldd	r24, Z+22	; 0x16
    378a:	80 93 7a 04 	sts	0x047A, r24
    378e:	eb 81       	ldd	r30, Y+3	; 0x03
    3790:	fc 81       	ldd	r31, Y+4	; 0x04
    3792:	86 89       	ldd	r24, Z+22	; 0x16
    3794:	28 2f       	mov	r18, r24
    3796:	30 e0       	ldi	r19, 0x00	; 0
    3798:	c9 01       	movw	r24, r18
    379a:	88 0f       	add	r24, r24
    379c:	99 1f       	adc	r25, r25
    379e:	88 0f       	add	r24, r24
    37a0:	99 1f       	adc	r25, r25
    37a2:	88 0f       	add	r24, r24
    37a4:	99 1f       	adc	r25, r25
    37a6:	82 0f       	add	r24, r18
    37a8:	93 1f       	adc	r25, r19
    37aa:	ac 01       	movw	r20, r24
    37ac:	4b 57       	subi	r20, 0x7B	; 123
    37ae:	5b 4f       	sbci	r21, 0xFB	; 251
    37b0:	8b 81       	ldd	r24, Y+3	; 0x03
    37b2:	9c 81       	ldd	r25, Y+4	; 0x04
    37b4:	9c 01       	movw	r18, r24
    37b6:	2e 5f       	subi	r18, 0xFE	; 254
    37b8:	3f 4f       	sbci	r19, 0xFF	; 255
    37ba:	ca 01       	movw	r24, r20
    37bc:	b9 01       	movw	r22, r18
    37be:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    37c2:	eb 81       	ldd	r30, Y+3	; 0x03
    37c4:	fc 81       	ldd	r31, Y+4	; 0x04
    37c6:	96 89       	ldd	r25, Z+22	; 0x16
    37c8:	e0 91 75 04 	lds	r30, 0x0475
    37cc:	f0 91 76 04 	lds	r31, 0x0476
    37d0:	86 89       	ldd	r24, Z+22	; 0x16
    37d2:	98 17       	cp	r25, r24
    37d4:	18 f0       	brcs	.+6      	; 0x37dc <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    37d6:	81 e0       	ldi	r24, 0x01	; 1
    37d8:	80 93 7d 04 	sts	0x047D, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    37dc:	80 91 bf 04 	lds	r24, 0x04BF
    37e0:	88 23       	and	r24, r24
    37e2:	09 f0       	breq	.+2      	; 0x37e6 <xTaskResumeAll+0xcc>
    37e4:	b6 cf       	rjmp	.-148    	; 0x3752 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    37e6:	8b 81       	ldd	r24, Y+3	; 0x03
    37e8:	9c 81       	ldd	r25, Y+4	; 0x04
    37ea:	00 97       	sbiw	r24, 0x00	; 0
    37ec:	11 f0       	breq	.+4      	; 0x37f2 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    37ee:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    37f2:	80 91 7c 04 	lds	r24, 0x047C
    37f6:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    37f8:	89 81       	ldd	r24, Y+1	; 0x01
    37fa:	88 23       	and	r24, r24
    37fc:	79 f0       	breq	.+30     	; 0x381c <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    37fe:	0e 94 7d 1c 	call	0x38fa	; 0x38fa <xTaskIncrementTick>
    3802:	88 23       	and	r24, r24
    3804:	19 f0       	breq	.+6      	; 0x380c <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    3806:	81 e0       	ldi	r24, 0x01	; 1
    3808:	80 93 7d 04 	sts	0x047D, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    380c:	89 81       	ldd	r24, Y+1	; 0x01
    380e:	81 50       	subi	r24, 0x01	; 1
    3810:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    3812:	89 81       	ldd	r24, Y+1	; 0x01
    3814:	88 23       	and	r24, r24
    3816:	99 f7       	brne	.-26     	; 0x37fe <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    3818:	10 92 7c 04 	sts	0x047C, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    381c:	80 91 7d 04 	lds	r24, 0x047D
    3820:	88 23       	and	r24, r24
    3822:	21 f0       	breq	.+8      	; 0x382c <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3824:	81 e0       	ldi	r24, 0x01	; 1
    3826:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3828:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    382c:	0f 90       	pop	r0
    382e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3830:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3832:	0f 90       	pop	r0
    3834:	0f 90       	pop	r0
    3836:	0f 90       	pop	r0
    3838:	0f 90       	pop	r0
    383a:	cf 91       	pop	r28
    383c:	df 91       	pop	r29
    383e:	08 95       	ret

00003840 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3840:	df 93       	push	r29
    3842:	cf 93       	push	r28
    3844:	00 d0       	rcall	.+0      	; 0x3846 <xTaskGetTickCount+0x6>
    3846:	cd b7       	in	r28, 0x3d	; 61
    3848:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    384a:	0f b6       	in	r0, 0x3f	; 63
    384c:	f8 94       	cli
    384e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3850:	80 91 78 04 	lds	r24, 0x0478
    3854:	90 91 79 04 	lds	r25, 0x0479
    3858:	9a 83       	std	Y+2, r25	; 0x02
    385a:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    385c:	0f 90       	pop	r0
    385e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3860:	89 81       	ldd	r24, Y+1	; 0x01
    3862:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3864:	0f 90       	pop	r0
    3866:	0f 90       	pop	r0
    3868:	cf 91       	pop	r28
    386a:	df 91       	pop	r29
    386c:	08 95       	ret

0000386e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    386e:	df 93       	push	r29
    3870:	cf 93       	push	r28
    3872:	00 d0       	rcall	.+0      	; 0x3874 <xTaskGetTickCountFromISR+0x6>
    3874:	0f 92       	push	r0
    3876:	cd b7       	in	r28, 0x3d	; 61
    3878:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    387a:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    387c:	80 91 78 04 	lds	r24, 0x0478
    3880:	90 91 79 04 	lds	r25, 0x0479
    3884:	9b 83       	std	Y+3, r25	; 0x03
    3886:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3888:	8a 81       	ldd	r24, Y+2	; 0x02
    388a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    388c:	0f 90       	pop	r0
    388e:	0f 90       	pop	r0
    3890:	0f 90       	pop	r0
    3892:	cf 91       	pop	r28
    3894:	df 91       	pop	r29
    3896:	08 95       	ret

00003898 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3898:	df 93       	push	r29
    389a:	cf 93       	push	r28
    389c:	cd b7       	in	r28, 0x3d	; 61
    389e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    38a0:	80 91 77 04 	lds	r24, 0x0477
}
    38a4:	cf 91       	pop	r28
    38a6:	df 91       	pop	r29
    38a8:	08 95       	ret

000038aa <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    38aa:	df 93       	push	r29
    38ac:	cf 93       	push	r28
    38ae:	00 d0       	rcall	.+0      	; 0x38b0 <pcTaskGetName+0x6>
    38b0:	00 d0       	rcall	.+0      	; 0x38b2 <pcTaskGetName+0x8>
    38b2:	00 d0       	rcall	.+0      	; 0x38b4 <pcTaskGetName+0xa>
    38b4:	cd b7       	in	r28, 0x3d	; 61
    38b6:	de b7       	in	r29, 0x3e	; 62
    38b8:	9c 83       	std	Y+4, r25	; 0x04
    38ba:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    38bc:	8b 81       	ldd	r24, Y+3	; 0x03
    38be:	9c 81       	ldd	r25, Y+4	; 0x04
    38c0:	00 97       	sbiw	r24, 0x00	; 0
    38c2:	39 f4       	brne	.+14     	; 0x38d2 <pcTaskGetName+0x28>
    38c4:	80 91 75 04 	lds	r24, 0x0475
    38c8:	90 91 76 04 	lds	r25, 0x0476
    38cc:	9e 83       	std	Y+6, r25	; 0x06
    38ce:	8d 83       	std	Y+5, r24	; 0x05
    38d0:	04 c0       	rjmp	.+8      	; 0x38da <pcTaskGetName+0x30>
    38d2:	8b 81       	ldd	r24, Y+3	; 0x03
    38d4:	9c 81       	ldd	r25, Y+4	; 0x04
    38d6:	9e 83       	std	Y+6, r25	; 0x06
    38d8:	8d 83       	std	Y+5, r24	; 0x05
    38da:	8d 81       	ldd	r24, Y+5	; 0x05
    38dc:	9e 81       	ldd	r25, Y+6	; 0x06
    38de:	9a 83       	std	Y+2, r25	; 0x02
    38e0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    38e2:	89 81       	ldd	r24, Y+1	; 0x01
    38e4:	9a 81       	ldd	r25, Y+2	; 0x02
    38e6:	49 96       	adiw	r24, 0x19	; 25
}
    38e8:	26 96       	adiw	r28, 0x06	; 6
    38ea:	0f b6       	in	r0, 0x3f	; 63
    38ec:	f8 94       	cli
    38ee:	de bf       	out	0x3e, r29	; 62
    38f0:	0f be       	out	0x3f, r0	; 63
    38f2:	cd bf       	out	0x3d, r28	; 61
    38f4:	cf 91       	pop	r28
    38f6:	df 91       	pop	r29
    38f8:	08 95       	ret

000038fa <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    38fa:	df 93       	push	r29
    38fc:	cf 93       	push	r28
    38fe:	cd b7       	in	r28, 0x3d	; 61
    3900:	de b7       	in	r29, 0x3e	; 62
    3902:	29 97       	sbiw	r28, 0x09	; 9
    3904:	0f b6       	in	r0, 0x3f	; 63
    3906:	f8 94       	cli
    3908:	de bf       	out	0x3e, r29	; 62
    390a:	0f be       	out	0x3f, r0	; 63
    390c:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    390e:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3910:	80 91 84 04 	lds	r24, 0x0484
    3914:	88 23       	and	r24, r24
    3916:	09 f0       	breq	.+2      	; 0x391a <xTaskIncrementTick+0x20>
    3918:	c0 c0       	rjmp	.+384    	; 0x3a9a <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    391a:	80 91 78 04 	lds	r24, 0x0478
    391e:	90 91 79 04 	lds	r25, 0x0479
    3922:	01 96       	adiw	r24, 0x01	; 1
    3924:	9c 83       	std	Y+4, r25	; 0x04
    3926:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    3928:	8b 81       	ldd	r24, Y+3	; 0x03
    392a:	9c 81       	ldd	r25, Y+4	; 0x04
    392c:	90 93 79 04 	sts	0x0479, r25
    3930:	80 93 78 04 	sts	0x0478, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3934:	8b 81       	ldd	r24, Y+3	; 0x03
    3936:	9c 81       	ldd	r25, Y+4	; 0x04
    3938:	00 97       	sbiw	r24, 0x00	; 0
    393a:	d9 f4       	brne	.+54     	; 0x3972 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    393c:	80 91 bb 04 	lds	r24, 0x04BB
    3940:	90 91 bc 04 	lds	r25, 0x04BC
    3944:	9a 83       	std	Y+2, r25	; 0x02
    3946:	89 83       	std	Y+1, r24	; 0x01
    3948:	80 91 bd 04 	lds	r24, 0x04BD
    394c:	90 91 be 04 	lds	r25, 0x04BE
    3950:	90 93 bc 04 	sts	0x04BC, r25
    3954:	80 93 bb 04 	sts	0x04BB, r24
    3958:	89 81       	ldd	r24, Y+1	; 0x01
    395a:	9a 81       	ldd	r25, Y+2	; 0x02
    395c:	90 93 be 04 	sts	0x04BE, r25
    3960:	80 93 bd 04 	sts	0x04BD, r24
    3964:	80 91 7e 04 	lds	r24, 0x047E
    3968:	8f 5f       	subi	r24, 0xFF	; 255
    396a:	80 93 7e 04 	sts	0x047E, r24
    396e:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    3972:	20 91 80 04 	lds	r18, 0x0480
    3976:	30 91 81 04 	lds	r19, 0x0481
    397a:	8b 81       	ldd	r24, Y+3	; 0x03
    397c:	9c 81       	ldd	r25, Y+4	; 0x04
    397e:	82 17       	cp	r24, r18
    3980:	93 07       	cpc	r25, r19
    3982:	08 f4       	brcc	.+2      	; 0x3986 <xTaskIncrementTick+0x8c>
    3984:	71 c0       	rjmp	.+226    	; 0x3a68 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3986:	e0 91 bb 04 	lds	r30, 0x04BB
    398a:	f0 91 bc 04 	lds	r31, 0x04BC
    398e:	80 81       	ld	r24, Z
    3990:	88 23       	and	r24, r24
    3992:	39 f4       	brne	.+14     	; 0x39a2 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3994:	8f ef       	ldi	r24, 0xFF	; 255
    3996:	9f ef       	ldi	r25, 0xFF	; 255
    3998:	90 93 81 04 	sts	0x0481, r25
    399c:	80 93 80 04 	sts	0x0480, r24
    39a0:	63 c0       	rjmp	.+198    	; 0x3a68 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    39a2:	e0 91 bb 04 	lds	r30, 0x04BB
    39a6:	f0 91 bc 04 	lds	r31, 0x04BC
    39aa:	05 80       	ldd	r0, Z+5	; 0x05
    39ac:	f6 81       	ldd	r31, Z+6	; 0x06
    39ae:	e0 2d       	mov	r30, r0
    39b0:	86 81       	ldd	r24, Z+6	; 0x06
    39b2:	97 81       	ldd	r25, Z+7	; 0x07
    39b4:	99 87       	std	Y+9, r25	; 0x09
    39b6:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    39b8:	e8 85       	ldd	r30, Y+8	; 0x08
    39ba:	f9 85       	ldd	r31, Y+9	; 0x09
    39bc:	82 81       	ldd	r24, Z+2	; 0x02
    39be:	93 81       	ldd	r25, Z+3	; 0x03
    39c0:	9f 83       	std	Y+7, r25	; 0x07
    39c2:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    39c4:	2b 81       	ldd	r18, Y+3	; 0x03
    39c6:	3c 81       	ldd	r19, Y+4	; 0x04
    39c8:	8e 81       	ldd	r24, Y+6	; 0x06
    39ca:	9f 81       	ldd	r25, Y+7	; 0x07
    39cc:	28 17       	cp	r18, r24
    39ce:	39 07       	cpc	r19, r25
    39d0:	38 f4       	brcc	.+14     	; 0x39e0 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    39d2:	8e 81       	ldd	r24, Y+6	; 0x06
    39d4:	9f 81       	ldd	r25, Y+7	; 0x07
    39d6:	90 93 81 04 	sts	0x0481, r25
    39da:	80 93 80 04 	sts	0x0480, r24
    39de:	44 c0       	rjmp	.+136    	; 0x3a68 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    39e0:	88 85       	ldd	r24, Y+8	; 0x08
    39e2:	99 85       	ldd	r25, Y+9	; 0x09
    39e4:	02 96       	adiw	r24, 0x02	; 2
    39e6:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    39ea:	e8 85       	ldd	r30, Y+8	; 0x08
    39ec:	f9 85       	ldd	r31, Y+9	; 0x09
    39ee:	84 89       	ldd	r24, Z+20	; 0x14
    39f0:	95 89       	ldd	r25, Z+21	; 0x15
    39f2:	00 97       	sbiw	r24, 0x00	; 0
    39f4:	29 f0       	breq	.+10     	; 0x3a00 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    39f6:	88 85       	ldd	r24, Y+8	; 0x08
    39f8:	99 85       	ldd	r25, Y+9	; 0x09
    39fa:	0c 96       	adiw	r24, 0x0c	; 12
    39fc:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3a00:	e8 85       	ldd	r30, Y+8	; 0x08
    3a02:	f9 85       	ldd	r31, Y+9	; 0x09
    3a04:	96 89       	ldd	r25, Z+22	; 0x16
    3a06:	80 91 7a 04 	lds	r24, 0x047A
    3a0a:	89 17       	cp	r24, r25
    3a0c:	28 f4       	brcc	.+10     	; 0x3a18 <xTaskIncrementTick+0x11e>
    3a0e:	e8 85       	ldd	r30, Y+8	; 0x08
    3a10:	f9 85       	ldd	r31, Y+9	; 0x09
    3a12:	86 89       	ldd	r24, Z+22	; 0x16
    3a14:	80 93 7a 04 	sts	0x047A, r24
    3a18:	e8 85       	ldd	r30, Y+8	; 0x08
    3a1a:	f9 85       	ldd	r31, Y+9	; 0x09
    3a1c:	86 89       	ldd	r24, Z+22	; 0x16
    3a1e:	28 2f       	mov	r18, r24
    3a20:	30 e0       	ldi	r19, 0x00	; 0
    3a22:	c9 01       	movw	r24, r18
    3a24:	88 0f       	add	r24, r24
    3a26:	99 1f       	adc	r25, r25
    3a28:	88 0f       	add	r24, r24
    3a2a:	99 1f       	adc	r25, r25
    3a2c:	88 0f       	add	r24, r24
    3a2e:	99 1f       	adc	r25, r25
    3a30:	82 0f       	add	r24, r18
    3a32:	93 1f       	adc	r25, r19
    3a34:	ac 01       	movw	r20, r24
    3a36:	4b 57       	subi	r20, 0x7B	; 123
    3a38:	5b 4f       	sbci	r21, 0xFB	; 251
    3a3a:	88 85       	ldd	r24, Y+8	; 0x08
    3a3c:	99 85       	ldd	r25, Y+9	; 0x09
    3a3e:	9c 01       	movw	r18, r24
    3a40:	2e 5f       	subi	r18, 0xFE	; 254
    3a42:	3f 4f       	sbci	r19, 0xFF	; 255
    3a44:	ca 01       	movw	r24, r20
    3a46:	b9 01       	movw	r22, r18
    3a48:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3a4c:	e8 85       	ldd	r30, Y+8	; 0x08
    3a4e:	f9 85       	ldd	r31, Y+9	; 0x09
    3a50:	96 89       	ldd	r25, Z+22	; 0x16
    3a52:	e0 91 75 04 	lds	r30, 0x0475
    3a56:	f0 91 76 04 	lds	r31, 0x0476
    3a5a:	86 89       	ldd	r24, Z+22	; 0x16
    3a5c:	98 17       	cp	r25, r24
    3a5e:	08 f4       	brcc	.+2      	; 0x3a62 <xTaskIncrementTick+0x168>
    3a60:	92 cf       	rjmp	.-220    	; 0x3986 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    3a62:	81 e0       	ldi	r24, 0x01	; 1
    3a64:	8d 83       	std	Y+5, r24	; 0x05
    3a66:	8f cf       	rjmp	.-226    	; 0x3986 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3a68:	e0 91 75 04 	lds	r30, 0x0475
    3a6c:	f0 91 76 04 	lds	r31, 0x0476
    3a70:	86 89       	ldd	r24, Z+22	; 0x16
    3a72:	28 2f       	mov	r18, r24
    3a74:	30 e0       	ldi	r19, 0x00	; 0
    3a76:	c9 01       	movw	r24, r18
    3a78:	88 0f       	add	r24, r24
    3a7a:	99 1f       	adc	r25, r25
    3a7c:	88 0f       	add	r24, r24
    3a7e:	99 1f       	adc	r25, r25
    3a80:	88 0f       	add	r24, r24
    3a82:	99 1f       	adc	r25, r25
    3a84:	82 0f       	add	r24, r18
    3a86:	93 1f       	adc	r25, r19
    3a88:	fc 01       	movw	r30, r24
    3a8a:	eb 57       	subi	r30, 0x7B	; 123
    3a8c:	fb 4f       	sbci	r31, 0xFB	; 251
    3a8e:	80 81       	ld	r24, Z
    3a90:	82 30       	cpi	r24, 0x02	; 2
    3a92:	40 f0       	brcs	.+16     	; 0x3aa4 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    3a94:	81 e0       	ldi	r24, 0x01	; 1
    3a96:	8d 83       	std	Y+5, r24	; 0x05
    3a98:	05 c0       	rjmp	.+10     	; 0x3aa4 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3a9a:	80 91 7c 04 	lds	r24, 0x047C
    3a9e:	8f 5f       	subi	r24, 0xFF	; 255
    3aa0:	80 93 7c 04 	sts	0x047C, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    3aa4:	80 91 7d 04 	lds	r24, 0x047D
    3aa8:	88 23       	and	r24, r24
    3aaa:	11 f0       	breq	.+4      	; 0x3ab0 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    3aac:	81 e0       	ldi	r24, 0x01	; 1
    3aae:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3ab0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3ab2:	29 96       	adiw	r28, 0x09	; 9
    3ab4:	0f b6       	in	r0, 0x3f	; 63
    3ab6:	f8 94       	cli
    3ab8:	de bf       	out	0x3e, r29	; 62
    3aba:	0f be       	out	0x3f, r0	; 63
    3abc:	cd bf       	out	0x3d, r28	; 61
    3abe:	cf 91       	pop	r28
    3ac0:	df 91       	pop	r29
    3ac2:	08 95       	ret

00003ac4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3ac4:	df 93       	push	r29
    3ac6:	cf 93       	push	r28
    3ac8:	00 d0       	rcall	.+0      	; 0x3aca <vTaskSwitchContext+0x6>
    3aca:	0f 92       	push	r0
    3acc:	cd b7       	in	r28, 0x3d	; 61
    3ace:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3ad0:	80 91 84 04 	lds	r24, 0x0484
    3ad4:	88 23       	and	r24, r24
    3ad6:	21 f0       	breq	.+8      	; 0x3ae0 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3ad8:	81 e0       	ldi	r24, 0x01	; 1
    3ada:	80 93 7d 04 	sts	0x047D, r24
    3ade:	59 c0       	rjmp	.+178    	; 0x3b92 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    3ae0:	10 92 7d 04 	sts	0x047D, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ae4:	80 91 7a 04 	lds	r24, 0x047A
    3ae8:	8b 83       	std	Y+3, r24	; 0x03
    3aea:	03 c0       	rjmp	.+6      	; 0x3af2 <vTaskSwitchContext+0x2e>
    3aec:	8b 81       	ldd	r24, Y+3	; 0x03
    3aee:	81 50       	subi	r24, 0x01	; 1
    3af0:	8b 83       	std	Y+3, r24	; 0x03
    3af2:	8b 81       	ldd	r24, Y+3	; 0x03
    3af4:	28 2f       	mov	r18, r24
    3af6:	30 e0       	ldi	r19, 0x00	; 0
    3af8:	c9 01       	movw	r24, r18
    3afa:	88 0f       	add	r24, r24
    3afc:	99 1f       	adc	r25, r25
    3afe:	88 0f       	add	r24, r24
    3b00:	99 1f       	adc	r25, r25
    3b02:	88 0f       	add	r24, r24
    3b04:	99 1f       	adc	r25, r25
    3b06:	82 0f       	add	r24, r18
    3b08:	93 1f       	adc	r25, r19
    3b0a:	fc 01       	movw	r30, r24
    3b0c:	eb 57       	subi	r30, 0x7B	; 123
    3b0e:	fb 4f       	sbci	r31, 0xFB	; 251
    3b10:	80 81       	ld	r24, Z
    3b12:	88 23       	and	r24, r24
    3b14:	59 f3       	breq	.-42     	; 0x3aec <vTaskSwitchContext+0x28>
    3b16:	8b 81       	ldd	r24, Y+3	; 0x03
    3b18:	28 2f       	mov	r18, r24
    3b1a:	30 e0       	ldi	r19, 0x00	; 0
    3b1c:	c9 01       	movw	r24, r18
    3b1e:	88 0f       	add	r24, r24
    3b20:	99 1f       	adc	r25, r25
    3b22:	88 0f       	add	r24, r24
    3b24:	99 1f       	adc	r25, r25
    3b26:	88 0f       	add	r24, r24
    3b28:	99 1f       	adc	r25, r25
    3b2a:	82 0f       	add	r24, r18
    3b2c:	93 1f       	adc	r25, r19
    3b2e:	8b 57       	subi	r24, 0x7B	; 123
    3b30:	9b 4f       	sbci	r25, 0xFB	; 251
    3b32:	9a 83       	std	Y+2, r25	; 0x02
    3b34:	89 83       	std	Y+1, r24	; 0x01
    3b36:	e9 81       	ldd	r30, Y+1	; 0x01
    3b38:	fa 81       	ldd	r31, Y+2	; 0x02
    3b3a:	01 80       	ldd	r0, Z+1	; 0x01
    3b3c:	f2 81       	ldd	r31, Z+2	; 0x02
    3b3e:	e0 2d       	mov	r30, r0
    3b40:	82 81       	ldd	r24, Z+2	; 0x02
    3b42:	93 81       	ldd	r25, Z+3	; 0x03
    3b44:	e9 81       	ldd	r30, Y+1	; 0x01
    3b46:	fa 81       	ldd	r31, Y+2	; 0x02
    3b48:	92 83       	std	Z+2, r25	; 0x02
    3b4a:	81 83       	std	Z+1, r24	; 0x01
    3b4c:	e9 81       	ldd	r30, Y+1	; 0x01
    3b4e:	fa 81       	ldd	r31, Y+2	; 0x02
    3b50:	21 81       	ldd	r18, Z+1	; 0x01
    3b52:	32 81       	ldd	r19, Z+2	; 0x02
    3b54:	89 81       	ldd	r24, Y+1	; 0x01
    3b56:	9a 81       	ldd	r25, Y+2	; 0x02
    3b58:	03 96       	adiw	r24, 0x03	; 3
    3b5a:	28 17       	cp	r18, r24
    3b5c:	39 07       	cpc	r19, r25
    3b5e:	59 f4       	brne	.+22     	; 0x3b76 <vTaskSwitchContext+0xb2>
    3b60:	e9 81       	ldd	r30, Y+1	; 0x01
    3b62:	fa 81       	ldd	r31, Y+2	; 0x02
    3b64:	01 80       	ldd	r0, Z+1	; 0x01
    3b66:	f2 81       	ldd	r31, Z+2	; 0x02
    3b68:	e0 2d       	mov	r30, r0
    3b6a:	82 81       	ldd	r24, Z+2	; 0x02
    3b6c:	93 81       	ldd	r25, Z+3	; 0x03
    3b6e:	e9 81       	ldd	r30, Y+1	; 0x01
    3b70:	fa 81       	ldd	r31, Y+2	; 0x02
    3b72:	92 83       	std	Z+2, r25	; 0x02
    3b74:	81 83       	std	Z+1, r24	; 0x01
    3b76:	e9 81       	ldd	r30, Y+1	; 0x01
    3b78:	fa 81       	ldd	r31, Y+2	; 0x02
    3b7a:	01 80       	ldd	r0, Z+1	; 0x01
    3b7c:	f2 81       	ldd	r31, Z+2	; 0x02
    3b7e:	e0 2d       	mov	r30, r0
    3b80:	86 81       	ldd	r24, Z+6	; 0x06
    3b82:	97 81       	ldd	r25, Z+7	; 0x07
    3b84:	90 93 76 04 	sts	0x0476, r25
    3b88:	80 93 75 04 	sts	0x0475, r24
    3b8c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b8e:	80 93 7a 04 	sts	0x047A, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3b92:	0f 90       	pop	r0
    3b94:	0f 90       	pop	r0
    3b96:	0f 90       	pop	r0
    3b98:	cf 91       	pop	r28
    3b9a:	df 91       	pop	r29
    3b9c:	08 95       	ret

00003b9e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3b9e:	df 93       	push	r29
    3ba0:	cf 93       	push	r28
    3ba2:	00 d0       	rcall	.+0      	; 0x3ba4 <vTaskPlaceOnEventList+0x6>
    3ba4:	00 d0       	rcall	.+0      	; 0x3ba6 <vTaskPlaceOnEventList+0x8>
    3ba6:	cd b7       	in	r28, 0x3d	; 61
    3ba8:	de b7       	in	r29, 0x3e	; 62
    3baa:	9a 83       	std	Y+2, r25	; 0x02
    3bac:	89 83       	std	Y+1, r24	; 0x01
    3bae:	7c 83       	std	Y+4, r23	; 0x04
    3bb0:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3bb2:	80 91 75 04 	lds	r24, 0x0475
    3bb6:	90 91 76 04 	lds	r25, 0x0476
    3bba:	9c 01       	movw	r18, r24
    3bbc:	24 5f       	subi	r18, 0xF4	; 244
    3bbe:	3f 4f       	sbci	r19, 0xFF	; 255
    3bc0:	89 81       	ldd	r24, Y+1	; 0x01
    3bc2:	9a 81       	ldd	r25, Y+2	; 0x02
    3bc4:	b9 01       	movw	r22, r18
    3bc6:	0e 94 55 0e 	call	0x1caa	; 0x1caa <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3bca:	8b 81       	ldd	r24, Y+3	; 0x03
    3bcc:	9c 81       	ldd	r25, Y+4	; 0x04
    3bce:	61 e0       	ldi	r22, 0x01	; 1
    3bd0:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <prvAddCurrentTaskToDelayedList>
}
    3bd4:	0f 90       	pop	r0
    3bd6:	0f 90       	pop	r0
    3bd8:	0f 90       	pop	r0
    3bda:	0f 90       	pop	r0
    3bdc:	cf 91       	pop	r28
    3bde:	df 91       	pop	r29
    3be0:	08 95       	ret

00003be2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3be2:	df 93       	push	r29
    3be4:	cf 93       	push	r28
    3be6:	00 d0       	rcall	.+0      	; 0x3be8 <vTaskPlaceOnUnorderedEventList+0x6>
    3be8:	00 d0       	rcall	.+0      	; 0x3bea <vTaskPlaceOnUnorderedEventList+0x8>
    3bea:	00 d0       	rcall	.+0      	; 0x3bec <vTaskPlaceOnUnorderedEventList+0xa>
    3bec:	cd b7       	in	r28, 0x3d	; 61
    3bee:	de b7       	in	r29, 0x3e	; 62
    3bf0:	9a 83       	std	Y+2, r25	; 0x02
    3bf2:	89 83       	std	Y+1, r24	; 0x01
    3bf4:	7c 83       	std	Y+4, r23	; 0x04
    3bf6:	6b 83       	std	Y+3, r22	; 0x03
    3bf8:	5e 83       	std	Y+6, r21	; 0x06
    3bfa:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3bfc:	e0 91 75 04 	lds	r30, 0x0475
    3c00:	f0 91 76 04 	lds	r31, 0x0476
    3c04:	8b 81       	ldd	r24, Y+3	; 0x03
    3c06:	9c 81       	ldd	r25, Y+4	; 0x04
    3c08:	90 68       	ori	r25, 0x80	; 128
    3c0a:	95 87       	std	Z+13, r25	; 0x0d
    3c0c:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3c0e:	80 91 75 04 	lds	r24, 0x0475
    3c12:	90 91 76 04 	lds	r25, 0x0476
    3c16:	9c 01       	movw	r18, r24
    3c18:	24 5f       	subi	r18, 0xF4	; 244
    3c1a:	3f 4f       	sbci	r19, 0xFF	; 255
    3c1c:	89 81       	ldd	r24, Y+1	; 0x01
    3c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c20:	b9 01       	movw	r22, r18
    3c22:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3c26:	8d 81       	ldd	r24, Y+5	; 0x05
    3c28:	9e 81       	ldd	r25, Y+6	; 0x06
    3c2a:	61 e0       	ldi	r22, 0x01	; 1
    3c2c:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <prvAddCurrentTaskToDelayedList>
}
    3c30:	26 96       	adiw	r28, 0x06	; 6
    3c32:	0f b6       	in	r0, 0x3f	; 63
    3c34:	f8 94       	cli
    3c36:	de bf       	out	0x3e, r29	; 62
    3c38:	0f be       	out	0x3f, r0	; 63
    3c3a:	cd bf       	out	0x3d, r28	; 61
    3c3c:	cf 91       	pop	r28
    3c3e:	df 91       	pop	r29
    3c40:	08 95       	ret

00003c42 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3c42:	df 93       	push	r29
    3c44:	cf 93       	push	r28
    3c46:	00 d0       	rcall	.+0      	; 0x3c48 <xTaskRemoveFromEventList+0x6>
    3c48:	00 d0       	rcall	.+0      	; 0x3c4a <xTaskRemoveFromEventList+0x8>
    3c4a:	0f 92       	push	r0
    3c4c:	cd b7       	in	r28, 0x3d	; 61
    3c4e:	de b7       	in	r29, 0x3e	; 62
    3c50:	9d 83       	std	Y+5, r25	; 0x05
    3c52:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3c54:	ec 81       	ldd	r30, Y+4	; 0x04
    3c56:	fd 81       	ldd	r31, Y+5	; 0x05
    3c58:	05 80       	ldd	r0, Z+5	; 0x05
    3c5a:	f6 81       	ldd	r31, Z+6	; 0x06
    3c5c:	e0 2d       	mov	r30, r0
    3c5e:	86 81       	ldd	r24, Z+6	; 0x06
    3c60:	97 81       	ldd	r25, Z+7	; 0x07
    3c62:	9b 83       	std	Y+3, r25	; 0x03
    3c64:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3c66:	8a 81       	ldd	r24, Y+2	; 0x02
    3c68:	9b 81       	ldd	r25, Y+3	; 0x03
    3c6a:	0c 96       	adiw	r24, 0x0c	; 12
    3c6c:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3c70:	80 91 84 04 	lds	r24, 0x0484
    3c74:	88 23       	and	r24, r24
    3c76:	61 f5       	brne	.+88     	; 0x3cd0 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3c78:	8a 81       	ldd	r24, Y+2	; 0x02
    3c7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c7c:	02 96       	adiw	r24, 0x02	; 2
    3c7e:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3c82:	ea 81       	ldd	r30, Y+2	; 0x02
    3c84:	fb 81       	ldd	r31, Y+3	; 0x03
    3c86:	96 89       	ldd	r25, Z+22	; 0x16
    3c88:	80 91 7a 04 	lds	r24, 0x047A
    3c8c:	89 17       	cp	r24, r25
    3c8e:	28 f4       	brcc	.+10     	; 0x3c9a <xTaskRemoveFromEventList+0x58>
    3c90:	ea 81       	ldd	r30, Y+2	; 0x02
    3c92:	fb 81       	ldd	r31, Y+3	; 0x03
    3c94:	86 89       	ldd	r24, Z+22	; 0x16
    3c96:	80 93 7a 04 	sts	0x047A, r24
    3c9a:	ea 81       	ldd	r30, Y+2	; 0x02
    3c9c:	fb 81       	ldd	r31, Y+3	; 0x03
    3c9e:	86 89       	ldd	r24, Z+22	; 0x16
    3ca0:	28 2f       	mov	r18, r24
    3ca2:	30 e0       	ldi	r19, 0x00	; 0
    3ca4:	c9 01       	movw	r24, r18
    3ca6:	88 0f       	add	r24, r24
    3ca8:	99 1f       	adc	r25, r25
    3caa:	88 0f       	add	r24, r24
    3cac:	99 1f       	adc	r25, r25
    3cae:	88 0f       	add	r24, r24
    3cb0:	99 1f       	adc	r25, r25
    3cb2:	82 0f       	add	r24, r18
    3cb4:	93 1f       	adc	r25, r19
    3cb6:	ac 01       	movw	r20, r24
    3cb8:	4b 57       	subi	r20, 0x7B	; 123
    3cba:	5b 4f       	sbci	r21, 0xFB	; 251
    3cbc:	8a 81       	ldd	r24, Y+2	; 0x02
    3cbe:	9b 81       	ldd	r25, Y+3	; 0x03
    3cc0:	9c 01       	movw	r18, r24
    3cc2:	2e 5f       	subi	r18, 0xFE	; 254
    3cc4:	3f 4f       	sbci	r19, 0xFF	; 255
    3cc6:	ca 01       	movw	r24, r20
    3cc8:	b9 01       	movw	r22, r18
    3cca:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>
    3cce:	0a c0       	rjmp	.+20     	; 0x3ce4 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3cd0:	8a 81       	ldd	r24, Y+2	; 0x02
    3cd2:	9b 81       	ldd	r25, Y+3	; 0x03
    3cd4:	9c 01       	movw	r18, r24
    3cd6:	24 5f       	subi	r18, 0xF4	; 244
    3cd8:	3f 4f       	sbci	r19, 0xFF	; 255
    3cda:	8f eb       	ldi	r24, 0xBF	; 191
    3cdc:	94 e0       	ldi	r25, 0x04	; 4
    3cde:	b9 01       	movw	r22, r18
    3ce0:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3ce4:	ea 81       	ldd	r30, Y+2	; 0x02
    3ce6:	fb 81       	ldd	r31, Y+3	; 0x03
    3ce8:	96 89       	ldd	r25, Z+22	; 0x16
    3cea:	e0 91 75 04 	lds	r30, 0x0475
    3cee:	f0 91 76 04 	lds	r31, 0x0476
    3cf2:	86 89       	ldd	r24, Z+22	; 0x16
    3cf4:	89 17       	cp	r24, r25
    3cf6:	30 f4       	brcc	.+12     	; 0x3d04 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3cf8:	81 e0       	ldi	r24, 0x01	; 1
    3cfa:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3cfc:	81 e0       	ldi	r24, 0x01	; 1
    3cfe:	80 93 7d 04 	sts	0x047D, r24
    3d02:	01 c0       	rjmp	.+2      	; 0x3d06 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3d04:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3d06:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d08:	0f 90       	pop	r0
    3d0a:	0f 90       	pop	r0
    3d0c:	0f 90       	pop	r0
    3d0e:	0f 90       	pop	r0
    3d10:	0f 90       	pop	r0
    3d12:	cf 91       	pop	r28
    3d14:	df 91       	pop	r29
    3d16:	08 95       	ret

00003d18 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3d18:	df 93       	push	r29
    3d1a:	cf 93       	push	r28
    3d1c:	00 d0       	rcall	.+0      	; 0x3d1e <vTaskRemoveFromUnorderedEventList+0x6>
    3d1e:	00 d0       	rcall	.+0      	; 0x3d20 <vTaskRemoveFromUnorderedEventList+0x8>
    3d20:	00 d0       	rcall	.+0      	; 0x3d22 <vTaskRemoveFromUnorderedEventList+0xa>
    3d22:	cd b7       	in	r28, 0x3d	; 61
    3d24:	de b7       	in	r29, 0x3e	; 62
    3d26:	9c 83       	std	Y+4, r25	; 0x04
    3d28:	8b 83       	std	Y+3, r24	; 0x03
    3d2a:	7e 83       	std	Y+6, r23	; 0x06
    3d2c:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3d2e:	8d 81       	ldd	r24, Y+5	; 0x05
    3d30:	9e 81       	ldd	r25, Y+6	; 0x06
    3d32:	90 68       	ori	r25, 0x80	; 128
    3d34:	eb 81       	ldd	r30, Y+3	; 0x03
    3d36:	fc 81       	ldd	r31, Y+4	; 0x04
    3d38:	91 83       	std	Z+1, r25	; 0x01
    3d3a:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d3c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d3e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d40:	86 81       	ldd	r24, Z+6	; 0x06
    3d42:	97 81       	ldd	r25, Z+7	; 0x07
    3d44:	9a 83       	std	Y+2, r25	; 0x02
    3d46:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3d48:	8b 81       	ldd	r24, Y+3	; 0x03
    3d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d4c:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3d50:	89 81       	ldd	r24, Y+1	; 0x01
    3d52:	9a 81       	ldd	r25, Y+2	; 0x02
    3d54:	02 96       	adiw	r24, 0x02	; 2
    3d56:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3d5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d5e:	96 89       	ldd	r25, Z+22	; 0x16
    3d60:	80 91 7a 04 	lds	r24, 0x047A
    3d64:	89 17       	cp	r24, r25
    3d66:	28 f4       	brcc	.+10     	; 0x3d72 <vTaskRemoveFromUnorderedEventList+0x5a>
    3d68:	e9 81       	ldd	r30, Y+1	; 0x01
    3d6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d6c:	86 89       	ldd	r24, Z+22	; 0x16
    3d6e:	80 93 7a 04 	sts	0x047A, r24
    3d72:	e9 81       	ldd	r30, Y+1	; 0x01
    3d74:	fa 81       	ldd	r31, Y+2	; 0x02
    3d76:	86 89       	ldd	r24, Z+22	; 0x16
    3d78:	28 2f       	mov	r18, r24
    3d7a:	30 e0       	ldi	r19, 0x00	; 0
    3d7c:	c9 01       	movw	r24, r18
    3d7e:	88 0f       	add	r24, r24
    3d80:	99 1f       	adc	r25, r25
    3d82:	88 0f       	add	r24, r24
    3d84:	99 1f       	adc	r25, r25
    3d86:	88 0f       	add	r24, r24
    3d88:	99 1f       	adc	r25, r25
    3d8a:	82 0f       	add	r24, r18
    3d8c:	93 1f       	adc	r25, r19
    3d8e:	ac 01       	movw	r20, r24
    3d90:	4b 57       	subi	r20, 0x7B	; 123
    3d92:	5b 4f       	sbci	r21, 0xFB	; 251
    3d94:	89 81       	ldd	r24, Y+1	; 0x01
    3d96:	9a 81       	ldd	r25, Y+2	; 0x02
    3d98:	9c 01       	movw	r18, r24
    3d9a:	2e 5f       	subi	r18, 0xFE	; 254
    3d9c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d9e:	ca 01       	movw	r24, r20
    3da0:	b9 01       	movw	r22, r18
    3da2:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3da6:	e9 81       	ldd	r30, Y+1	; 0x01
    3da8:	fa 81       	ldd	r31, Y+2	; 0x02
    3daa:	96 89       	ldd	r25, Z+22	; 0x16
    3dac:	e0 91 75 04 	lds	r30, 0x0475
    3db0:	f0 91 76 04 	lds	r31, 0x0476
    3db4:	86 89       	ldd	r24, Z+22	; 0x16
    3db6:	89 17       	cp	r24, r25
    3db8:	18 f4       	brcc	.+6      	; 0x3dc0 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3dba:	81 e0       	ldi	r24, 0x01	; 1
    3dbc:	80 93 7d 04 	sts	0x047D, r24
	}
}
    3dc0:	26 96       	adiw	r28, 0x06	; 6
    3dc2:	0f b6       	in	r0, 0x3f	; 63
    3dc4:	f8 94       	cli
    3dc6:	de bf       	out	0x3e, r29	; 62
    3dc8:	0f be       	out	0x3f, r0	; 63
    3dca:	cd bf       	out	0x3d, r28	; 61
    3dcc:	cf 91       	pop	r28
    3dce:	df 91       	pop	r29
    3dd0:	08 95       	ret

00003dd2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3dd2:	df 93       	push	r29
    3dd4:	cf 93       	push	r28
    3dd6:	00 d0       	rcall	.+0      	; 0x3dd8 <vTaskSetTimeOutState+0x6>
    3dd8:	cd b7       	in	r28, 0x3d	; 61
    3dda:	de b7       	in	r29, 0x3e	; 62
    3ddc:	9a 83       	std	Y+2, r25	; 0x02
    3dde:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3de0:	0f b6       	in	r0, 0x3f	; 63
    3de2:	f8 94       	cli
    3de4:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3de6:	80 91 7e 04 	lds	r24, 0x047E
    3dea:	e9 81       	ldd	r30, Y+1	; 0x01
    3dec:	fa 81       	ldd	r31, Y+2	; 0x02
    3dee:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3df0:	80 91 78 04 	lds	r24, 0x0478
    3df4:	90 91 79 04 	lds	r25, 0x0479
    3df8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dfa:	fa 81       	ldd	r31, Y+2	; 0x02
    3dfc:	92 83       	std	Z+2, r25	; 0x02
    3dfe:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3e00:	0f 90       	pop	r0
    3e02:	0f be       	out	0x3f, r0	; 63
}
    3e04:	0f 90       	pop	r0
    3e06:	0f 90       	pop	r0
    3e08:	cf 91       	pop	r28
    3e0a:	df 91       	pop	r29
    3e0c:	08 95       	ret

00003e0e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3e0e:	df 93       	push	r29
    3e10:	cf 93       	push	r28
    3e12:	00 d0       	rcall	.+0      	; 0x3e14 <vTaskInternalSetTimeOutState+0x6>
    3e14:	cd b7       	in	r28, 0x3d	; 61
    3e16:	de b7       	in	r29, 0x3e	; 62
    3e18:	9a 83       	std	Y+2, r25	; 0x02
    3e1a:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3e1c:	80 91 7e 04 	lds	r24, 0x047E
    3e20:	e9 81       	ldd	r30, Y+1	; 0x01
    3e22:	fa 81       	ldd	r31, Y+2	; 0x02
    3e24:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3e26:	80 91 78 04 	lds	r24, 0x0478
    3e2a:	90 91 79 04 	lds	r25, 0x0479
    3e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e30:	fa 81       	ldd	r31, Y+2	; 0x02
    3e32:	92 83       	std	Z+2, r25	; 0x02
    3e34:	81 83       	std	Z+1, r24	; 0x01
}
    3e36:	0f 90       	pop	r0
    3e38:	0f 90       	pop	r0
    3e3a:	cf 91       	pop	r28
    3e3c:	df 91       	pop	r29
    3e3e:	08 95       	ret

00003e40 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3e40:	df 93       	push	r29
    3e42:	cf 93       	push	r28
    3e44:	cd b7       	in	r28, 0x3d	; 61
    3e46:	de b7       	in	r29, 0x3e	; 62
    3e48:	29 97       	sbiw	r28, 0x09	; 9
    3e4a:	0f b6       	in	r0, 0x3f	; 63
    3e4c:	f8 94       	cli
    3e4e:	de bf       	out	0x3e, r29	; 62
    3e50:	0f be       	out	0x3f, r0	; 63
    3e52:	cd bf       	out	0x3d, r28	; 61
    3e54:	9f 83       	std	Y+7, r25	; 0x07
    3e56:	8e 83       	std	Y+6, r24	; 0x06
    3e58:	79 87       	std	Y+9, r23	; 0x09
    3e5a:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3e5c:	0f b6       	in	r0, 0x3f	; 63
    3e5e:	f8 94       	cli
    3e60:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3e62:	80 91 78 04 	lds	r24, 0x0478
    3e66:	90 91 79 04 	lds	r25, 0x0479
    3e6a:	9c 83       	std	Y+4, r25	; 0x04
    3e6c:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3e6e:	ee 81       	ldd	r30, Y+6	; 0x06
    3e70:	ff 81       	ldd	r31, Y+7	; 0x07
    3e72:	21 81       	ldd	r18, Z+1	; 0x01
    3e74:	32 81       	ldd	r19, Z+2	; 0x02
    3e76:	8b 81       	ldd	r24, Y+3	; 0x03
    3e78:	9c 81       	ldd	r25, Y+4	; 0x04
    3e7a:	82 1b       	sub	r24, r18
    3e7c:	93 0b       	sbc	r25, r19
    3e7e:	9a 83       	std	Y+2, r25	; 0x02
    3e80:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3e82:	ee 81       	ldd	r30, Y+6	; 0x06
    3e84:	ff 81       	ldd	r31, Y+7	; 0x07
    3e86:	90 81       	ld	r25, Z
    3e88:	80 91 7e 04 	lds	r24, 0x047E
    3e8c:	98 17       	cp	r25, r24
    3e8e:	61 f0       	breq	.+24     	; 0x3ea8 <xTaskCheckForTimeOut+0x68>
    3e90:	ee 81       	ldd	r30, Y+6	; 0x06
    3e92:	ff 81       	ldd	r31, Y+7	; 0x07
    3e94:	21 81       	ldd	r18, Z+1	; 0x01
    3e96:	32 81       	ldd	r19, Z+2	; 0x02
    3e98:	8b 81       	ldd	r24, Y+3	; 0x03
    3e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3e9c:	82 17       	cp	r24, r18
    3e9e:	93 07       	cpc	r25, r19
    3ea0:	18 f0       	brcs	.+6      	; 0x3ea8 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3ea2:	81 e0       	ldi	r24, 0x01	; 1
    3ea4:	8d 83       	std	Y+5, r24	; 0x05
    3ea6:	23 c0       	rjmp	.+70     	; 0x3eee <xTaskCheckForTimeOut+0xae>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3ea8:	e8 85       	ldd	r30, Y+8	; 0x08
    3eaa:	f9 85       	ldd	r31, Y+9	; 0x09
    3eac:	20 81       	ld	r18, Z
    3eae:	31 81       	ldd	r19, Z+1	; 0x01
    3eb0:	89 81       	ldd	r24, Y+1	; 0x01
    3eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    3eb4:	82 17       	cp	r24, r18
    3eb6:	93 07       	cpc	r25, r19
    3eb8:	a0 f4       	brcc	.+40     	; 0x3ee2 <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3eba:	e8 85       	ldd	r30, Y+8	; 0x08
    3ebc:	f9 85       	ldd	r31, Y+9	; 0x09
    3ebe:	20 81       	ld	r18, Z
    3ec0:	31 81       	ldd	r19, Z+1	; 0x01
    3ec2:	89 81       	ldd	r24, Y+1	; 0x01
    3ec4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ec6:	a9 01       	movw	r20, r18
    3ec8:	48 1b       	sub	r20, r24
    3eca:	59 0b       	sbc	r21, r25
    3ecc:	ca 01       	movw	r24, r20
    3ece:	e8 85       	ldd	r30, Y+8	; 0x08
    3ed0:	f9 85       	ldd	r31, Y+9	; 0x09
    3ed2:	91 83       	std	Z+1, r25	; 0x01
    3ed4:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3ed6:	8e 81       	ldd	r24, Y+6	; 0x06
    3ed8:	9f 81       	ldd	r25, Y+7	; 0x07
    3eda:	0e 94 07 1f 	call	0x3e0e	; 0x3e0e <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3ede:	1d 82       	std	Y+5, r1	; 0x05
    3ee0:	06 c0       	rjmp	.+12     	; 0x3eee <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			*pxTicksToWait = 0;
    3ee2:	e8 85       	ldd	r30, Y+8	; 0x08
    3ee4:	f9 85       	ldd	r31, Y+9	; 0x09
    3ee6:	11 82       	std	Z+1, r1	; 0x01
    3ee8:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    3eea:	81 e0       	ldi	r24, 0x01	; 1
    3eec:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    3eee:	0f 90       	pop	r0
    3ef0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3ef2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3ef4:	29 96       	adiw	r28, 0x09	; 9
    3ef6:	0f b6       	in	r0, 0x3f	; 63
    3ef8:	f8 94       	cli
    3efa:	de bf       	out	0x3e, r29	; 62
    3efc:	0f be       	out	0x3f, r0	; 63
    3efe:	cd bf       	out	0x3d, r28	; 61
    3f00:	cf 91       	pop	r28
    3f02:	df 91       	pop	r29
    3f04:	08 95       	ret

00003f06 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3f06:	df 93       	push	r29
    3f08:	cf 93       	push	r28
    3f0a:	cd b7       	in	r28, 0x3d	; 61
    3f0c:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3f0e:	81 e0       	ldi	r24, 0x01	; 1
    3f10:	80 93 7d 04 	sts	0x047D, r24
}
    3f14:	cf 91       	pop	r28
    3f16:	df 91       	pop	r29
    3f18:	08 95       	ret

00003f1a <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3f1a:	df 93       	push	r29
    3f1c:	cf 93       	push	r28
    3f1e:	00 d0       	rcall	.+0      	; 0x3f20 <prvIdleTask+0x6>
    3f20:	cd b7       	in	r28, 0x3d	; 61
    3f22:	de b7       	in	r29, 0x3e	; 62
    3f24:	9a 83       	std	Y+2, r25	; 0x02
    3f26:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    3f28:	0e 94 d0 1f 	call	0x3fa0	; 0x3fa0 <prvCheckTasksWaitingTermination>
    3f2c:	fd cf       	rjmp	.-6      	; 0x3f28 <prvIdleTask+0xe>

00003f2e <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3f2e:	df 93       	push	r29
    3f30:	cf 93       	push	r28
    3f32:	0f 92       	push	r0
    3f34:	cd b7       	in	r28, 0x3d	; 61
    3f36:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3f38:	19 82       	std	Y+1, r1	; 0x01
    3f3a:	13 c0       	rjmp	.+38     	; 0x3f62 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3f3c:	89 81       	ldd	r24, Y+1	; 0x01
    3f3e:	28 2f       	mov	r18, r24
    3f40:	30 e0       	ldi	r19, 0x00	; 0
    3f42:	c9 01       	movw	r24, r18
    3f44:	88 0f       	add	r24, r24
    3f46:	99 1f       	adc	r25, r25
    3f48:	88 0f       	add	r24, r24
    3f4a:	99 1f       	adc	r25, r25
    3f4c:	88 0f       	add	r24, r24
    3f4e:	99 1f       	adc	r25, r25
    3f50:	82 0f       	add	r24, r18
    3f52:	93 1f       	adc	r25, r19
    3f54:	8b 57       	subi	r24, 0x7B	; 123
    3f56:	9b 4f       	sbci	r25, 0xFB	; 251
    3f58:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3f5c:	89 81       	ldd	r24, Y+1	; 0x01
    3f5e:	8f 5f       	subi	r24, 0xFF	; 255
    3f60:	89 83       	std	Y+1, r24	; 0x01
    3f62:	89 81       	ldd	r24, Y+1	; 0x01
    3f64:	84 30       	cpi	r24, 0x04	; 4
    3f66:	50 f3       	brcs	.-44     	; 0x3f3c <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3f68:	89 ea       	ldi	r24, 0xA9	; 169
    3f6a:	94 e0       	ldi	r25, 0x04	; 4
    3f6c:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3f70:	82 eb       	ldi	r24, 0xB2	; 178
    3f72:	94 e0       	ldi	r25, 0x04	; 4
    3f74:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3f78:	8f eb       	ldi	r24, 0xBF	; 191
    3f7a:	94 e0       	ldi	r25, 0x04	; 4
    3f7c:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3f80:	89 ea       	ldi	r24, 0xA9	; 169
    3f82:	94 e0       	ldi	r25, 0x04	; 4
    3f84:	90 93 bc 04 	sts	0x04BC, r25
    3f88:	80 93 bb 04 	sts	0x04BB, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3f8c:	82 eb       	ldi	r24, 0xB2	; 178
    3f8e:	94 e0       	ldi	r25, 0x04	; 4
    3f90:	90 93 be 04 	sts	0x04BE, r25
    3f94:	80 93 bd 04 	sts	0x04BD, r24
}
    3f98:	0f 90       	pop	r0
    3f9a:	cf 91       	pop	r28
    3f9c:	df 91       	pop	r29
    3f9e:	08 95       	ret

00003fa0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3fa0:	df 93       	push	r29
    3fa2:	cf 93       	push	r28
    3fa4:	cd b7       	in	r28, 0x3d	; 61
    3fa6:	de b7       	in	r29, 0x3e	; 62

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    3fa8:	cf 91       	pop	r28
    3faa:	df 91       	pop	r29
    3fac:	08 95       	ret

00003fae <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3fae:	df 93       	push	r29
    3fb0:	cf 93       	push	r28
    3fb2:	00 d0       	rcall	.+0      	; 0x3fb4 <prvResetNextTaskUnblockTime+0x6>
    3fb4:	cd b7       	in	r28, 0x3d	; 61
    3fb6:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3fb8:	e0 91 bb 04 	lds	r30, 0x04BB
    3fbc:	f0 91 bc 04 	lds	r31, 0x04BC
    3fc0:	80 81       	ld	r24, Z
    3fc2:	88 23       	and	r24, r24
    3fc4:	39 f4       	brne	.+14     	; 0x3fd4 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3fc6:	8f ef       	ldi	r24, 0xFF	; 255
    3fc8:	9f ef       	ldi	r25, 0xFF	; 255
    3fca:	90 93 81 04 	sts	0x0481, r25
    3fce:	80 93 80 04 	sts	0x0480, r24
    3fd2:	13 c0       	rjmp	.+38     	; 0x3ffa <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3fd4:	e0 91 bb 04 	lds	r30, 0x04BB
    3fd8:	f0 91 bc 04 	lds	r31, 0x04BC
    3fdc:	05 80       	ldd	r0, Z+5	; 0x05
    3fde:	f6 81       	ldd	r31, Z+6	; 0x06
    3fe0:	e0 2d       	mov	r30, r0
    3fe2:	86 81       	ldd	r24, Z+6	; 0x06
    3fe4:	97 81       	ldd	r25, Z+7	; 0x07
    3fe6:	9a 83       	std	Y+2, r25	; 0x02
    3fe8:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3fea:	e9 81       	ldd	r30, Y+1	; 0x01
    3fec:	fa 81       	ldd	r31, Y+2	; 0x02
    3fee:	82 81       	ldd	r24, Z+2	; 0x02
    3ff0:	93 81       	ldd	r25, Z+3	; 0x03
    3ff2:	90 93 81 04 	sts	0x0481, r25
    3ff6:	80 93 80 04 	sts	0x0480, r24
	}
}
    3ffa:	0f 90       	pop	r0
    3ffc:	0f 90       	pop	r0
    3ffe:	cf 91       	pop	r28
    4000:	df 91       	pop	r29
    4002:	08 95       	ret

00004004 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4004:	df 93       	push	r29
    4006:	cf 93       	push	r28
    4008:	00 d0       	rcall	.+0      	; 0x400a <uxTaskResetEventItemValue+0x6>
    400a:	cd b7       	in	r28, 0x3d	; 61
    400c:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    400e:	e0 91 75 04 	lds	r30, 0x0475
    4012:	f0 91 76 04 	lds	r31, 0x0476
    4016:	84 85       	ldd	r24, Z+12	; 0x0c
    4018:	95 85       	ldd	r25, Z+13	; 0x0d
    401a:	9a 83       	std	Y+2, r25	; 0x02
    401c:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    401e:	a0 91 75 04 	lds	r26, 0x0475
    4022:	b0 91 76 04 	lds	r27, 0x0476
    4026:	e0 91 75 04 	lds	r30, 0x0475
    402a:	f0 91 76 04 	lds	r31, 0x0476
    402e:	86 89       	ldd	r24, Z+22	; 0x16
    4030:	28 2f       	mov	r18, r24
    4032:	30 e0       	ldi	r19, 0x00	; 0
    4034:	84 e0       	ldi	r24, 0x04	; 4
    4036:	90 e0       	ldi	r25, 0x00	; 0
    4038:	82 1b       	sub	r24, r18
    403a:	93 0b       	sbc	r25, r19
    403c:	1d 96       	adiw	r26, 0x0d	; 13
    403e:	9c 93       	st	X, r25
    4040:	8e 93       	st	-X, r24
    4042:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4044:	89 81       	ldd	r24, Y+1	; 0x01
    4046:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4048:	0f 90       	pop	r0
    404a:	0f 90       	pop	r0
    404c:	cf 91       	pop	r28
    404e:	df 91       	pop	r29
    4050:	08 95       	ret

00004052 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4052:	df 93       	push	r29
    4054:	cf 93       	push	r28
    4056:	cd b7       	in	r28, 0x3d	; 61
    4058:	de b7       	in	r29, 0x3e	; 62
    405a:	27 97       	sbiw	r28, 0x07	; 7
    405c:	0f b6       	in	r0, 0x3f	; 63
    405e:	f8 94       	cli
    4060:	de bf       	out	0x3e, r29	; 62
    4062:	0f be       	out	0x3f, r0	; 63
    4064:	cd bf       	out	0x3d, r28	; 61
    4066:	8d 83       	std	Y+5, r24	; 0x05
    4068:	7f 83       	std	Y+7, r23	; 0x07
    406a:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    406c:	0f b6       	in	r0, 0x3f	; 63
    406e:	f8 94       	cli
    4070:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4072:	e0 91 75 04 	lds	r30, 0x0475
    4076:	f0 91 76 04 	lds	r31, 0x0476
    407a:	81 a1       	ldd	r24, Z+33	; 0x21
    407c:	92 a1       	ldd	r25, Z+34	; 0x22
    407e:	a3 a1       	ldd	r26, Z+35	; 0x23
    4080:	b4 a1       	ldd	r27, Z+36	; 0x24
    4082:	00 97       	sbiw	r24, 0x00	; 0
    4084:	a1 05       	cpc	r26, r1
    4086:	b1 05       	cpc	r27, r1
    4088:	89 f4       	brne	.+34     	; 0x40ac <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    408a:	e0 91 75 04 	lds	r30, 0x0475
    408e:	f0 91 76 04 	lds	r31, 0x0476
    4092:	81 e0       	ldi	r24, 0x01	; 1
    4094:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    4096:	8e 81       	ldd	r24, Y+6	; 0x06
    4098:	9f 81       	ldd	r25, Y+7	; 0x07
    409a:	00 97       	sbiw	r24, 0x00	; 0
    409c:	39 f0       	breq	.+14     	; 0x40ac <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    409e:	8e 81       	ldd	r24, Y+6	; 0x06
    40a0:	9f 81       	ldd	r25, Y+7	; 0x07
    40a2:	61 e0       	ldi	r22, 0x01	; 1
    40a4:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    40a8:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    40ac:	0f 90       	pop	r0
    40ae:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    40b0:	0f b6       	in	r0, 0x3f	; 63
    40b2:	f8 94       	cli
    40b4:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    40b6:	e0 91 75 04 	lds	r30, 0x0475
    40ba:	f0 91 76 04 	lds	r31, 0x0476
    40be:	81 a1       	ldd	r24, Z+33	; 0x21
    40c0:	92 a1       	ldd	r25, Z+34	; 0x22
    40c2:	a3 a1       	ldd	r26, Z+35	; 0x23
    40c4:	b4 a1       	ldd	r27, Z+36	; 0x24
    40c6:	89 83       	std	Y+1, r24	; 0x01
    40c8:	9a 83       	std	Y+2, r25	; 0x02
    40ca:	ab 83       	std	Y+3, r26	; 0x03
    40cc:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    40ce:	89 81       	ldd	r24, Y+1	; 0x01
    40d0:	9a 81       	ldd	r25, Y+2	; 0x02
    40d2:	ab 81       	ldd	r26, Y+3	; 0x03
    40d4:	bc 81       	ldd	r27, Y+4	; 0x04
    40d6:	00 97       	sbiw	r24, 0x00	; 0
    40d8:	a1 05       	cpc	r26, r1
    40da:	b1 05       	cpc	r27, r1
    40dc:	d9 f0       	breq	.+54     	; 0x4114 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    40de:	8d 81       	ldd	r24, Y+5	; 0x05
    40e0:	88 23       	and	r24, r24
    40e2:	49 f0       	breq	.+18     	; 0x40f6 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    40e4:	e0 91 75 04 	lds	r30, 0x0475
    40e8:	f0 91 76 04 	lds	r31, 0x0476
    40ec:	11 a2       	std	Z+33, r1	; 0x21
    40ee:	12 a2       	std	Z+34, r1	; 0x22
    40f0:	13 a2       	std	Z+35, r1	; 0x23
    40f2:	14 a2       	std	Z+36, r1	; 0x24
    40f4:	0f c0       	rjmp	.+30     	; 0x4114 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    40f6:	e0 91 75 04 	lds	r30, 0x0475
    40fa:	f0 91 76 04 	lds	r31, 0x0476
    40fe:	89 81       	ldd	r24, Y+1	; 0x01
    4100:	9a 81       	ldd	r25, Y+2	; 0x02
    4102:	ab 81       	ldd	r26, Y+3	; 0x03
    4104:	bc 81       	ldd	r27, Y+4	; 0x04
    4106:	01 97       	sbiw	r24, 0x01	; 1
    4108:	a1 09       	sbc	r26, r1
    410a:	b1 09       	sbc	r27, r1
    410c:	81 a3       	std	Z+33, r24	; 0x21
    410e:	92 a3       	std	Z+34, r25	; 0x22
    4110:	a3 a3       	std	Z+35, r26	; 0x23
    4112:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4114:	e0 91 75 04 	lds	r30, 0x0475
    4118:	f0 91 76 04 	lds	r31, 0x0476
    411c:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    411e:	0f 90       	pop	r0
    4120:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4122:	89 81       	ldd	r24, Y+1	; 0x01
    4124:	9a 81       	ldd	r25, Y+2	; 0x02
    4126:	ab 81       	ldd	r26, Y+3	; 0x03
    4128:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    412a:	bc 01       	movw	r22, r24
    412c:	cd 01       	movw	r24, r26
    412e:	27 96       	adiw	r28, 0x07	; 7
    4130:	0f b6       	in	r0, 0x3f	; 63
    4132:	f8 94       	cli
    4134:	de bf       	out	0x3e, r29	; 62
    4136:	0f be       	out	0x3f, r0	; 63
    4138:	cd bf       	out	0x3d, r28	; 61
    413a:	cf 91       	pop	r28
    413c:	df 91       	pop	r29
    413e:	08 95       	ret

00004140 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4140:	ef 92       	push	r14
    4142:	ff 92       	push	r15
    4144:	0f 93       	push	r16
    4146:	1f 93       	push	r17
    4148:	df 93       	push	r29
    414a:	cf 93       	push	r28
    414c:	cd b7       	in	r28, 0x3d	; 61
    414e:	de b7       	in	r29, 0x3e	; 62
    4150:	2d 97       	sbiw	r28, 0x0d	; 13
    4152:	0f b6       	in	r0, 0x3f	; 63
    4154:	f8 94       	cli
    4156:	de bf       	out	0x3e, r29	; 62
    4158:	0f be       	out	0x3f, r0	; 63
    415a:	cd bf       	out	0x3d, r28	; 61
    415c:	6a 83       	std	Y+2, r22	; 0x02
    415e:	7b 83       	std	Y+3, r23	; 0x03
    4160:	8c 83       	std	Y+4, r24	; 0x04
    4162:	9d 83       	std	Y+5, r25	; 0x05
    4164:	2e 83       	std	Y+6, r18	; 0x06
    4166:	3f 83       	std	Y+7, r19	; 0x07
    4168:	48 87       	std	Y+8, r20	; 0x08
    416a:	59 87       	std	Y+9, r21	; 0x09
    416c:	1b 87       	std	Y+11, r17	; 0x0b
    416e:	0a 87       	std	Y+10, r16	; 0x0a
    4170:	fd 86       	std	Y+13, r15	; 0x0d
    4172:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4174:	0f b6       	in	r0, 0x3f	; 63
    4176:	f8 94       	cli
    4178:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    417a:	e0 91 75 04 	lds	r30, 0x0475
    417e:	f0 91 76 04 	lds	r31, 0x0476
    4182:	85 a1       	ldd	r24, Z+37	; 0x25
    4184:	82 30       	cpi	r24, 0x02	; 2
    4186:	49 f1       	breq	.+82     	; 0x41da <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4188:	e0 91 75 04 	lds	r30, 0x0475
    418c:	f0 91 76 04 	lds	r31, 0x0476
    4190:	21 a1       	ldd	r18, Z+33	; 0x21
    4192:	32 a1       	ldd	r19, Z+34	; 0x22
    4194:	43 a1       	ldd	r20, Z+35	; 0x23
    4196:	54 a1       	ldd	r21, Z+36	; 0x24
    4198:	8a 81       	ldd	r24, Y+2	; 0x02
    419a:	9b 81       	ldd	r25, Y+3	; 0x03
    419c:	ac 81       	ldd	r26, Y+4	; 0x04
    419e:	bd 81       	ldd	r27, Y+5	; 0x05
    41a0:	80 95       	com	r24
    41a2:	90 95       	com	r25
    41a4:	a0 95       	com	r26
    41a6:	b0 95       	com	r27
    41a8:	82 23       	and	r24, r18
    41aa:	93 23       	and	r25, r19
    41ac:	a4 23       	and	r26, r20
    41ae:	b5 23       	and	r27, r21
    41b0:	81 a3       	std	Z+33, r24	; 0x21
    41b2:	92 a3       	std	Z+34, r25	; 0x22
    41b4:	a3 a3       	std	Z+35, r26	; 0x23
    41b6:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    41b8:	e0 91 75 04 	lds	r30, 0x0475
    41bc:	f0 91 76 04 	lds	r31, 0x0476
    41c0:	81 e0       	ldi	r24, 0x01	; 1
    41c2:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    41c4:	8c 85       	ldd	r24, Y+12	; 0x0c
    41c6:	9d 85       	ldd	r25, Y+13	; 0x0d
    41c8:	00 97       	sbiw	r24, 0x00	; 0
    41ca:	39 f0       	breq	.+14     	; 0x41da <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    41cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    41ce:	9d 85       	ldd	r25, Y+13	; 0x0d
    41d0:	61 e0       	ldi	r22, 0x01	; 1
    41d2:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    41d6:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    41da:	0f 90       	pop	r0
    41dc:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    41de:	0f b6       	in	r0, 0x3f	; 63
    41e0:	f8 94       	cli
    41e2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    41e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    41e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    41e8:	00 97       	sbiw	r24, 0x00	; 0
    41ea:	71 f0       	breq	.+28     	; 0x4208 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    41ec:	e0 91 75 04 	lds	r30, 0x0475
    41f0:	f0 91 76 04 	lds	r31, 0x0476
    41f4:	81 a1       	ldd	r24, Z+33	; 0x21
    41f6:	92 a1       	ldd	r25, Z+34	; 0x22
    41f8:	a3 a1       	ldd	r26, Z+35	; 0x23
    41fa:	b4 a1       	ldd	r27, Z+36	; 0x24
    41fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    41fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    4200:	80 83       	st	Z, r24
    4202:	91 83       	std	Z+1, r25	; 0x01
    4204:	a2 83       	std	Z+2, r26	; 0x02
    4206:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4208:	e0 91 75 04 	lds	r30, 0x0475
    420c:	f0 91 76 04 	lds	r31, 0x0476
    4210:	85 a1       	ldd	r24, Z+37	; 0x25
    4212:	82 30       	cpi	r24, 0x02	; 2
    4214:	11 f0       	breq	.+4      	; 0x421a <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4216:	19 82       	std	Y+1, r1	; 0x01
    4218:	1a c0       	rjmp	.+52     	; 0x424e <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    421a:	e0 91 75 04 	lds	r30, 0x0475
    421e:	f0 91 76 04 	lds	r31, 0x0476
    4222:	21 a1       	ldd	r18, Z+33	; 0x21
    4224:	32 a1       	ldd	r19, Z+34	; 0x22
    4226:	43 a1       	ldd	r20, Z+35	; 0x23
    4228:	54 a1       	ldd	r21, Z+36	; 0x24
    422a:	8e 81       	ldd	r24, Y+6	; 0x06
    422c:	9f 81       	ldd	r25, Y+7	; 0x07
    422e:	a8 85       	ldd	r26, Y+8	; 0x08
    4230:	b9 85       	ldd	r27, Y+9	; 0x09
    4232:	80 95       	com	r24
    4234:	90 95       	com	r25
    4236:	a0 95       	com	r26
    4238:	b0 95       	com	r27
    423a:	82 23       	and	r24, r18
    423c:	93 23       	and	r25, r19
    423e:	a4 23       	and	r26, r20
    4240:	b5 23       	and	r27, r21
    4242:	81 a3       	std	Z+33, r24	; 0x21
    4244:	92 a3       	std	Z+34, r25	; 0x22
    4246:	a3 a3       	std	Z+35, r26	; 0x23
    4248:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    424a:	81 e0       	ldi	r24, 0x01	; 1
    424c:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    424e:	e0 91 75 04 	lds	r30, 0x0475
    4252:	f0 91 76 04 	lds	r31, 0x0476
    4256:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    4258:	0f 90       	pop	r0
    425a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    425c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    425e:	2d 96       	adiw	r28, 0x0d	; 13
    4260:	0f b6       	in	r0, 0x3f	; 63
    4262:	f8 94       	cli
    4264:	de bf       	out	0x3e, r29	; 62
    4266:	0f be       	out	0x3f, r0	; 63
    4268:	cd bf       	out	0x3d, r28	; 61
    426a:	cf 91       	pop	r28
    426c:	df 91       	pop	r29
    426e:	1f 91       	pop	r17
    4270:	0f 91       	pop	r16
    4272:	ff 90       	pop	r15
    4274:	ef 90       	pop	r14
    4276:	08 95       	ret

00004278 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4278:	0f 93       	push	r16
    427a:	1f 93       	push	r17
    427c:	df 93       	push	r29
    427e:	cf 93       	push	r28
    4280:	cd b7       	in	r28, 0x3d	; 61
    4282:	de b7       	in	r29, 0x3e	; 62
    4284:	2f 97       	sbiw	r28, 0x0f	; 15
    4286:	0f b6       	in	r0, 0x3f	; 63
    4288:	f8 94       	cli
    428a:	de bf       	out	0x3e, r29	; 62
    428c:	0f be       	out	0x3f, r0	; 63
    428e:	cd bf       	out	0x3d, r28	; 61
    4290:	9e 83       	std	Y+6, r25	; 0x06
    4292:	8d 83       	std	Y+5, r24	; 0x05
    4294:	4f 83       	std	Y+7, r20	; 0x07
    4296:	58 87       	std	Y+8, r21	; 0x08
    4298:	69 87       	std	Y+9, r22	; 0x09
    429a:	7a 87       	std	Y+10, r23	; 0x0a
    429c:	2b 87       	std	Y+11, r18	; 0x0b
    429e:	1d 87       	std	Y+13, r17	; 0x0d
    42a0:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    42a2:	81 e0       	ldi	r24, 0x01	; 1
    42a4:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    42a6:	8d 81       	ldd	r24, Y+5	; 0x05
    42a8:	9e 81       	ldd	r25, Y+6	; 0x06
    42aa:	9c 83       	std	Y+4, r25	; 0x04
    42ac:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    42ae:	0f b6       	in	r0, 0x3f	; 63
    42b0:	f8 94       	cli
    42b2:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    42b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    42b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    42b8:	00 97       	sbiw	r24, 0x00	; 0
    42ba:	61 f0       	breq	.+24     	; 0x42d4 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    42bc:	eb 81       	ldd	r30, Y+3	; 0x03
    42be:	fc 81       	ldd	r31, Y+4	; 0x04
    42c0:	81 a1       	ldd	r24, Z+33	; 0x21
    42c2:	92 a1       	ldd	r25, Z+34	; 0x22
    42c4:	a3 a1       	ldd	r26, Z+35	; 0x23
    42c6:	b4 a1       	ldd	r27, Z+36	; 0x24
    42c8:	ec 85       	ldd	r30, Y+12	; 0x0c
    42ca:	fd 85       	ldd	r31, Y+13	; 0x0d
    42cc:	80 83       	st	Z, r24
    42ce:	91 83       	std	Z+1, r25	; 0x01
    42d0:	a2 83       	std	Z+2, r26	; 0x02
    42d2:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    42d4:	eb 81       	ldd	r30, Y+3	; 0x03
    42d6:	fc 81       	ldd	r31, Y+4	; 0x04
    42d8:	85 a1       	ldd	r24, Z+37	; 0x25
    42da:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    42dc:	eb 81       	ldd	r30, Y+3	; 0x03
    42de:	fc 81       	ldd	r31, Y+4	; 0x04
    42e0:	82 e0       	ldi	r24, 0x02	; 2
    42e2:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    42e4:	8b 85       	ldd	r24, Y+11	; 0x0b
    42e6:	28 2f       	mov	r18, r24
    42e8:	30 e0       	ldi	r19, 0x00	; 0
    42ea:	3f 87       	std	Y+15, r19	; 0x0f
    42ec:	2e 87       	std	Y+14, r18	; 0x0e
    42ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    42f0:	9f 85       	ldd	r25, Y+15	; 0x0f
    42f2:	82 30       	cpi	r24, 0x02	; 2
    42f4:	91 05       	cpc	r25, r1
    42f6:	59 f1       	breq	.+86     	; 0x434e <xTaskGenericNotify+0xd6>
    42f8:	2e 85       	ldd	r18, Y+14	; 0x0e
    42fa:	3f 85       	ldd	r19, Y+15	; 0x0f
    42fc:	23 30       	cpi	r18, 0x03	; 3
    42fe:	31 05       	cpc	r19, r1
    4300:	34 f4       	brge	.+12     	; 0x430e <xTaskGenericNotify+0x96>
    4302:	8e 85       	ldd	r24, Y+14	; 0x0e
    4304:	9f 85       	ldd	r25, Y+15	; 0x0f
    4306:	81 30       	cpi	r24, 0x01	; 1
    4308:	91 05       	cpc	r25, r1
    430a:	61 f0       	breq	.+24     	; 0x4324 <xTaskGenericNotify+0xac>
    430c:	4a c0       	rjmp	.+148    	; 0x43a2 <xTaskGenericNotify+0x12a>
    430e:	2e 85       	ldd	r18, Y+14	; 0x0e
    4310:	3f 85       	ldd	r19, Y+15	; 0x0f
    4312:	23 30       	cpi	r18, 0x03	; 3
    4314:	31 05       	cpc	r19, r1
    4316:	59 f1       	breq	.+86     	; 0x436e <xTaskGenericNotify+0xf6>
    4318:	8e 85       	ldd	r24, Y+14	; 0x0e
    431a:	9f 85       	ldd	r25, Y+15	; 0x0f
    431c:	84 30       	cpi	r24, 0x04	; 4
    431e:	91 05       	cpc	r25, r1
    4320:	89 f1       	breq	.+98     	; 0x4384 <xTaskGenericNotify+0x10c>
    4322:	3f c0       	rjmp	.+126    	; 0x43a2 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4324:	eb 81       	ldd	r30, Y+3	; 0x03
    4326:	fc 81       	ldd	r31, Y+4	; 0x04
    4328:	21 a1       	ldd	r18, Z+33	; 0x21
    432a:	32 a1       	ldd	r19, Z+34	; 0x22
    432c:	43 a1       	ldd	r20, Z+35	; 0x23
    432e:	54 a1       	ldd	r21, Z+36	; 0x24
    4330:	8f 81       	ldd	r24, Y+7	; 0x07
    4332:	98 85       	ldd	r25, Y+8	; 0x08
    4334:	a9 85       	ldd	r26, Y+9	; 0x09
    4336:	ba 85       	ldd	r27, Y+10	; 0x0a
    4338:	82 2b       	or	r24, r18
    433a:	93 2b       	or	r25, r19
    433c:	a4 2b       	or	r26, r20
    433e:	b5 2b       	or	r27, r21
    4340:	eb 81       	ldd	r30, Y+3	; 0x03
    4342:	fc 81       	ldd	r31, Y+4	; 0x04
    4344:	81 a3       	std	Z+33, r24	; 0x21
    4346:	92 a3       	std	Z+34, r25	; 0x22
    4348:	a3 a3       	std	Z+35, r26	; 0x23
    434a:	b4 a3       	std	Z+36, r27	; 0x24
    434c:	2a c0       	rjmp	.+84     	; 0x43a2 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    434e:	eb 81       	ldd	r30, Y+3	; 0x03
    4350:	fc 81       	ldd	r31, Y+4	; 0x04
    4352:	81 a1       	ldd	r24, Z+33	; 0x21
    4354:	92 a1       	ldd	r25, Z+34	; 0x22
    4356:	a3 a1       	ldd	r26, Z+35	; 0x23
    4358:	b4 a1       	ldd	r27, Z+36	; 0x24
    435a:	01 96       	adiw	r24, 0x01	; 1
    435c:	a1 1d       	adc	r26, r1
    435e:	b1 1d       	adc	r27, r1
    4360:	eb 81       	ldd	r30, Y+3	; 0x03
    4362:	fc 81       	ldd	r31, Y+4	; 0x04
    4364:	81 a3       	std	Z+33, r24	; 0x21
    4366:	92 a3       	std	Z+34, r25	; 0x22
    4368:	a3 a3       	std	Z+35, r26	; 0x23
    436a:	b4 a3       	std	Z+36, r27	; 0x24
    436c:	1a c0       	rjmp	.+52     	; 0x43a2 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    436e:	eb 81       	ldd	r30, Y+3	; 0x03
    4370:	fc 81       	ldd	r31, Y+4	; 0x04
    4372:	8f 81       	ldd	r24, Y+7	; 0x07
    4374:	98 85       	ldd	r25, Y+8	; 0x08
    4376:	a9 85       	ldd	r26, Y+9	; 0x09
    4378:	ba 85       	ldd	r27, Y+10	; 0x0a
    437a:	81 a3       	std	Z+33, r24	; 0x21
    437c:	92 a3       	std	Z+34, r25	; 0x22
    437e:	a3 a3       	std	Z+35, r26	; 0x23
    4380:	b4 a3       	std	Z+36, r27	; 0x24
    4382:	0f c0       	rjmp	.+30     	; 0x43a2 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4384:	89 81       	ldd	r24, Y+1	; 0x01
    4386:	82 30       	cpi	r24, 0x02	; 2
    4388:	59 f0       	breq	.+22     	; 0x43a0 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    438a:	eb 81       	ldd	r30, Y+3	; 0x03
    438c:	fc 81       	ldd	r31, Y+4	; 0x04
    438e:	8f 81       	ldd	r24, Y+7	; 0x07
    4390:	98 85       	ldd	r25, Y+8	; 0x08
    4392:	a9 85       	ldd	r26, Y+9	; 0x09
    4394:	ba 85       	ldd	r27, Y+10	; 0x0a
    4396:	81 a3       	std	Z+33, r24	; 0x21
    4398:	92 a3       	std	Z+34, r25	; 0x22
    439a:	a3 a3       	std	Z+35, r26	; 0x23
    439c:	b4 a3       	std	Z+36, r27	; 0x24
    439e:	01 c0       	rjmp	.+2      	; 0x43a2 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    43a0:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    43a2:	89 81       	ldd	r24, Y+1	; 0x01
    43a4:	81 30       	cpi	r24, 0x01	; 1
    43a6:	b9 f5       	brne	.+110    	; 0x4416 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    43a8:	8b 81       	ldd	r24, Y+3	; 0x03
    43aa:	9c 81       	ldd	r25, Y+4	; 0x04
    43ac:	02 96       	adiw	r24, 0x02	; 2
    43ae:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    43b2:	eb 81       	ldd	r30, Y+3	; 0x03
    43b4:	fc 81       	ldd	r31, Y+4	; 0x04
    43b6:	96 89       	ldd	r25, Z+22	; 0x16
    43b8:	80 91 7a 04 	lds	r24, 0x047A
    43bc:	89 17       	cp	r24, r25
    43be:	28 f4       	brcc	.+10     	; 0x43ca <xTaskGenericNotify+0x152>
    43c0:	eb 81       	ldd	r30, Y+3	; 0x03
    43c2:	fc 81       	ldd	r31, Y+4	; 0x04
    43c4:	86 89       	ldd	r24, Z+22	; 0x16
    43c6:	80 93 7a 04 	sts	0x047A, r24
    43ca:	eb 81       	ldd	r30, Y+3	; 0x03
    43cc:	fc 81       	ldd	r31, Y+4	; 0x04
    43ce:	86 89       	ldd	r24, Z+22	; 0x16
    43d0:	28 2f       	mov	r18, r24
    43d2:	30 e0       	ldi	r19, 0x00	; 0
    43d4:	c9 01       	movw	r24, r18
    43d6:	88 0f       	add	r24, r24
    43d8:	99 1f       	adc	r25, r25
    43da:	88 0f       	add	r24, r24
    43dc:	99 1f       	adc	r25, r25
    43de:	88 0f       	add	r24, r24
    43e0:	99 1f       	adc	r25, r25
    43e2:	82 0f       	add	r24, r18
    43e4:	93 1f       	adc	r25, r19
    43e6:	ac 01       	movw	r20, r24
    43e8:	4b 57       	subi	r20, 0x7B	; 123
    43ea:	5b 4f       	sbci	r21, 0xFB	; 251
    43ec:	8b 81       	ldd	r24, Y+3	; 0x03
    43ee:	9c 81       	ldd	r25, Y+4	; 0x04
    43f0:	9c 01       	movw	r18, r24
    43f2:	2e 5f       	subi	r18, 0xFE	; 254
    43f4:	3f 4f       	sbci	r19, 0xFF	; 255
    43f6:	ca 01       	movw	r24, r20
    43f8:	b9 01       	movw	r22, r18
    43fa:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    43fe:	eb 81       	ldd	r30, Y+3	; 0x03
    4400:	fc 81       	ldd	r31, Y+4	; 0x04
    4402:	96 89       	ldd	r25, Z+22	; 0x16
    4404:	e0 91 75 04 	lds	r30, 0x0475
    4408:	f0 91 76 04 	lds	r31, 0x0476
    440c:	86 89       	ldd	r24, Z+22	; 0x16
    440e:	89 17       	cp	r24, r25
    4410:	10 f4       	brcc	.+4      	; 0x4416 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4412:	0e 94 cc 10 	call	0x2198	; 0x2198 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4416:	0f 90       	pop	r0
    4418:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    441a:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    441c:	2f 96       	adiw	r28, 0x0f	; 15
    441e:	0f b6       	in	r0, 0x3f	; 63
    4420:	f8 94       	cli
    4422:	de bf       	out	0x3e, r29	; 62
    4424:	0f be       	out	0x3f, r0	; 63
    4426:	cd bf       	out	0x3d, r28	; 61
    4428:	cf 91       	pop	r28
    442a:	df 91       	pop	r29
    442c:	1f 91       	pop	r17
    442e:	0f 91       	pop	r16
    4430:	08 95       	ret

00004432 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4432:	ef 92       	push	r14
    4434:	ff 92       	push	r15
    4436:	0f 93       	push	r16
    4438:	1f 93       	push	r17
    443a:	df 93       	push	r29
    443c:	cf 93       	push	r28
    443e:	cd b7       	in	r28, 0x3d	; 61
    4440:	de b7       	in	r29, 0x3e	; 62
    4442:	62 97       	sbiw	r28, 0x12	; 18
    4444:	0f b6       	in	r0, 0x3f	; 63
    4446:	f8 94       	cli
    4448:	de bf       	out	0x3e, r29	; 62
    444a:	0f be       	out	0x3f, r0	; 63
    444c:	cd bf       	out	0x3d, r28	; 61
    444e:	9f 83       	std	Y+7, r25	; 0x07
    4450:	8e 83       	std	Y+6, r24	; 0x06
    4452:	48 87       	std	Y+8, r20	; 0x08
    4454:	59 87       	std	Y+9, r21	; 0x09
    4456:	6a 87       	std	Y+10, r22	; 0x0a
    4458:	7b 87       	std	Y+11, r23	; 0x0b
    445a:	2c 87       	std	Y+12, r18	; 0x0c
    445c:	1e 87       	std	Y+14, r17	; 0x0e
    445e:	0d 87       	std	Y+13, r16	; 0x0d
    4460:	f8 8a       	std	Y+16, r15	; 0x10
    4462:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4464:	81 e0       	ldi	r24, 0x01	; 1
    4466:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4468:	8e 81       	ldd	r24, Y+6	; 0x06
    446a:	9f 81       	ldd	r25, Y+7	; 0x07
    446c:	9d 83       	std	Y+5, r25	; 0x05
    446e:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4470:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    4472:	8d 85       	ldd	r24, Y+13	; 0x0d
    4474:	9e 85       	ldd	r25, Y+14	; 0x0e
    4476:	00 97       	sbiw	r24, 0x00	; 0
    4478:	61 f0       	breq	.+24     	; 0x4492 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    447a:	ec 81       	ldd	r30, Y+4	; 0x04
    447c:	fd 81       	ldd	r31, Y+5	; 0x05
    447e:	81 a1       	ldd	r24, Z+33	; 0x21
    4480:	92 a1       	ldd	r25, Z+34	; 0x22
    4482:	a3 a1       	ldd	r26, Z+35	; 0x23
    4484:	b4 a1       	ldd	r27, Z+36	; 0x24
    4486:	ed 85       	ldd	r30, Y+13	; 0x0d
    4488:	fe 85       	ldd	r31, Y+14	; 0x0e
    448a:	80 83       	st	Z, r24
    448c:	91 83       	std	Z+1, r25	; 0x01
    448e:	a2 83       	std	Z+2, r26	; 0x02
    4490:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4492:	ec 81       	ldd	r30, Y+4	; 0x04
    4494:	fd 81       	ldd	r31, Y+5	; 0x05
    4496:	85 a1       	ldd	r24, Z+37	; 0x25
    4498:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    449a:	ec 81       	ldd	r30, Y+4	; 0x04
    449c:	fd 81       	ldd	r31, Y+5	; 0x05
    449e:	82 e0       	ldi	r24, 0x02	; 2
    44a0:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    44a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    44a4:	28 2f       	mov	r18, r24
    44a6:	30 e0       	ldi	r19, 0x00	; 0
    44a8:	3a 8b       	std	Y+18, r19	; 0x12
    44aa:	29 8b       	std	Y+17, r18	; 0x11
    44ac:	89 89       	ldd	r24, Y+17	; 0x11
    44ae:	9a 89       	ldd	r25, Y+18	; 0x12
    44b0:	82 30       	cpi	r24, 0x02	; 2
    44b2:	91 05       	cpc	r25, r1
    44b4:	59 f1       	breq	.+86     	; 0x450c <xTaskGenericNotifyFromISR+0xda>
    44b6:	29 89       	ldd	r18, Y+17	; 0x11
    44b8:	3a 89       	ldd	r19, Y+18	; 0x12
    44ba:	23 30       	cpi	r18, 0x03	; 3
    44bc:	31 05       	cpc	r19, r1
    44be:	34 f4       	brge	.+12     	; 0x44cc <xTaskGenericNotifyFromISR+0x9a>
    44c0:	89 89       	ldd	r24, Y+17	; 0x11
    44c2:	9a 89       	ldd	r25, Y+18	; 0x12
    44c4:	81 30       	cpi	r24, 0x01	; 1
    44c6:	91 05       	cpc	r25, r1
    44c8:	61 f0       	breq	.+24     	; 0x44e2 <xTaskGenericNotifyFromISR+0xb0>
    44ca:	4a c0       	rjmp	.+148    	; 0x4560 <xTaskGenericNotifyFromISR+0x12e>
    44cc:	29 89       	ldd	r18, Y+17	; 0x11
    44ce:	3a 89       	ldd	r19, Y+18	; 0x12
    44d0:	23 30       	cpi	r18, 0x03	; 3
    44d2:	31 05       	cpc	r19, r1
    44d4:	59 f1       	breq	.+86     	; 0x452c <xTaskGenericNotifyFromISR+0xfa>
    44d6:	89 89       	ldd	r24, Y+17	; 0x11
    44d8:	9a 89       	ldd	r25, Y+18	; 0x12
    44da:	84 30       	cpi	r24, 0x04	; 4
    44dc:	91 05       	cpc	r25, r1
    44de:	89 f1       	breq	.+98     	; 0x4542 <xTaskGenericNotifyFromISR+0x110>
    44e0:	3f c0       	rjmp	.+126    	; 0x4560 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    44e2:	ec 81       	ldd	r30, Y+4	; 0x04
    44e4:	fd 81       	ldd	r31, Y+5	; 0x05
    44e6:	21 a1       	ldd	r18, Z+33	; 0x21
    44e8:	32 a1       	ldd	r19, Z+34	; 0x22
    44ea:	43 a1       	ldd	r20, Z+35	; 0x23
    44ec:	54 a1       	ldd	r21, Z+36	; 0x24
    44ee:	88 85       	ldd	r24, Y+8	; 0x08
    44f0:	99 85       	ldd	r25, Y+9	; 0x09
    44f2:	aa 85       	ldd	r26, Y+10	; 0x0a
    44f4:	bb 85       	ldd	r27, Y+11	; 0x0b
    44f6:	82 2b       	or	r24, r18
    44f8:	93 2b       	or	r25, r19
    44fa:	a4 2b       	or	r26, r20
    44fc:	b5 2b       	or	r27, r21
    44fe:	ec 81       	ldd	r30, Y+4	; 0x04
    4500:	fd 81       	ldd	r31, Y+5	; 0x05
    4502:	81 a3       	std	Z+33, r24	; 0x21
    4504:	92 a3       	std	Z+34, r25	; 0x22
    4506:	a3 a3       	std	Z+35, r26	; 0x23
    4508:	b4 a3       	std	Z+36, r27	; 0x24
    450a:	2a c0       	rjmp	.+84     	; 0x4560 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    450c:	ec 81       	ldd	r30, Y+4	; 0x04
    450e:	fd 81       	ldd	r31, Y+5	; 0x05
    4510:	81 a1       	ldd	r24, Z+33	; 0x21
    4512:	92 a1       	ldd	r25, Z+34	; 0x22
    4514:	a3 a1       	ldd	r26, Z+35	; 0x23
    4516:	b4 a1       	ldd	r27, Z+36	; 0x24
    4518:	01 96       	adiw	r24, 0x01	; 1
    451a:	a1 1d       	adc	r26, r1
    451c:	b1 1d       	adc	r27, r1
    451e:	ec 81       	ldd	r30, Y+4	; 0x04
    4520:	fd 81       	ldd	r31, Y+5	; 0x05
    4522:	81 a3       	std	Z+33, r24	; 0x21
    4524:	92 a3       	std	Z+34, r25	; 0x22
    4526:	a3 a3       	std	Z+35, r26	; 0x23
    4528:	b4 a3       	std	Z+36, r27	; 0x24
    452a:	1a c0       	rjmp	.+52     	; 0x4560 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    452c:	ec 81       	ldd	r30, Y+4	; 0x04
    452e:	fd 81       	ldd	r31, Y+5	; 0x05
    4530:	88 85       	ldd	r24, Y+8	; 0x08
    4532:	99 85       	ldd	r25, Y+9	; 0x09
    4534:	aa 85       	ldd	r26, Y+10	; 0x0a
    4536:	bb 85       	ldd	r27, Y+11	; 0x0b
    4538:	81 a3       	std	Z+33, r24	; 0x21
    453a:	92 a3       	std	Z+34, r25	; 0x22
    453c:	a3 a3       	std	Z+35, r26	; 0x23
    453e:	b4 a3       	std	Z+36, r27	; 0x24
    4540:	0f c0       	rjmp	.+30     	; 0x4560 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4542:	8b 81       	ldd	r24, Y+3	; 0x03
    4544:	82 30       	cpi	r24, 0x02	; 2
    4546:	59 f0       	breq	.+22     	; 0x455e <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4548:	ec 81       	ldd	r30, Y+4	; 0x04
    454a:	fd 81       	ldd	r31, Y+5	; 0x05
    454c:	88 85       	ldd	r24, Y+8	; 0x08
    454e:	99 85       	ldd	r25, Y+9	; 0x09
    4550:	aa 85       	ldd	r26, Y+10	; 0x0a
    4552:	bb 85       	ldd	r27, Y+11	; 0x0b
    4554:	81 a3       	std	Z+33, r24	; 0x21
    4556:	92 a3       	std	Z+34, r25	; 0x22
    4558:	a3 a3       	std	Z+35, r26	; 0x23
    455a:	b4 a3       	std	Z+36, r27	; 0x24
    455c:	01 c0       	rjmp	.+2      	; 0x4560 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    455e:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4560:	8b 81       	ldd	r24, Y+3	; 0x03
    4562:	81 30       	cpi	r24, 0x01	; 1
    4564:	09 f0       	breq	.+2      	; 0x4568 <xTaskGenericNotifyFromISR+0x136>
    4566:	4f c0       	rjmp	.+158    	; 0x4606 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4568:	80 91 84 04 	lds	r24, 0x0484
    456c:	88 23       	and	r24, r24
    456e:	61 f5       	brne	.+88     	; 0x45c8 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4570:	8c 81       	ldd	r24, Y+4	; 0x04
    4572:	9d 81       	ldd	r25, Y+5	; 0x05
    4574:	02 96       	adiw	r24, 0x02	; 2
    4576:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    457a:	ec 81       	ldd	r30, Y+4	; 0x04
    457c:	fd 81       	ldd	r31, Y+5	; 0x05
    457e:	96 89       	ldd	r25, Z+22	; 0x16
    4580:	80 91 7a 04 	lds	r24, 0x047A
    4584:	89 17       	cp	r24, r25
    4586:	28 f4       	brcc	.+10     	; 0x4592 <xTaskGenericNotifyFromISR+0x160>
    4588:	ec 81       	ldd	r30, Y+4	; 0x04
    458a:	fd 81       	ldd	r31, Y+5	; 0x05
    458c:	86 89       	ldd	r24, Z+22	; 0x16
    458e:	80 93 7a 04 	sts	0x047A, r24
    4592:	ec 81       	ldd	r30, Y+4	; 0x04
    4594:	fd 81       	ldd	r31, Y+5	; 0x05
    4596:	86 89       	ldd	r24, Z+22	; 0x16
    4598:	28 2f       	mov	r18, r24
    459a:	30 e0       	ldi	r19, 0x00	; 0
    459c:	c9 01       	movw	r24, r18
    459e:	88 0f       	add	r24, r24
    45a0:	99 1f       	adc	r25, r25
    45a2:	88 0f       	add	r24, r24
    45a4:	99 1f       	adc	r25, r25
    45a6:	88 0f       	add	r24, r24
    45a8:	99 1f       	adc	r25, r25
    45aa:	82 0f       	add	r24, r18
    45ac:	93 1f       	adc	r25, r19
    45ae:	ac 01       	movw	r20, r24
    45b0:	4b 57       	subi	r20, 0x7B	; 123
    45b2:	5b 4f       	sbci	r21, 0xFB	; 251
    45b4:	8c 81       	ldd	r24, Y+4	; 0x04
    45b6:	9d 81       	ldd	r25, Y+5	; 0x05
    45b8:	9c 01       	movw	r18, r24
    45ba:	2e 5f       	subi	r18, 0xFE	; 254
    45bc:	3f 4f       	sbci	r19, 0xFF	; 255
    45be:	ca 01       	movw	r24, r20
    45c0:	b9 01       	movw	r22, r18
    45c2:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>
    45c6:	0a c0       	rjmp	.+20     	; 0x45dc <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    45c8:	8c 81       	ldd	r24, Y+4	; 0x04
    45ca:	9d 81       	ldd	r25, Y+5	; 0x05
    45cc:	9c 01       	movw	r18, r24
    45ce:	24 5f       	subi	r18, 0xF4	; 244
    45d0:	3f 4f       	sbci	r19, 0xFF	; 255
    45d2:	8f eb       	ldi	r24, 0xBF	; 191
    45d4:	94 e0       	ldi	r25, 0x04	; 4
    45d6:	b9 01       	movw	r22, r18
    45d8:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    45dc:	ec 81       	ldd	r30, Y+4	; 0x04
    45de:	fd 81       	ldd	r31, Y+5	; 0x05
    45e0:	96 89       	ldd	r25, Z+22	; 0x16
    45e2:	e0 91 75 04 	lds	r30, 0x0475
    45e6:	f0 91 76 04 	lds	r31, 0x0476
    45ea:	86 89       	ldd	r24, Z+22	; 0x16
    45ec:	89 17       	cp	r24, r25
    45ee:	58 f4       	brcc	.+22     	; 0x4606 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    45f0:	8f 85       	ldd	r24, Y+15	; 0x0f
    45f2:	98 89       	ldd	r25, Y+16	; 0x10
    45f4:	00 97       	sbiw	r24, 0x00	; 0
    45f6:	21 f0       	breq	.+8      	; 0x4600 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    45f8:	ef 85       	ldd	r30, Y+15	; 0x0f
    45fa:	f8 89       	ldd	r31, Y+16	; 0x10
    45fc:	81 e0       	ldi	r24, 0x01	; 1
    45fe:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4600:	81 e0       	ldi	r24, 0x01	; 1
    4602:	80 93 7d 04 	sts	0x047D, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4606:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4608:	62 96       	adiw	r28, 0x12	; 18
    460a:	0f b6       	in	r0, 0x3f	; 63
    460c:	f8 94       	cli
    460e:	de bf       	out	0x3e, r29	; 62
    4610:	0f be       	out	0x3f, r0	; 63
    4612:	cd bf       	out	0x3d, r28	; 61
    4614:	cf 91       	pop	r28
    4616:	df 91       	pop	r29
    4618:	1f 91       	pop	r17
    461a:	0f 91       	pop	r16
    461c:	ff 90       	pop	r15
    461e:	ef 90       	pop	r14
    4620:	08 95       	ret

00004622 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4622:	df 93       	push	r29
    4624:	cf 93       	push	r28
    4626:	cd b7       	in	r28, 0x3d	; 61
    4628:	de b7       	in	r29, 0x3e	; 62
    462a:	28 97       	sbiw	r28, 0x08	; 8
    462c:	0f b6       	in	r0, 0x3f	; 63
    462e:	f8 94       	cli
    4630:	de bf       	out	0x3e, r29	; 62
    4632:	0f be       	out	0x3f, r0	; 63
    4634:	cd bf       	out	0x3d, r28	; 61
    4636:	9e 83       	std	Y+6, r25	; 0x06
    4638:	8d 83       	std	Y+5, r24	; 0x05
    463a:	78 87       	std	Y+8, r23	; 0x08
    463c:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    463e:	8d 81       	ldd	r24, Y+5	; 0x05
    4640:	9e 81       	ldd	r25, Y+6	; 0x06
    4642:	9c 83       	std	Y+4, r25	; 0x04
    4644:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4646:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4648:	eb 81       	ldd	r30, Y+3	; 0x03
    464a:	fc 81       	ldd	r31, Y+4	; 0x04
    464c:	85 a1       	ldd	r24, Z+37	; 0x25
    464e:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4650:	eb 81       	ldd	r30, Y+3	; 0x03
    4652:	fc 81       	ldd	r31, Y+4	; 0x04
    4654:	82 e0       	ldi	r24, 0x02	; 2
    4656:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4658:	eb 81       	ldd	r30, Y+3	; 0x03
    465a:	fc 81       	ldd	r31, Y+4	; 0x04
    465c:	81 a1       	ldd	r24, Z+33	; 0x21
    465e:	92 a1       	ldd	r25, Z+34	; 0x22
    4660:	a3 a1       	ldd	r26, Z+35	; 0x23
    4662:	b4 a1       	ldd	r27, Z+36	; 0x24
    4664:	01 96       	adiw	r24, 0x01	; 1
    4666:	a1 1d       	adc	r26, r1
    4668:	b1 1d       	adc	r27, r1
    466a:	eb 81       	ldd	r30, Y+3	; 0x03
    466c:	fc 81       	ldd	r31, Y+4	; 0x04
    466e:	81 a3       	std	Z+33, r24	; 0x21
    4670:	92 a3       	std	Z+34, r25	; 0x22
    4672:	a3 a3       	std	Z+35, r26	; 0x23
    4674:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4676:	8a 81       	ldd	r24, Y+2	; 0x02
    4678:	81 30       	cpi	r24, 0x01	; 1
    467a:	09 f0       	breq	.+2      	; 0x467e <vTaskNotifyGiveFromISR+0x5c>
    467c:	4f c0       	rjmp	.+158    	; 0x471c <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    467e:	80 91 84 04 	lds	r24, 0x0484
    4682:	88 23       	and	r24, r24
    4684:	61 f5       	brne	.+88     	; 0x46de <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4686:	8b 81       	ldd	r24, Y+3	; 0x03
    4688:	9c 81       	ldd	r25, Y+4	; 0x04
    468a:	02 96       	adiw	r24, 0x02	; 2
    468c:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4690:	eb 81       	ldd	r30, Y+3	; 0x03
    4692:	fc 81       	ldd	r31, Y+4	; 0x04
    4694:	96 89       	ldd	r25, Z+22	; 0x16
    4696:	80 91 7a 04 	lds	r24, 0x047A
    469a:	89 17       	cp	r24, r25
    469c:	28 f4       	brcc	.+10     	; 0x46a8 <vTaskNotifyGiveFromISR+0x86>
    469e:	eb 81       	ldd	r30, Y+3	; 0x03
    46a0:	fc 81       	ldd	r31, Y+4	; 0x04
    46a2:	86 89       	ldd	r24, Z+22	; 0x16
    46a4:	80 93 7a 04 	sts	0x047A, r24
    46a8:	eb 81       	ldd	r30, Y+3	; 0x03
    46aa:	fc 81       	ldd	r31, Y+4	; 0x04
    46ac:	86 89       	ldd	r24, Z+22	; 0x16
    46ae:	28 2f       	mov	r18, r24
    46b0:	30 e0       	ldi	r19, 0x00	; 0
    46b2:	c9 01       	movw	r24, r18
    46b4:	88 0f       	add	r24, r24
    46b6:	99 1f       	adc	r25, r25
    46b8:	88 0f       	add	r24, r24
    46ba:	99 1f       	adc	r25, r25
    46bc:	88 0f       	add	r24, r24
    46be:	99 1f       	adc	r25, r25
    46c0:	82 0f       	add	r24, r18
    46c2:	93 1f       	adc	r25, r19
    46c4:	ac 01       	movw	r20, r24
    46c6:	4b 57       	subi	r20, 0x7B	; 123
    46c8:	5b 4f       	sbci	r21, 0xFB	; 251
    46ca:	8b 81       	ldd	r24, Y+3	; 0x03
    46cc:	9c 81       	ldd	r25, Y+4	; 0x04
    46ce:	9c 01       	movw	r18, r24
    46d0:	2e 5f       	subi	r18, 0xFE	; 254
    46d2:	3f 4f       	sbci	r19, 0xFF	; 255
    46d4:	ca 01       	movw	r24, r20
    46d6:	b9 01       	movw	r22, r18
    46d8:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>
    46dc:	0a c0       	rjmp	.+20     	; 0x46f2 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    46de:	8b 81       	ldd	r24, Y+3	; 0x03
    46e0:	9c 81       	ldd	r25, Y+4	; 0x04
    46e2:	9c 01       	movw	r18, r24
    46e4:	24 5f       	subi	r18, 0xF4	; 244
    46e6:	3f 4f       	sbci	r19, 0xFF	; 255
    46e8:	8f eb       	ldi	r24, 0xBF	; 191
    46ea:	94 e0       	ldi	r25, 0x04	; 4
    46ec:	b9 01       	movw	r22, r18
    46ee:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    46f2:	eb 81       	ldd	r30, Y+3	; 0x03
    46f4:	fc 81       	ldd	r31, Y+4	; 0x04
    46f6:	96 89       	ldd	r25, Z+22	; 0x16
    46f8:	e0 91 75 04 	lds	r30, 0x0475
    46fc:	f0 91 76 04 	lds	r31, 0x0476
    4700:	86 89       	ldd	r24, Z+22	; 0x16
    4702:	89 17       	cp	r24, r25
    4704:	58 f4       	brcc	.+22     	; 0x471c <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4706:	8f 81       	ldd	r24, Y+7	; 0x07
    4708:	98 85       	ldd	r25, Y+8	; 0x08
    470a:	00 97       	sbiw	r24, 0x00	; 0
    470c:	21 f0       	breq	.+8      	; 0x4716 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    470e:	ef 81       	ldd	r30, Y+7	; 0x07
    4710:	f8 85       	ldd	r31, Y+8	; 0x08
    4712:	81 e0       	ldi	r24, 0x01	; 1
    4714:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4716:	81 e0       	ldi	r24, 0x01	; 1
    4718:	80 93 7d 04 	sts	0x047D, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    471c:	28 96       	adiw	r28, 0x08	; 8
    471e:	0f b6       	in	r0, 0x3f	; 63
    4720:	f8 94       	cli
    4722:	de bf       	out	0x3e, r29	; 62
    4724:	0f be       	out	0x3f, r0	; 63
    4726:	cd bf       	out	0x3d, r28	; 61
    4728:	cf 91       	pop	r28
    472a:	df 91       	pop	r29
    472c:	08 95       	ret

0000472e <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    472e:	df 93       	push	r29
    4730:	cf 93       	push	r28
    4732:	cd b7       	in	r28, 0x3d	; 61
    4734:	de b7       	in	r29, 0x3e	; 62
    4736:	27 97       	sbiw	r28, 0x07	; 7
    4738:	0f b6       	in	r0, 0x3f	; 63
    473a:	f8 94       	cli
    473c:	de bf       	out	0x3e, r29	; 62
    473e:	0f be       	out	0x3f, r0	; 63
    4740:	cd bf       	out	0x3d, r28	; 61
    4742:	9d 83       	std	Y+5, r25	; 0x05
    4744:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4746:	8c 81       	ldd	r24, Y+4	; 0x04
    4748:	9d 81       	ldd	r25, Y+5	; 0x05
    474a:	00 97       	sbiw	r24, 0x00	; 0
    474c:	39 f4       	brne	.+14     	; 0x475c <xTaskNotifyStateClear+0x2e>
    474e:	80 91 75 04 	lds	r24, 0x0475
    4752:	90 91 76 04 	lds	r25, 0x0476
    4756:	9f 83       	std	Y+7, r25	; 0x07
    4758:	8e 83       	std	Y+6, r24	; 0x06
    475a:	04 c0       	rjmp	.+8      	; 0x4764 <xTaskNotifyStateClear+0x36>
    475c:	8c 81       	ldd	r24, Y+4	; 0x04
    475e:	9d 81       	ldd	r25, Y+5	; 0x05
    4760:	9f 83       	std	Y+7, r25	; 0x07
    4762:	8e 83       	std	Y+6, r24	; 0x06
    4764:	8e 81       	ldd	r24, Y+6	; 0x06
    4766:	9f 81       	ldd	r25, Y+7	; 0x07
    4768:	9b 83       	std	Y+3, r25	; 0x03
    476a:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    476c:	0f b6       	in	r0, 0x3f	; 63
    476e:	f8 94       	cli
    4770:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    4772:	ea 81       	ldd	r30, Y+2	; 0x02
    4774:	fb 81       	ldd	r31, Y+3	; 0x03
    4776:	85 a1       	ldd	r24, Z+37	; 0x25
    4778:	82 30       	cpi	r24, 0x02	; 2
    477a:	31 f4       	brne	.+12     	; 0x4788 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    477c:	ea 81       	ldd	r30, Y+2	; 0x02
    477e:	fb 81       	ldd	r31, Y+3	; 0x03
    4780:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    4782:	81 e0       	ldi	r24, 0x01	; 1
    4784:	89 83       	std	Y+1, r24	; 0x01
    4786:	01 c0       	rjmp	.+2      	; 0x478a <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    4788:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    478a:	0f 90       	pop	r0
    478c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    478e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4790:	27 96       	adiw	r28, 0x07	; 7
    4792:	0f b6       	in	r0, 0x3f	; 63
    4794:	f8 94       	cli
    4796:	de bf       	out	0x3e, r29	; 62
    4798:	0f be       	out	0x3f, r0	; 63
    479a:	cd bf       	out	0x3d, r28	; 61
    479c:	cf 91       	pop	r28
    479e:	df 91       	pop	r29
    47a0:	08 95       	ret

000047a2 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    47a2:	df 93       	push	r29
    47a4:	cf 93       	push	r28
    47a6:	cd b7       	in	r28, 0x3d	; 61
    47a8:	de b7       	in	r29, 0x3e	; 62
    47aa:	27 97       	sbiw	r28, 0x07	; 7
    47ac:	0f b6       	in	r0, 0x3f	; 63
    47ae:	f8 94       	cli
    47b0:	de bf       	out	0x3e, r29	; 62
    47b2:	0f be       	out	0x3f, r0	; 63
    47b4:	cd bf       	out	0x3d, r28	; 61
    47b6:	9e 83       	std	Y+6, r25	; 0x06
    47b8:	8d 83       	std	Y+5, r24	; 0x05
    47ba:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    47bc:	80 91 78 04 	lds	r24, 0x0478
    47c0:	90 91 79 04 	lds	r25, 0x0479
    47c4:	9a 83       	std	Y+2, r25	; 0x02
    47c6:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    47c8:	80 91 75 04 	lds	r24, 0x0475
    47cc:	90 91 76 04 	lds	r25, 0x0476
    47d0:	02 96       	adiw	r24, 0x02	; 2
    47d2:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    47d6:	29 81       	ldd	r18, Y+1	; 0x01
    47d8:	3a 81       	ldd	r19, Y+2	; 0x02
    47da:	8d 81       	ldd	r24, Y+5	; 0x05
    47dc:	9e 81       	ldd	r25, Y+6	; 0x06
    47de:	82 0f       	add	r24, r18
    47e0:	93 1f       	adc	r25, r19
    47e2:	9c 83       	std	Y+4, r25	; 0x04
    47e4:	8b 83       	std	Y+3, r24	; 0x03

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    47e6:	e0 91 75 04 	lds	r30, 0x0475
    47ea:	f0 91 76 04 	lds	r31, 0x0476
    47ee:	8b 81       	ldd	r24, Y+3	; 0x03
    47f0:	9c 81       	ldd	r25, Y+4	; 0x04
    47f2:	93 83       	std	Z+3, r25	; 0x03
    47f4:	82 83       	std	Z+2, r24	; 0x02

		if( xTimeToWake < xConstTickCount )
    47f6:	2b 81       	ldd	r18, Y+3	; 0x03
    47f8:	3c 81       	ldd	r19, Y+4	; 0x04
    47fa:	89 81       	ldd	r24, Y+1	; 0x01
    47fc:	9a 81       	ldd	r25, Y+2	; 0x02
    47fe:	28 17       	cp	r18, r24
    4800:	39 07       	cpc	r19, r25
    4802:	70 f4       	brcc	.+28     	; 0x4820 <prvAddCurrentTaskToDelayedList+0x7e>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4804:	80 91 bd 04 	lds	r24, 0x04BD
    4808:	90 91 be 04 	lds	r25, 0x04BE
    480c:	20 91 75 04 	lds	r18, 0x0475
    4810:	30 91 76 04 	lds	r19, 0x0476
    4814:	2e 5f       	subi	r18, 0xFE	; 254
    4816:	3f 4f       	sbci	r19, 0xFF	; 255
    4818:	b9 01       	movw	r22, r18
    481a:	0e 94 55 0e 	call	0x1caa	; 0x1caa <vListInsert>
    481e:	1e c0       	rjmp	.+60     	; 0x485c <prvAddCurrentTaskToDelayedList+0xba>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4820:	40 91 bb 04 	lds	r20, 0x04BB
    4824:	50 91 bc 04 	lds	r21, 0x04BC
    4828:	80 91 75 04 	lds	r24, 0x0475
    482c:	90 91 76 04 	lds	r25, 0x0476
    4830:	9c 01       	movw	r18, r24
    4832:	2e 5f       	subi	r18, 0xFE	; 254
    4834:	3f 4f       	sbci	r19, 0xFF	; 255
    4836:	ca 01       	movw	r24, r20
    4838:	b9 01       	movw	r22, r18
    483a:	0e 94 55 0e 	call	0x1caa	; 0x1caa <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    483e:	20 91 80 04 	lds	r18, 0x0480
    4842:	30 91 81 04 	lds	r19, 0x0481
    4846:	8b 81       	ldd	r24, Y+3	; 0x03
    4848:	9c 81       	ldd	r25, Y+4	; 0x04
    484a:	82 17       	cp	r24, r18
    484c:	93 07       	cpc	r25, r19
    484e:	30 f4       	brcc	.+12     	; 0x485c <prvAddCurrentTaskToDelayedList+0xba>
			{
				xNextTaskUnblockTime = xTimeToWake;
    4850:	8b 81       	ldd	r24, Y+3	; 0x03
    4852:	9c 81       	ldd	r25, Y+4	; 0x04
    4854:	90 93 81 04 	sts	0x0481, r25
    4858:	80 93 80 04 	sts	0x0480, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    485c:	27 96       	adiw	r28, 0x07	; 7
    485e:	0f b6       	in	r0, 0x3f	; 63
    4860:	f8 94       	cli
    4862:	de bf       	out	0x3e, r29	; 62
    4864:	0f be       	out	0x3f, r0	; 63
    4866:	cd bf       	out	0x3d, r28	; 61
    4868:	cf 91       	pop	r28
    486a:	df 91       	pop	r29
    486c:	08 95       	ret

0000486e <UART_void_init>:
static void (*UART_Rx_callback)(u8 ) = NULL;


/******************************************************************************/
/* Functions implementation section */
void UART_void_init(void ){
    486e:	df 93       	push	r29
    4870:	cf 93       	push	r28
    4872:	cd b7       	in	r28, 0x3d	; 61
    4874:	de b7       	in	r29, 0x3e	; 62
	/*
	 *
	 */
	// Set the buad rate
	UART_UBRRH = UART_UBRRH_val;
    4876:	e0 e4       	ldi	r30, 0x40	; 64
    4878:	f0 e0       	ldi	r31, 0x00	; 0
    487a:	10 82       	st	Z, r1
	UART_UBRRL = UART_UBRRL_val;
    487c:	e9 e2       	ldi	r30, 0x29	; 41
    487e:	f0 e0       	ldi	r31, 0x00	; 0
    4880:	83 e3       	ldi	r24, 0x33	; 51
    4882:	80 83       	st	Z, r24


	// Configure the control and status regester
	UART_UCSRB = ((UART_enable << UART_UCSRB_RXCIE) | (UART_enable << UART_UCSRB_TXCIE) | (UART_disable << UART_UCSRB_UDRIE) | (UART_enable << UART_UCSRB_RXEN) | (UART_enable << UART_UCSRB_TXEN) | (UART_disable << UART_UCSRB_UCSZ2) | (UART_disable));
    4884:	ea e2       	ldi	r30, 0x2A	; 42
    4886:	f0 e0       	ldi	r31, 0x00	; 0
    4888:	88 ed       	ldi	r24, 0xD8	; 216
    488a:	80 83       	st	Z, r24
	UART_UCSRC = (UART_UCSRC_mask | (UART_disable << UART_UCSRC_UMSEL) | (UART_parity_mode << UART_UCSRC_UPM) | (UART_disable << UART_UCSRC_USBS) | (UART_UCSZ_val << UART_UCSRC_UCSZ) | (UART_disable << UART_UCSRC_UCPOL));
    488c:	e0 e4       	ldi	r30, 0x40	; 64
    488e:	f0 e0       	ldi	r31, 0x00	; 0
    4890:	86 e8       	ldi	r24, 0x86	; 134
    4892:	80 83       	st	Z, r24

	// Enable global interrupt
	set_bit(UART_SREG, UART_global_int);
    4894:	af e5       	ldi	r26, 0x5F	; 95
    4896:	b0 e0       	ldi	r27, 0x00	; 0
    4898:	ef e5       	ldi	r30, 0x5F	; 95
    489a:	f0 e0       	ldi	r31, 0x00	; 0
    489c:	80 81       	ld	r24, Z
    489e:	80 68       	ori	r24, 0x80	; 128
    48a0:	8c 93       	st	X, r24
}
    48a2:	cf 91       	pop	r28
    48a4:	df 91       	pop	r29
    48a6:	08 95       	ret

000048a8 <UART_u8_if_available>:

u8 UART_u8_if_available(void ){
    48a8:	df 93       	push	r29
    48aa:	cf 93       	push	r28
    48ac:	cd b7       	in	r28, 0x3d	; 61
    48ae:	de b7       	in	r29, 0x3e	; 62
	/*
	 *
	 */
	return get_bit(UART_UCSRA, UART_UCSRA_UDRE);
    48b0:	eb e2       	ldi	r30, 0x2B	; 43
    48b2:	f0 e0       	ldi	r31, 0x00	; 0
    48b4:	80 81       	ld	r24, Z
    48b6:	82 95       	swap	r24
    48b8:	86 95       	lsr	r24
    48ba:	87 70       	andi	r24, 0x07	; 7
    48bc:	81 70       	andi	r24, 0x01	; 1
}
    48be:	cf 91       	pop	r28
    48c0:	df 91       	pop	r29
    48c2:	08 95       	ret

000048c4 <UART_void_transmit_char>:

void UART_void_transmit_char(u8 copy_data_byte){
    48c4:	df 93       	push	r29
    48c6:	cf 93       	push	r28
    48c8:	0f 92       	push	r0
    48ca:	cd b7       	in	r28, 0x3d	; 61
    48cc:	de b7       	in	r29, 0x3e	; 62
    48ce:	89 83       	std	Y+1, r24	; 0x01
	/*
	 *
	 */
	while(UART_u8_if_available() == 0);
    48d0:	0e 94 54 24 	call	0x48a8	; 0x48a8 <UART_u8_if_available>
    48d4:	88 23       	and	r24, r24
    48d6:	e1 f3       	breq	.-8      	; 0x48d0 <UART_void_transmit_char+0xc>
	UART_UDR = copy_data_byte;
    48d8:	ec e2       	ldi	r30, 0x2C	; 44
    48da:	f0 e0       	ldi	r31, 0x00	; 0
    48dc:	89 81       	ldd	r24, Y+1	; 0x01
    48de:	80 83       	st	Z, r24
}
    48e0:	0f 90       	pop	r0
    48e2:	cf 91       	pop	r28
    48e4:	df 91       	pop	r29
    48e6:	08 95       	ret

000048e8 <UART_void_transmit_str>:

void UART_void_transmit_str(u8* copy_ptr_str){
    48e8:	df 93       	push	r29
    48ea:	cf 93       	push	r28
    48ec:	00 d0       	rcall	.+0      	; 0x48ee <UART_void_transmit_str+0x6>
    48ee:	cd b7       	in	r28, 0x3d	; 61
    48f0:	de b7       	in	r29, 0x3e	; 62
    48f2:	9a 83       	std	Y+2, r25	; 0x02
    48f4:	89 83       	std	Y+1, r24	; 0x01
	/*
	 *
	 */
	static u8 str_index = 0;
	if(*(copy_ptr_str + str_index) == '\0'){
    48f6:	80 91 cc 04 	lds	r24, 0x04CC
    48fa:	28 2f       	mov	r18, r24
    48fc:	30 e0       	ldi	r19, 0x00	; 0
    48fe:	89 81       	ldd	r24, Y+1	; 0x01
    4900:	9a 81       	ldd	r25, Y+2	; 0x02
    4902:	fc 01       	movw	r30, r24
    4904:	e2 0f       	add	r30, r18
    4906:	f3 1f       	adc	r31, r19
    4908:	80 81       	ld	r24, Z
    490a:	88 23       	and	r24, r24
    490c:	39 f4       	brne	.+14     	; 0x491c <UART_void_transmit_str+0x34>
		str_index = 0;
    490e:	10 92 cc 04 	sts	0x04CC, r1
		UART_copy_ptr_str= NULL;
    4912:	10 92 c9 04 	sts	0x04C9, r1
    4916:	10 92 c8 04 	sts	0x04C8, r1
    491a:	1b c0       	rjmp	.+54     	; 0x4952 <UART_void_transmit_str+0x6a>
	}
	else{
		if(str_index == 0){
    491c:	80 91 cc 04 	lds	r24, 0x04CC
    4920:	88 23       	and	r24, r24
    4922:	31 f4       	brne	.+12     	; 0x4930 <UART_void_transmit_str+0x48>
			UART_copy_ptr_str = copy_ptr_str;
    4924:	89 81       	ldd	r24, Y+1	; 0x01
    4926:	9a 81       	ldd	r25, Y+2	; 0x02
    4928:	90 93 c9 04 	sts	0x04C9, r25
    492c:	80 93 c8 04 	sts	0x04C8, r24
		}
		UART_void_transmit_char(*(copy_ptr_str + str_index));
    4930:	80 91 cc 04 	lds	r24, 0x04CC
    4934:	28 2f       	mov	r18, r24
    4936:	30 e0       	ldi	r19, 0x00	; 0
    4938:	89 81       	ldd	r24, Y+1	; 0x01
    493a:	9a 81       	ldd	r25, Y+2	; 0x02
    493c:	fc 01       	movw	r30, r24
    493e:	e2 0f       	add	r30, r18
    4940:	f3 1f       	adc	r31, r19
    4942:	80 81       	ld	r24, Z
    4944:	0e 94 62 24 	call	0x48c4	; 0x48c4 <UART_void_transmit_char>
			str_index++;
    4948:	80 91 cc 04 	lds	r24, 0x04CC
    494c:	8f 5f       	subi	r24, 0xFF	; 255
    494e:	80 93 cc 04 	sts	0x04CC, r24
	}
}
    4952:	0f 90       	pop	r0
    4954:	0f 90       	pop	r0
    4956:	cf 91       	pop	r28
    4958:	df 91       	pop	r29
    495a:	08 95       	ret

0000495c <UART_void_set_Rx_callback>:

void UART_void_set_Rx_callback(void (*copy_ptr_callback)(u8 )){
    495c:	df 93       	push	r29
    495e:	cf 93       	push	r28
    4960:	00 d0       	rcall	.+0      	; 0x4962 <UART_void_set_Rx_callback+0x6>
    4962:	cd b7       	in	r28, 0x3d	; 61
    4964:	de b7       	in	r29, 0x3e	; 62
    4966:	9a 83       	std	Y+2, r25	; 0x02
    4968:	89 83       	std	Y+1, r24	; 0x01
	/*
	 *
	 */
	UART_Rx_callback = copy_ptr_callback;
    496a:	89 81       	ldd	r24, Y+1	; 0x01
    496c:	9a 81       	ldd	r25, Y+2	; 0x02
    496e:	90 93 cb 04 	sts	0x04CB, r25
    4972:	80 93 ca 04 	sts	0x04CA, r24
}
    4976:	0f 90       	pop	r0
    4978:	0f 90       	pop	r0
    497a:	cf 91       	pop	r28
    497c:	df 91       	pop	r29
    497e:	08 95       	ret

00004980 <__vector_13>:

// UART, Rx complete
void __vector_13(void){
    4980:	1f 92       	push	r1
    4982:	0f 92       	push	r0
    4984:	0f b6       	in	r0, 0x3f	; 63
    4986:	0f 92       	push	r0
    4988:	11 24       	eor	r1, r1
    498a:	2f 93       	push	r18
    498c:	3f 93       	push	r19
    498e:	4f 93       	push	r20
    4990:	5f 93       	push	r21
    4992:	6f 93       	push	r22
    4994:	7f 93       	push	r23
    4996:	8f 93       	push	r24
    4998:	9f 93       	push	r25
    499a:	af 93       	push	r26
    499c:	bf 93       	push	r27
    499e:	ef 93       	push	r30
    49a0:	ff 93       	push	r31
    49a2:	df 93       	push	r29
    49a4:	cf 93       	push	r28
    49a6:	cd b7       	in	r28, 0x3d	; 61
    49a8:	de b7       	in	r29, 0x3e	; 62
	/*
	 *
	 */
	if(UART_Rx_callback != NULL){
    49aa:	80 91 ca 04 	lds	r24, 0x04CA
    49ae:	90 91 cb 04 	lds	r25, 0x04CB
    49b2:	00 97       	sbiw	r24, 0x00	; 0
    49b4:	41 f0       	breq	.+16     	; 0x49c6 <__vector_13+0x46>
		UART_Rx_callback(UART_UDR);
    49b6:	e0 91 ca 04 	lds	r30, 0x04CA
    49ba:	f0 91 cb 04 	lds	r31, 0x04CB
    49be:	ac e2       	ldi	r26, 0x2C	; 44
    49c0:	b0 e0       	ldi	r27, 0x00	; 0
    49c2:	8c 91       	ld	r24, X
    49c4:	09 95       	icall
	}
}
    49c6:	cf 91       	pop	r28
    49c8:	df 91       	pop	r29
    49ca:	ff 91       	pop	r31
    49cc:	ef 91       	pop	r30
    49ce:	bf 91       	pop	r27
    49d0:	af 91       	pop	r26
    49d2:	9f 91       	pop	r25
    49d4:	8f 91       	pop	r24
    49d6:	7f 91       	pop	r23
    49d8:	6f 91       	pop	r22
    49da:	5f 91       	pop	r21
    49dc:	4f 91       	pop	r20
    49de:	3f 91       	pop	r19
    49e0:	2f 91       	pop	r18
    49e2:	0f 90       	pop	r0
    49e4:	0f be       	out	0x3f, r0	; 63
    49e6:	0f 90       	pop	r0
    49e8:	1f 90       	pop	r1
    49ea:	18 95       	reti

000049ec <__vector_14>:

// USART Data Register Empty
void __vector_14(void){
    49ec:	1f 92       	push	r1
    49ee:	0f 92       	push	r0
    49f0:	0f b6       	in	r0, 0x3f	; 63
    49f2:	0f 92       	push	r0
    49f4:	11 24       	eor	r1, r1
    49f6:	df 93       	push	r29
    49f8:	cf 93       	push	r28
    49fa:	cd b7       	in	r28, 0x3d	; 61
    49fc:	de b7       	in	r29, 0x3e	; 62
	/*
	 *
	 */

}
    49fe:	cf 91       	pop	r28
    4a00:	df 91       	pop	r29
    4a02:	0f 90       	pop	r0
    4a04:	0f be       	out	0x3f, r0	; 63
    4a06:	0f 90       	pop	r0
    4a08:	1f 90       	pop	r1
    4a0a:	18 95       	reti

00004a0c <__vector_15>:

// UART, Tx complete
void __vector_15(void){
    4a0c:	1f 92       	push	r1
    4a0e:	0f 92       	push	r0
    4a10:	0f b6       	in	r0, 0x3f	; 63
    4a12:	0f 92       	push	r0
    4a14:	11 24       	eor	r1, r1
    4a16:	2f 93       	push	r18
    4a18:	3f 93       	push	r19
    4a1a:	4f 93       	push	r20
    4a1c:	5f 93       	push	r21
    4a1e:	6f 93       	push	r22
    4a20:	7f 93       	push	r23
    4a22:	8f 93       	push	r24
    4a24:	9f 93       	push	r25
    4a26:	af 93       	push	r26
    4a28:	bf 93       	push	r27
    4a2a:	ef 93       	push	r30
    4a2c:	ff 93       	push	r31
    4a2e:	df 93       	push	r29
    4a30:	cf 93       	push	r28
    4a32:	cd b7       	in	r28, 0x3d	; 61
    4a34:	de b7       	in	r29, 0x3e	; 62
	/*
	 *
	 */
	UART_void_transmit_str(UART_copy_ptr_str);
    4a36:	80 91 c8 04 	lds	r24, 0x04C8
    4a3a:	90 91 c9 04 	lds	r25, 0x04C9
    4a3e:	0e 94 74 24 	call	0x48e8	; 0x48e8 <UART_void_transmit_str>
}
    4a42:	cf 91       	pop	r28
    4a44:	df 91       	pop	r29
    4a46:	ff 91       	pop	r31
    4a48:	ef 91       	pop	r30
    4a4a:	bf 91       	pop	r27
    4a4c:	af 91       	pop	r26
    4a4e:	9f 91       	pop	r25
    4a50:	8f 91       	pop	r24
    4a52:	7f 91       	pop	r23
    4a54:	6f 91       	pop	r22
    4a56:	5f 91       	pop	r21
    4a58:	4f 91       	pop	r20
    4a5a:	3f 91       	pop	r19
    4a5c:	2f 91       	pop	r18
    4a5e:	0f 90       	pop	r0
    4a60:	0f be       	out	0x3f, r0	; 63
    4a62:	0f 90       	pop	r0
    4a64:	1f 90       	pop	r1
    4a66:	18 95       	reti

00004a68 <DIO_void_set_port_dir>:


/* Implementing of the driver functions */
/* Set direction of PORTx functions */
void DIO_void_set_port_dir(u8 copy_u8_port_id, u8 port_dir_copy)
{
    4a68:	df 93       	push	r29
    4a6a:	cf 93       	push	r28
    4a6c:	00 d0       	rcall	.+0      	; 0x4a6e <DIO_void_set_port_dir+0x6>
    4a6e:	cd b7       	in	r28, 0x3d	; 61
    4a70:	de b7       	in	r29, 0x3e	; 62
    4a72:	89 83       	std	Y+1, r24	; 0x01
    4a74:	6a 83       	std	Y+2, r22	; 0x02
	 *						1: for output pin
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT Direction Register DDRx
	 */
	*(DIO_DDRx_REF[copy_u8_port_id]) = port_dir_copy;
    4a76:	89 81       	ldd	r24, Y+1	; 0x01
    4a78:	88 2f       	mov	r24, r24
    4a7a:	90 e0       	ldi	r25, 0x00	; 0
    4a7c:	88 0f       	add	r24, r24
    4a7e:	99 1f       	adc	r25, r25
    4a80:	fc 01       	movw	r30, r24
    4a82:	e8 50       	subi	r30, 0x08	; 8
    4a84:	fe 4f       	sbci	r31, 0xFE	; 254
    4a86:	01 90       	ld	r0, Z+
    4a88:	f0 81       	ld	r31, Z
    4a8a:	e0 2d       	mov	r30, r0
    4a8c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a8e:	80 83       	st	Z, r24
}
    4a90:	0f 90       	pop	r0
    4a92:	0f 90       	pop	r0
    4a94:	cf 91       	pop	r28
    4a96:	df 91       	pop	r29
    4a98:	08 95       	ret

00004a9a <DIO_void_set_port_in_pullUp>:


void DIO_void_set_port_in_pullUp(u8 copy_u8_port_id)
{
    4a9a:	df 93       	push	r29
    4a9c:	cf 93       	push	r28
    4a9e:	0f 92       	push	r0
    4aa0:	cd b7       	in	r28, 0x3d	; 61
    4aa2:	de b7       	in	r29, 0x3e	; 62
    4aa4:	89 83       	std	Y+1, r24	; 0x01
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT Direction Register DDRx
	 */
	*(DIO_DDRx_REF[copy_u8_port_id]) = INPUT;
    4aa6:	89 81       	ldd	r24, Y+1	; 0x01
    4aa8:	88 2f       	mov	r24, r24
    4aaa:	90 e0       	ldi	r25, 0x00	; 0
    4aac:	88 0f       	add	r24, r24
    4aae:	99 1f       	adc	r25, r25
    4ab0:	fc 01       	movw	r30, r24
    4ab2:	e8 50       	subi	r30, 0x08	; 8
    4ab4:	fe 4f       	sbci	r31, 0xFE	; 254
    4ab6:	01 90       	ld	r0, Z+
    4ab8:	f0 81       	ld	r31, Z
    4aba:	e0 2d       	mov	r30, r0
    4abc:	10 82       	st	Z, r1
	*(DIO_PORTx_REF[copy_u8_port_id]) = PORT_MAX;
    4abe:	89 81       	ldd	r24, Y+1	; 0x01
    4ac0:	88 2f       	mov	r24, r24
    4ac2:	90 e0       	ldi	r25, 0x00	; 0
    4ac4:	88 0f       	add	r24, r24
    4ac6:	99 1f       	adc	r25, r25
    4ac8:	fc 01       	movw	r30, r24
    4aca:	e0 50       	subi	r30, 0x00	; 0
    4acc:	fe 4f       	sbci	r31, 0xFE	; 254
    4ace:	01 90       	ld	r0, Z+
    4ad0:	f0 81       	ld	r31, Z
    4ad2:	e0 2d       	mov	r30, r0
    4ad4:	8f ef       	ldi	r24, 0xFF	; 255
    4ad6:	80 83       	st	Z, r24
}
    4ad8:	0f 90       	pop	r0
    4ada:	cf 91       	pop	r28
    4adc:	df 91       	pop	r29
    4ade:	08 95       	ret

00004ae0 <DIO_u8_get_PortDir>:


u8 DIO_u8_get_PortDir(u8 copy_u8_port_id)
{
    4ae0:	df 93       	push	r29
    4ae2:	cf 93       	push	r28
    4ae4:	0f 92       	push	r0
    4ae6:	cd b7       	in	r28, 0x3d	; 61
    4ae8:	de b7       	in	r29, 0x3e	; 62
    4aea:	89 83       	std	Y+1, r24	; 0x01
	return *(DIO_DDRx_REF[copy_u8_port_id]);
    4aec:	89 81       	ldd	r24, Y+1	; 0x01
    4aee:	88 2f       	mov	r24, r24
    4af0:	90 e0       	ldi	r25, 0x00	; 0
    4af2:	88 0f       	add	r24, r24
    4af4:	99 1f       	adc	r25, r25
    4af6:	fc 01       	movw	r30, r24
    4af8:	e8 50       	subi	r30, 0x08	; 8
    4afa:	fe 4f       	sbci	r31, 0xFE	; 254
    4afc:	01 90       	ld	r0, Z+
    4afe:	f0 81       	ld	r31, Z
    4b00:	e0 2d       	mov	r30, r0
    4b02:	80 81       	ld	r24, Z
}
    4b04:	0f 90       	pop	r0
    4b06:	cf 91       	pop	r28
    4b08:	df 91       	pop	r29
    4b0a:	08 95       	ret

00004b0c <DIO_void_set_pin_dir>:

/* Set direction of PINx functions */
void DIO_void_set_pin_dir(u8 copy_u8_port_id, u8 copy_u8_pin_num, u8 pin_dir_copy)
{
    4b0c:	df 93       	push	r29
    4b0e:	cf 93       	push	r28
    4b10:	00 d0       	rcall	.+0      	; 0x4b12 <DIO_void_set_pin_dir+0x6>
    4b12:	0f 92       	push	r0
    4b14:	cd b7       	in	r28, 0x3d	; 61
    4b16:	de b7       	in	r29, 0x3e	; 62
    4b18:	89 83       	std	Y+1, r24	; 0x01
    4b1a:	6a 83       	std	Y+2, r22	; 0x02
    4b1c:	4b 83       	std	Y+3, r20	; 0x03
	 *				   1: for output pin
	 *
	 * Function does not return any output, yet it affects the 
	 * pin in the PORT Direction Register DDRx
	 */	
	agn_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num, pin_dir_copy);
    4b1e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b20:	88 23       	and	r24, r24
    4b22:	29 f1       	breq	.+74     	; 0x4b6e <DIO_void_set_pin_dir+0x62>
    4b24:	89 81       	ldd	r24, Y+1	; 0x01
    4b26:	88 2f       	mov	r24, r24
    4b28:	90 e0       	ldi	r25, 0x00	; 0
    4b2a:	88 0f       	add	r24, r24
    4b2c:	99 1f       	adc	r25, r25
    4b2e:	fc 01       	movw	r30, r24
    4b30:	e8 50       	subi	r30, 0x08	; 8
    4b32:	fe 4f       	sbci	r31, 0xFE	; 254
    4b34:	a0 81       	ld	r26, Z
    4b36:	b1 81       	ldd	r27, Z+1	; 0x01
    4b38:	89 81       	ldd	r24, Y+1	; 0x01
    4b3a:	88 2f       	mov	r24, r24
    4b3c:	90 e0       	ldi	r25, 0x00	; 0
    4b3e:	88 0f       	add	r24, r24
    4b40:	99 1f       	adc	r25, r25
    4b42:	fc 01       	movw	r30, r24
    4b44:	e8 50       	subi	r30, 0x08	; 8
    4b46:	fe 4f       	sbci	r31, 0xFE	; 254
    4b48:	01 90       	ld	r0, Z+
    4b4a:	f0 81       	ld	r31, Z
    4b4c:	e0 2d       	mov	r30, r0
    4b4e:	80 81       	ld	r24, Z
    4b50:	48 2f       	mov	r20, r24
    4b52:	8a 81       	ldd	r24, Y+2	; 0x02
    4b54:	28 2f       	mov	r18, r24
    4b56:	30 e0       	ldi	r19, 0x00	; 0
    4b58:	81 e0       	ldi	r24, 0x01	; 1
    4b5a:	90 e0       	ldi	r25, 0x00	; 0
    4b5c:	02 2e       	mov	r0, r18
    4b5e:	02 c0       	rjmp	.+4      	; 0x4b64 <DIO_void_set_pin_dir+0x58>
    4b60:	88 0f       	add	r24, r24
    4b62:	99 1f       	adc	r25, r25
    4b64:	0a 94       	dec	r0
    4b66:	e2 f7       	brpl	.-8      	; 0x4b60 <DIO_void_set_pin_dir+0x54>
    4b68:	84 2b       	or	r24, r20
    4b6a:	8c 93       	st	X, r24
    4b6c:	25 c0       	rjmp	.+74     	; 0x4bb8 <DIO_void_set_pin_dir+0xac>
    4b6e:	89 81       	ldd	r24, Y+1	; 0x01
    4b70:	88 2f       	mov	r24, r24
    4b72:	90 e0       	ldi	r25, 0x00	; 0
    4b74:	88 0f       	add	r24, r24
    4b76:	99 1f       	adc	r25, r25
    4b78:	fc 01       	movw	r30, r24
    4b7a:	e8 50       	subi	r30, 0x08	; 8
    4b7c:	fe 4f       	sbci	r31, 0xFE	; 254
    4b7e:	a0 81       	ld	r26, Z
    4b80:	b1 81       	ldd	r27, Z+1	; 0x01
    4b82:	89 81       	ldd	r24, Y+1	; 0x01
    4b84:	88 2f       	mov	r24, r24
    4b86:	90 e0       	ldi	r25, 0x00	; 0
    4b88:	88 0f       	add	r24, r24
    4b8a:	99 1f       	adc	r25, r25
    4b8c:	fc 01       	movw	r30, r24
    4b8e:	e8 50       	subi	r30, 0x08	; 8
    4b90:	fe 4f       	sbci	r31, 0xFE	; 254
    4b92:	01 90       	ld	r0, Z+
    4b94:	f0 81       	ld	r31, Z
    4b96:	e0 2d       	mov	r30, r0
    4b98:	80 81       	ld	r24, Z
    4b9a:	48 2f       	mov	r20, r24
    4b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b9e:	28 2f       	mov	r18, r24
    4ba0:	30 e0       	ldi	r19, 0x00	; 0
    4ba2:	81 e0       	ldi	r24, 0x01	; 1
    4ba4:	90 e0       	ldi	r25, 0x00	; 0
    4ba6:	02 2e       	mov	r0, r18
    4ba8:	02 c0       	rjmp	.+4      	; 0x4bae <DIO_void_set_pin_dir+0xa2>
    4baa:	88 0f       	add	r24, r24
    4bac:	99 1f       	adc	r25, r25
    4bae:	0a 94       	dec	r0
    4bb0:	e2 f7       	brpl	.-8      	; 0x4baa <DIO_void_set_pin_dir+0x9e>
    4bb2:	80 95       	com	r24
    4bb4:	84 23       	and	r24, r20
    4bb6:	8c 93       	st	X, r24
}
    4bb8:	0f 90       	pop	r0
    4bba:	0f 90       	pop	r0
    4bbc:	0f 90       	pop	r0
    4bbe:	cf 91       	pop	r28
    4bc0:	df 91       	pop	r29
    4bc2:	08 95       	ret

00004bc4 <DIO_void_set_pin_in_pullUP>:


void DIO_void_set_pin_in_pullUP(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4bc4:	df 93       	push	r29
    4bc6:	cf 93       	push	r28
    4bc8:	00 d0       	rcall	.+0      	; 0x4bca <DIO_void_set_pin_in_pullUP+0x6>
    4bca:	cd b7       	in	r28, 0x3d	; 61
    4bcc:	de b7       	in	r29, 0x3e	; 62
    4bce:	89 83       	std	Y+1, r24	; 0x01
    4bd0:	6a 83       	std	Y+2, r22	; 0x02
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	pin in the PORT Direction Register DDRx					  
	 */
	clr_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4bd2:	89 81       	ldd	r24, Y+1	; 0x01
    4bd4:	88 2f       	mov	r24, r24
    4bd6:	90 e0       	ldi	r25, 0x00	; 0
    4bd8:	88 0f       	add	r24, r24
    4bda:	99 1f       	adc	r25, r25
    4bdc:	fc 01       	movw	r30, r24
    4bde:	e8 50       	subi	r30, 0x08	; 8
    4be0:	fe 4f       	sbci	r31, 0xFE	; 254
    4be2:	a0 81       	ld	r26, Z
    4be4:	b1 81       	ldd	r27, Z+1	; 0x01
    4be6:	89 81       	ldd	r24, Y+1	; 0x01
    4be8:	88 2f       	mov	r24, r24
    4bea:	90 e0       	ldi	r25, 0x00	; 0
    4bec:	88 0f       	add	r24, r24
    4bee:	99 1f       	adc	r25, r25
    4bf0:	fc 01       	movw	r30, r24
    4bf2:	e8 50       	subi	r30, 0x08	; 8
    4bf4:	fe 4f       	sbci	r31, 0xFE	; 254
    4bf6:	01 90       	ld	r0, Z+
    4bf8:	f0 81       	ld	r31, Z
    4bfa:	e0 2d       	mov	r30, r0
    4bfc:	80 81       	ld	r24, Z
    4bfe:	48 2f       	mov	r20, r24
    4c00:	8a 81       	ldd	r24, Y+2	; 0x02
    4c02:	28 2f       	mov	r18, r24
    4c04:	30 e0       	ldi	r19, 0x00	; 0
    4c06:	81 e0       	ldi	r24, 0x01	; 1
    4c08:	90 e0       	ldi	r25, 0x00	; 0
    4c0a:	02 c0       	rjmp	.+4      	; 0x4c10 <DIO_void_set_pin_in_pullUP+0x4c>
    4c0c:	88 0f       	add	r24, r24
    4c0e:	99 1f       	adc	r25, r25
    4c10:	2a 95       	dec	r18
    4c12:	e2 f7       	brpl	.-8      	; 0x4c0c <DIO_void_set_pin_in_pullUP+0x48>
    4c14:	80 95       	com	r24
    4c16:	84 23       	and	r24, r20
    4c18:	8c 93       	st	X, r24
	set_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4c1a:	89 81       	ldd	r24, Y+1	; 0x01
    4c1c:	88 2f       	mov	r24, r24
    4c1e:	90 e0       	ldi	r25, 0x00	; 0
    4c20:	88 0f       	add	r24, r24
    4c22:	99 1f       	adc	r25, r25
    4c24:	fc 01       	movw	r30, r24
    4c26:	e0 50       	subi	r30, 0x00	; 0
    4c28:	fe 4f       	sbci	r31, 0xFE	; 254
    4c2a:	a0 81       	ld	r26, Z
    4c2c:	b1 81       	ldd	r27, Z+1	; 0x01
    4c2e:	89 81       	ldd	r24, Y+1	; 0x01
    4c30:	88 2f       	mov	r24, r24
    4c32:	90 e0       	ldi	r25, 0x00	; 0
    4c34:	88 0f       	add	r24, r24
    4c36:	99 1f       	adc	r25, r25
    4c38:	fc 01       	movw	r30, r24
    4c3a:	e0 50       	subi	r30, 0x00	; 0
    4c3c:	fe 4f       	sbci	r31, 0xFE	; 254
    4c3e:	01 90       	ld	r0, Z+
    4c40:	f0 81       	ld	r31, Z
    4c42:	e0 2d       	mov	r30, r0
    4c44:	80 81       	ld	r24, Z
    4c46:	48 2f       	mov	r20, r24
    4c48:	8a 81       	ldd	r24, Y+2	; 0x02
    4c4a:	28 2f       	mov	r18, r24
    4c4c:	30 e0       	ldi	r19, 0x00	; 0
    4c4e:	81 e0       	ldi	r24, 0x01	; 1
    4c50:	90 e0       	ldi	r25, 0x00	; 0
    4c52:	02 2e       	mov	r0, r18
    4c54:	02 c0       	rjmp	.+4      	; 0x4c5a <DIO_void_set_pin_in_pullUP+0x96>
    4c56:	88 0f       	add	r24, r24
    4c58:	99 1f       	adc	r25, r25
    4c5a:	0a 94       	dec	r0
    4c5c:	e2 f7       	brpl	.-8      	; 0x4c56 <DIO_void_set_pin_in_pullUP+0x92>
    4c5e:	84 2b       	or	r24, r20
    4c60:	8c 93       	st	X, r24
}
    4c62:	0f 90       	pop	r0
    4c64:	0f 90       	pop	r0
    4c66:	cf 91       	pop	r28
    4c68:	df 91       	pop	r29
    4c6a:	08 95       	ret

00004c6c <DIO_u8_get_PinDir>:


u8 DIO_u8_get_PinDir(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4c6c:	df 93       	push	r29
    4c6e:	cf 93       	push	r28
    4c70:	00 d0       	rcall	.+0      	; 0x4c72 <DIO_u8_get_PinDir+0x6>
    4c72:	cd b7       	in	r28, 0x3d	; 61
    4c74:	de b7       	in	r29, 0x3e	; 62
    4c76:	89 83       	std	Y+1, r24	; 0x01
    4c78:	6a 83       	std	Y+2, r22	; 0x02
	return get_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4c7a:	89 81       	ldd	r24, Y+1	; 0x01
    4c7c:	88 2f       	mov	r24, r24
    4c7e:	90 e0       	ldi	r25, 0x00	; 0
    4c80:	88 0f       	add	r24, r24
    4c82:	99 1f       	adc	r25, r25
    4c84:	fc 01       	movw	r30, r24
    4c86:	e8 50       	subi	r30, 0x08	; 8
    4c88:	fe 4f       	sbci	r31, 0xFE	; 254
    4c8a:	01 90       	ld	r0, Z+
    4c8c:	f0 81       	ld	r31, Z
    4c8e:	e0 2d       	mov	r30, r0
    4c90:	80 81       	ld	r24, Z
    4c92:	28 2f       	mov	r18, r24
    4c94:	30 e0       	ldi	r19, 0x00	; 0
    4c96:	8a 81       	ldd	r24, Y+2	; 0x02
    4c98:	88 2f       	mov	r24, r24
    4c9a:	90 e0       	ldi	r25, 0x00	; 0
    4c9c:	a9 01       	movw	r20, r18
    4c9e:	02 c0       	rjmp	.+4      	; 0x4ca4 <DIO_u8_get_PinDir+0x38>
    4ca0:	55 95       	asr	r21
    4ca2:	47 95       	ror	r20
    4ca4:	8a 95       	dec	r24
    4ca6:	e2 f7       	brpl	.-8      	; 0x4ca0 <DIO_u8_get_PinDir+0x34>
    4ca8:	ca 01       	movw	r24, r20
    4caa:	81 70       	andi	r24, 0x01	; 1
}
    4cac:	0f 90       	pop	r0
    4cae:	0f 90       	pop	r0
    4cb0:	cf 91       	pop	r28
    4cb2:	df 91       	pop	r29
    4cb4:	08 95       	ret

00004cb6 <DIO_void_set_port>:


/* Assign Value to output PORTx functions */
void DIO_void_set_port(u8 copy_u8_port_id)
{
    4cb6:	df 93       	push	r29
    4cb8:	cf 93       	push	r28
    4cba:	0f 92       	push	r0
    4cbc:	cd b7       	in	r28, 0x3d	; 61
    4cbe:	de b7       	in	r29, 0x3e	; 62
    4cc0:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = PORT_MAX;
    4cc2:	89 81       	ldd	r24, Y+1	; 0x01
    4cc4:	88 2f       	mov	r24, r24
    4cc6:	90 e0       	ldi	r25, 0x00	; 0
    4cc8:	88 0f       	add	r24, r24
    4cca:	99 1f       	adc	r25, r25
    4ccc:	fc 01       	movw	r30, r24
    4cce:	e0 50       	subi	r30, 0x00	; 0
    4cd0:	fe 4f       	sbci	r31, 0xFE	; 254
    4cd2:	01 90       	ld	r0, Z+
    4cd4:	f0 81       	ld	r31, Z
    4cd6:	e0 2d       	mov	r30, r0
    4cd8:	8f ef       	ldi	r24, 0xFF	; 255
    4cda:	80 83       	st	Z, r24
}
    4cdc:	0f 90       	pop	r0
    4cde:	cf 91       	pop	r28
    4ce0:	df 91       	pop	r29
    4ce2:	08 95       	ret

00004ce4 <DIO_void_clear_port>:


void DIO_void_clear_port(u8 copy_u8_port_id)
{
    4ce4:	df 93       	push	r29
    4ce6:	cf 93       	push	r28
    4ce8:	0f 92       	push	r0
    4cea:	cd b7       	in	r28, 0x3d	; 61
    4cec:	de b7       	in	r29, 0x3e	; 62
    4cee:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = LOW;
    4cf0:	89 81       	ldd	r24, Y+1	; 0x01
    4cf2:	88 2f       	mov	r24, r24
    4cf4:	90 e0       	ldi	r25, 0x00	; 0
    4cf6:	88 0f       	add	r24, r24
    4cf8:	99 1f       	adc	r25, r25
    4cfa:	fc 01       	movw	r30, r24
    4cfc:	e0 50       	subi	r30, 0x00	; 0
    4cfe:	fe 4f       	sbci	r31, 0xFE	; 254
    4d00:	01 90       	ld	r0, Z+
    4d02:	f0 81       	ld	r31, Z
    4d04:	e0 2d       	mov	r30, r0
    4d06:	10 82       	st	Z, r1
}
    4d08:	0f 90       	pop	r0
    4d0a:	cf 91       	pop	r28
    4d0c:	df 91       	pop	r29
    4d0e:	08 95       	ret

00004d10 <DIO_void_toggle_port>:


void DIO_void_toggle_port(u8 copy_u8_port_id)
{
    4d10:	df 93       	push	r29
    4d12:	cf 93       	push	r28
    4d14:	0f 92       	push	r0
    4d16:	cd b7       	in	r28, 0x3d	; 61
    4d18:	de b7       	in	r29, 0x3e	; 62
    4d1a:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) ^= PORT_MAX;
    4d1c:	89 81       	ldd	r24, Y+1	; 0x01
    4d1e:	88 2f       	mov	r24, r24
    4d20:	90 e0       	ldi	r25, 0x00	; 0
    4d22:	88 0f       	add	r24, r24
    4d24:	99 1f       	adc	r25, r25
    4d26:	fc 01       	movw	r30, r24
    4d28:	e0 50       	subi	r30, 0x00	; 0
    4d2a:	fe 4f       	sbci	r31, 0xFE	; 254
    4d2c:	a0 81       	ld	r26, Z
    4d2e:	b1 81       	ldd	r27, Z+1	; 0x01
    4d30:	89 81       	ldd	r24, Y+1	; 0x01
    4d32:	88 2f       	mov	r24, r24
    4d34:	90 e0       	ldi	r25, 0x00	; 0
    4d36:	88 0f       	add	r24, r24
    4d38:	99 1f       	adc	r25, r25
    4d3a:	fc 01       	movw	r30, r24
    4d3c:	e0 50       	subi	r30, 0x00	; 0
    4d3e:	fe 4f       	sbci	r31, 0xFE	; 254
    4d40:	01 90       	ld	r0, Z+
    4d42:	f0 81       	ld	r31, Z
    4d44:	e0 2d       	mov	r30, r0
    4d46:	80 81       	ld	r24, Z
    4d48:	80 95       	com	r24
    4d4a:	8c 93       	st	X, r24
}
    4d4c:	0f 90       	pop	r0
    4d4e:	cf 91       	pop	r28
    4d50:	df 91       	pop	r29
    4d52:	08 95       	ret

00004d54 <DIO_void_assign_port>:


void DIO_void_assign_port(u8 copy_u8_port_id, u8 port_val)
{
    4d54:	df 93       	push	r29
    4d56:	cf 93       	push	r28
    4d58:	00 d0       	rcall	.+0      	; 0x4d5a <DIO_void_assign_port+0x6>
    4d5a:	cd b7       	in	r28, 0x3d	; 61
    4d5c:	de b7       	in	r29, 0x3e	; 62
    4d5e:	89 83       	std	Y+1, r24	; 0x01
    4d60:	6a 83       	std	Y+2, r22	; 0x02
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = port_val;
    4d62:	89 81       	ldd	r24, Y+1	; 0x01
    4d64:	88 2f       	mov	r24, r24
    4d66:	90 e0       	ldi	r25, 0x00	; 0
    4d68:	88 0f       	add	r24, r24
    4d6a:	99 1f       	adc	r25, r25
    4d6c:	fc 01       	movw	r30, r24
    4d6e:	e0 50       	subi	r30, 0x00	; 0
    4d70:	fe 4f       	sbci	r31, 0xFE	; 254
    4d72:	01 90       	ld	r0, Z+
    4d74:	f0 81       	ld	r31, Z
    4d76:	e0 2d       	mov	r30, r0
    4d78:	8a 81       	ldd	r24, Y+2	; 0x02
    4d7a:	80 83       	st	Z, r24
}
    4d7c:	0f 90       	pop	r0
    4d7e:	0f 90       	pop	r0
    4d80:	cf 91       	pop	r28
    4d82:	df 91       	pop	r29
    4d84:	08 95       	ret

00004d86 <DIO_u8_get_PortOut>:


u8 DIO_u8_get_PortOut(u8 copy_u8_port_id)
{
    4d86:	df 93       	push	r29
    4d88:	cf 93       	push	r28
    4d8a:	0f 92       	push	r0
    4d8c:	cd b7       	in	r28, 0x3d	; 61
    4d8e:	de b7       	in	r29, 0x3e	; 62
    4d90:	89 83       	std	Y+1, r24	; 0x01
	/*
	 *
	 */
	return *(DIO_PORTx_REF[copy_u8_port_id]);
    4d92:	89 81       	ldd	r24, Y+1	; 0x01
    4d94:	88 2f       	mov	r24, r24
    4d96:	90 e0       	ldi	r25, 0x00	; 0
    4d98:	88 0f       	add	r24, r24
    4d9a:	99 1f       	adc	r25, r25
    4d9c:	fc 01       	movw	r30, r24
    4d9e:	e0 50       	subi	r30, 0x00	; 0
    4da0:	fe 4f       	sbci	r31, 0xFE	; 254
    4da2:	01 90       	ld	r0, Z+
    4da4:	f0 81       	ld	r31, Z
    4da6:	e0 2d       	mov	r30, r0
    4da8:	80 81       	ld	r24, Z
}
    4daa:	0f 90       	pop	r0
    4dac:	cf 91       	pop	r28
    4dae:	df 91       	pop	r29
    4db0:	08 95       	ret

00004db2 <DIO_void_set_pin>:


/* Assign Value to output PINx functions */
void DIO_void_set_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4db2:	df 93       	push	r29
    4db4:	cf 93       	push	r28
    4db6:	00 d0       	rcall	.+0      	; 0x4db8 <DIO_void_set_pin+0x6>
    4db8:	cd b7       	in	r28, 0x3d	; 61
    4dba:	de b7       	in	r29, 0x3e	; 62
    4dbc:	89 83       	std	Y+1, r24	; 0x01
    4dbe:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	set_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4dc0:	89 81       	ldd	r24, Y+1	; 0x01
    4dc2:	88 2f       	mov	r24, r24
    4dc4:	90 e0       	ldi	r25, 0x00	; 0
    4dc6:	88 0f       	add	r24, r24
    4dc8:	99 1f       	adc	r25, r25
    4dca:	fc 01       	movw	r30, r24
    4dcc:	e0 50       	subi	r30, 0x00	; 0
    4dce:	fe 4f       	sbci	r31, 0xFE	; 254
    4dd0:	a0 81       	ld	r26, Z
    4dd2:	b1 81       	ldd	r27, Z+1	; 0x01
    4dd4:	89 81       	ldd	r24, Y+1	; 0x01
    4dd6:	88 2f       	mov	r24, r24
    4dd8:	90 e0       	ldi	r25, 0x00	; 0
    4dda:	88 0f       	add	r24, r24
    4ddc:	99 1f       	adc	r25, r25
    4dde:	fc 01       	movw	r30, r24
    4de0:	e0 50       	subi	r30, 0x00	; 0
    4de2:	fe 4f       	sbci	r31, 0xFE	; 254
    4de4:	01 90       	ld	r0, Z+
    4de6:	f0 81       	ld	r31, Z
    4de8:	e0 2d       	mov	r30, r0
    4dea:	80 81       	ld	r24, Z
    4dec:	48 2f       	mov	r20, r24
    4dee:	8a 81       	ldd	r24, Y+2	; 0x02
    4df0:	28 2f       	mov	r18, r24
    4df2:	30 e0       	ldi	r19, 0x00	; 0
    4df4:	81 e0       	ldi	r24, 0x01	; 1
    4df6:	90 e0       	ldi	r25, 0x00	; 0
    4df8:	02 2e       	mov	r0, r18
    4dfa:	02 c0       	rjmp	.+4      	; 0x4e00 <DIO_void_set_pin+0x4e>
    4dfc:	88 0f       	add	r24, r24
    4dfe:	99 1f       	adc	r25, r25
    4e00:	0a 94       	dec	r0
    4e02:	e2 f7       	brpl	.-8      	; 0x4dfc <DIO_void_set_pin+0x4a>
    4e04:	84 2b       	or	r24, r20
    4e06:	8c 93       	st	X, r24
}
    4e08:	0f 90       	pop	r0
    4e0a:	0f 90       	pop	r0
    4e0c:	cf 91       	pop	r28
    4e0e:	df 91       	pop	r29
    4e10:	08 95       	ret

00004e12 <DIO_void_clear_pin>:


void DIO_void_clear_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4e12:	df 93       	push	r29
    4e14:	cf 93       	push	r28
    4e16:	00 d0       	rcall	.+0      	; 0x4e18 <DIO_void_clear_pin+0x6>
    4e18:	cd b7       	in	r28, 0x3d	; 61
    4e1a:	de b7       	in	r29, 0x3e	; 62
    4e1c:	89 83       	std	Y+1, r24	; 0x01
    4e1e:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	clr_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4e20:	89 81       	ldd	r24, Y+1	; 0x01
    4e22:	88 2f       	mov	r24, r24
    4e24:	90 e0       	ldi	r25, 0x00	; 0
    4e26:	88 0f       	add	r24, r24
    4e28:	99 1f       	adc	r25, r25
    4e2a:	fc 01       	movw	r30, r24
    4e2c:	e0 50       	subi	r30, 0x00	; 0
    4e2e:	fe 4f       	sbci	r31, 0xFE	; 254
    4e30:	a0 81       	ld	r26, Z
    4e32:	b1 81       	ldd	r27, Z+1	; 0x01
    4e34:	89 81       	ldd	r24, Y+1	; 0x01
    4e36:	88 2f       	mov	r24, r24
    4e38:	90 e0       	ldi	r25, 0x00	; 0
    4e3a:	88 0f       	add	r24, r24
    4e3c:	99 1f       	adc	r25, r25
    4e3e:	fc 01       	movw	r30, r24
    4e40:	e0 50       	subi	r30, 0x00	; 0
    4e42:	fe 4f       	sbci	r31, 0xFE	; 254
    4e44:	01 90       	ld	r0, Z+
    4e46:	f0 81       	ld	r31, Z
    4e48:	e0 2d       	mov	r30, r0
    4e4a:	80 81       	ld	r24, Z
    4e4c:	48 2f       	mov	r20, r24
    4e4e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e50:	28 2f       	mov	r18, r24
    4e52:	30 e0       	ldi	r19, 0x00	; 0
    4e54:	81 e0       	ldi	r24, 0x01	; 1
    4e56:	90 e0       	ldi	r25, 0x00	; 0
    4e58:	02 2e       	mov	r0, r18
    4e5a:	02 c0       	rjmp	.+4      	; 0x4e60 <DIO_void_clear_pin+0x4e>
    4e5c:	88 0f       	add	r24, r24
    4e5e:	99 1f       	adc	r25, r25
    4e60:	0a 94       	dec	r0
    4e62:	e2 f7       	brpl	.-8      	; 0x4e5c <DIO_void_clear_pin+0x4a>
    4e64:	80 95       	com	r24
    4e66:	84 23       	and	r24, r20
    4e68:	8c 93       	st	X, r24
}
    4e6a:	0f 90       	pop	r0
    4e6c:	0f 90       	pop	r0
    4e6e:	cf 91       	pop	r28
    4e70:	df 91       	pop	r29
    4e72:	08 95       	ret

00004e74 <DIO_void_toggle_pin>:


void DIO_void_toggle_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4e74:	df 93       	push	r29
    4e76:	cf 93       	push	r28
    4e78:	00 d0       	rcall	.+0      	; 0x4e7a <DIO_void_toggle_pin+0x6>
    4e7a:	cd b7       	in	r28, 0x3d	; 61
    4e7c:	de b7       	in	r29, 0x3e	; 62
    4e7e:	89 83       	std	Y+1, r24	; 0x01
    4e80:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	tgl_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4e82:	89 81       	ldd	r24, Y+1	; 0x01
    4e84:	88 2f       	mov	r24, r24
    4e86:	90 e0       	ldi	r25, 0x00	; 0
    4e88:	88 0f       	add	r24, r24
    4e8a:	99 1f       	adc	r25, r25
    4e8c:	fc 01       	movw	r30, r24
    4e8e:	e0 50       	subi	r30, 0x00	; 0
    4e90:	fe 4f       	sbci	r31, 0xFE	; 254
    4e92:	a0 81       	ld	r26, Z
    4e94:	b1 81       	ldd	r27, Z+1	; 0x01
    4e96:	89 81       	ldd	r24, Y+1	; 0x01
    4e98:	88 2f       	mov	r24, r24
    4e9a:	90 e0       	ldi	r25, 0x00	; 0
    4e9c:	88 0f       	add	r24, r24
    4e9e:	99 1f       	adc	r25, r25
    4ea0:	fc 01       	movw	r30, r24
    4ea2:	e0 50       	subi	r30, 0x00	; 0
    4ea4:	fe 4f       	sbci	r31, 0xFE	; 254
    4ea6:	01 90       	ld	r0, Z+
    4ea8:	f0 81       	ld	r31, Z
    4eaa:	e0 2d       	mov	r30, r0
    4eac:	80 81       	ld	r24, Z
    4eae:	48 2f       	mov	r20, r24
    4eb0:	8a 81       	ldd	r24, Y+2	; 0x02
    4eb2:	28 2f       	mov	r18, r24
    4eb4:	30 e0       	ldi	r19, 0x00	; 0
    4eb6:	81 e0       	ldi	r24, 0x01	; 1
    4eb8:	90 e0       	ldi	r25, 0x00	; 0
    4eba:	02 2e       	mov	r0, r18
    4ebc:	02 c0       	rjmp	.+4      	; 0x4ec2 <DIO_void_toggle_pin+0x4e>
    4ebe:	88 0f       	add	r24, r24
    4ec0:	99 1f       	adc	r25, r25
    4ec2:	0a 94       	dec	r0
    4ec4:	e2 f7       	brpl	.-8      	; 0x4ebe <DIO_void_toggle_pin+0x4a>
    4ec6:	84 27       	eor	r24, r20
    4ec8:	8c 93       	st	X, r24
}
    4eca:	0f 90       	pop	r0
    4ecc:	0f 90       	pop	r0
    4ece:	cf 91       	pop	r28
    4ed0:	df 91       	pop	r29
    4ed2:	08 95       	ret

00004ed4 <DIO_void_assign_pin>:


void DIO_void_assign_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num, u8 pin_val)
{
    4ed4:	df 93       	push	r29
    4ed6:	cf 93       	push	r28
    4ed8:	00 d0       	rcall	.+0      	; 0x4eda <DIO_void_assign_pin+0x6>
    4eda:	0f 92       	push	r0
    4edc:	cd b7       	in	r28, 0x3d	; 61
    4ede:	de b7       	in	r29, 0x3e	; 62
    4ee0:	89 83       	std	Y+1, r24	; 0x01
    4ee2:	6a 83       	std	Y+2, r22	; 0x02
    4ee4:	4b 83       	std	Y+3, r20	; 0x03
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	agn_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num, pin_val);
    4ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ee8:	88 23       	and	r24, r24
    4eea:	29 f1       	breq	.+74     	; 0x4f36 <DIO_void_assign_pin+0x62>
    4eec:	89 81       	ldd	r24, Y+1	; 0x01
    4eee:	88 2f       	mov	r24, r24
    4ef0:	90 e0       	ldi	r25, 0x00	; 0
    4ef2:	88 0f       	add	r24, r24
    4ef4:	99 1f       	adc	r25, r25
    4ef6:	fc 01       	movw	r30, r24
    4ef8:	e0 50       	subi	r30, 0x00	; 0
    4efa:	fe 4f       	sbci	r31, 0xFE	; 254
    4efc:	a0 81       	ld	r26, Z
    4efe:	b1 81       	ldd	r27, Z+1	; 0x01
    4f00:	89 81       	ldd	r24, Y+1	; 0x01
    4f02:	88 2f       	mov	r24, r24
    4f04:	90 e0       	ldi	r25, 0x00	; 0
    4f06:	88 0f       	add	r24, r24
    4f08:	99 1f       	adc	r25, r25
    4f0a:	fc 01       	movw	r30, r24
    4f0c:	e0 50       	subi	r30, 0x00	; 0
    4f0e:	fe 4f       	sbci	r31, 0xFE	; 254
    4f10:	01 90       	ld	r0, Z+
    4f12:	f0 81       	ld	r31, Z
    4f14:	e0 2d       	mov	r30, r0
    4f16:	80 81       	ld	r24, Z
    4f18:	48 2f       	mov	r20, r24
    4f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    4f1c:	28 2f       	mov	r18, r24
    4f1e:	30 e0       	ldi	r19, 0x00	; 0
    4f20:	81 e0       	ldi	r24, 0x01	; 1
    4f22:	90 e0       	ldi	r25, 0x00	; 0
    4f24:	02 2e       	mov	r0, r18
    4f26:	02 c0       	rjmp	.+4      	; 0x4f2c <DIO_void_assign_pin+0x58>
    4f28:	88 0f       	add	r24, r24
    4f2a:	99 1f       	adc	r25, r25
    4f2c:	0a 94       	dec	r0
    4f2e:	e2 f7       	brpl	.-8      	; 0x4f28 <DIO_void_assign_pin+0x54>
    4f30:	84 2b       	or	r24, r20
    4f32:	8c 93       	st	X, r24
    4f34:	25 c0       	rjmp	.+74     	; 0x4f80 <DIO_void_assign_pin+0xac>
    4f36:	89 81       	ldd	r24, Y+1	; 0x01
    4f38:	88 2f       	mov	r24, r24
    4f3a:	90 e0       	ldi	r25, 0x00	; 0
    4f3c:	88 0f       	add	r24, r24
    4f3e:	99 1f       	adc	r25, r25
    4f40:	fc 01       	movw	r30, r24
    4f42:	e0 50       	subi	r30, 0x00	; 0
    4f44:	fe 4f       	sbci	r31, 0xFE	; 254
    4f46:	a0 81       	ld	r26, Z
    4f48:	b1 81       	ldd	r27, Z+1	; 0x01
    4f4a:	89 81       	ldd	r24, Y+1	; 0x01
    4f4c:	88 2f       	mov	r24, r24
    4f4e:	90 e0       	ldi	r25, 0x00	; 0
    4f50:	88 0f       	add	r24, r24
    4f52:	99 1f       	adc	r25, r25
    4f54:	fc 01       	movw	r30, r24
    4f56:	e0 50       	subi	r30, 0x00	; 0
    4f58:	fe 4f       	sbci	r31, 0xFE	; 254
    4f5a:	01 90       	ld	r0, Z+
    4f5c:	f0 81       	ld	r31, Z
    4f5e:	e0 2d       	mov	r30, r0
    4f60:	80 81       	ld	r24, Z
    4f62:	48 2f       	mov	r20, r24
    4f64:	8a 81       	ldd	r24, Y+2	; 0x02
    4f66:	28 2f       	mov	r18, r24
    4f68:	30 e0       	ldi	r19, 0x00	; 0
    4f6a:	81 e0       	ldi	r24, 0x01	; 1
    4f6c:	90 e0       	ldi	r25, 0x00	; 0
    4f6e:	02 2e       	mov	r0, r18
    4f70:	02 c0       	rjmp	.+4      	; 0x4f76 <DIO_void_assign_pin+0xa2>
    4f72:	88 0f       	add	r24, r24
    4f74:	99 1f       	adc	r25, r25
    4f76:	0a 94       	dec	r0
    4f78:	e2 f7       	brpl	.-8      	; 0x4f72 <DIO_void_assign_pin+0x9e>
    4f7a:	80 95       	com	r24
    4f7c:	84 23       	and	r24, r20
    4f7e:	8c 93       	st	X, r24
}
    4f80:	0f 90       	pop	r0
    4f82:	0f 90       	pop	r0
    4f84:	0f 90       	pop	r0
    4f86:	cf 91       	pop	r28
    4f88:	df 91       	pop	r29
    4f8a:	08 95       	ret

00004f8c <DIO_u8_get_PinOut>:


u8 DIO_u8_get_PinOut(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4f8c:	df 93       	push	r29
    4f8e:	cf 93       	push	r28
    4f90:	00 d0       	rcall	.+0      	; 0x4f92 <DIO_u8_get_PinOut+0x6>
    4f92:	cd b7       	in	r28, 0x3d	; 61
    4f94:	de b7       	in	r29, 0x3e	; 62
    4f96:	89 83       	std	Y+1, r24	; 0x01
    4f98:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 *
	 */
	return get_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4f9a:	89 81       	ldd	r24, Y+1	; 0x01
    4f9c:	88 2f       	mov	r24, r24
    4f9e:	90 e0       	ldi	r25, 0x00	; 0
    4fa0:	88 0f       	add	r24, r24
    4fa2:	99 1f       	adc	r25, r25
    4fa4:	fc 01       	movw	r30, r24
    4fa6:	e0 50       	subi	r30, 0x00	; 0
    4fa8:	fe 4f       	sbci	r31, 0xFE	; 254
    4faa:	01 90       	ld	r0, Z+
    4fac:	f0 81       	ld	r31, Z
    4fae:	e0 2d       	mov	r30, r0
    4fb0:	80 81       	ld	r24, Z
    4fb2:	28 2f       	mov	r18, r24
    4fb4:	30 e0       	ldi	r19, 0x00	; 0
    4fb6:	8a 81       	ldd	r24, Y+2	; 0x02
    4fb8:	88 2f       	mov	r24, r24
    4fba:	90 e0       	ldi	r25, 0x00	; 0
    4fbc:	a9 01       	movw	r20, r18
    4fbe:	02 c0       	rjmp	.+4      	; 0x4fc4 <DIO_u8_get_PinOut+0x38>
    4fc0:	55 95       	asr	r21
    4fc2:	47 95       	ror	r20
    4fc4:	8a 95       	dec	r24
    4fc6:	e2 f7       	brpl	.-8      	; 0x4fc0 <DIO_u8_get_PinOut+0x34>
    4fc8:	ca 01       	movw	r24, r20
    4fca:	81 70       	andi	r24, 0x01	; 1
}
    4fcc:	0f 90       	pop	r0
    4fce:	0f 90       	pop	r0
    4fd0:	cf 91       	pop	r28
    4fd2:	df 91       	pop	r29
    4fd4:	08 95       	ret

00004fd6 <DIO_u8_get_port>:


/* Get value from input PORTx functions */
u8 DIO_u8_get_port(u8 copy_u8_port_id)
{
    4fd6:	df 93       	push	r29
    4fd8:	cf 93       	push	r28
    4fda:	0f 92       	push	r0
    4fdc:	cd b7       	in	r28, 0x3d	; 61
    4fde:	de b7       	in	r29, 0x3e	; 62
    4fe0:	89 83       	std	Y+1, r24	; 0x01
	 *	
	 *	Function does not affect any regester it only gets
	 *	from the value in the input regester PINx of the 
	 *	given port                                                 
	 */
	return *(DIO_PINx_REF[copy_u8_port_id]);
    4fe2:	89 81       	ldd	r24, Y+1	; 0x01
    4fe4:	88 2f       	mov	r24, r24
    4fe6:	90 e0       	ldi	r25, 0x00	; 0
    4fe8:	88 0f       	add	r24, r24
    4fea:	99 1f       	adc	r25, r25
    4fec:	fc 01       	movw	r30, r24
    4fee:	e0 51       	subi	r30, 0x10	; 16
    4ff0:	fe 4f       	sbci	r31, 0xFE	; 254
    4ff2:	01 90       	ld	r0, Z+
    4ff4:	f0 81       	ld	r31, Z
    4ff6:	e0 2d       	mov	r30, r0
    4ff8:	80 81       	ld	r24, Z
}
    4ffa:	0f 90       	pop	r0
    4ffc:	cf 91       	pop	r28
    4ffe:	df 91       	pop	r29
    5000:	08 95       	ret

00005002 <DIO_u8_get_pin>:


/* Get value from input PINx functions */
u8 DIO_u8_get_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    5002:	df 93       	push	r29
    5004:	cf 93       	push	r28
    5006:	00 d0       	rcall	.+0      	; 0x5008 <DIO_u8_get_pin+0x6>
    5008:	cd b7       	in	r28, 0x3d	; 61
    500a:	de b7       	in	r29, 0x3e	; 62
    500c:	89 83       	std	Y+1, r24	; 0x01
    500e:	6a 83       	std	Y+2, r22	; 0x02
	 *	
	 *	Function does not affect any regester it only gets the pin
	 *	value from the value in the input regester PINx of the 
	 *	given port                                                 
	 */
	return get_bit(*(DIO_PINx_REF[copy_u8_port_id]), copy_u8_pin_num);
    5010:	89 81       	ldd	r24, Y+1	; 0x01
    5012:	88 2f       	mov	r24, r24
    5014:	90 e0       	ldi	r25, 0x00	; 0
    5016:	88 0f       	add	r24, r24
    5018:	99 1f       	adc	r25, r25
    501a:	fc 01       	movw	r30, r24
    501c:	e0 51       	subi	r30, 0x10	; 16
    501e:	fe 4f       	sbci	r31, 0xFE	; 254
    5020:	01 90       	ld	r0, Z+
    5022:	f0 81       	ld	r31, Z
    5024:	e0 2d       	mov	r30, r0
    5026:	80 81       	ld	r24, Z
    5028:	28 2f       	mov	r18, r24
    502a:	30 e0       	ldi	r19, 0x00	; 0
    502c:	8a 81       	ldd	r24, Y+2	; 0x02
    502e:	88 2f       	mov	r24, r24
    5030:	90 e0       	ldi	r25, 0x00	; 0
    5032:	a9 01       	movw	r20, r18
    5034:	02 c0       	rjmp	.+4      	; 0x503a <DIO_u8_get_pin+0x38>
    5036:	55 95       	asr	r21
    5038:	47 95       	ror	r20
    503a:	8a 95       	dec	r24
    503c:	e2 f7       	brpl	.-8      	; 0x5036 <DIO_u8_get_pin+0x34>
    503e:	ca 01       	movw	r24, r20
    5040:	81 70       	andi	r24, 0x01	; 1
}
    5042:	0f 90       	pop	r0
    5044:	0f 90       	pop	r0
    5046:	cf 91       	pop	r28
    5048:	df 91       	pop	r29
    504a:	08 95       	ret

0000504c <ADC_void_init>:

//Global variables
static void (*callback_functions_address)(u16 )= NULL;

/* Implementing of the driver functions */
void ADC_void_init(void ){
    504c:	df 93       	push	r29
    504e:	cf 93       	push	r28
    5050:	cd b7       	in	r28, 0x3d	; 61
    5052:	de b7       	in	r29, 0x3e	; 62
	 *	No inputs to the function.
	 *
	 *	No return from the function.
	 */
	// Assign the value of the left adjust bit
	agn_bit(ADC_ADMUX, ADC_ADLAR_pin, ADC_ADLAR);
    5054:	a7 e2       	ldi	r26, 0x27	; 39
    5056:	b0 e0       	ldi	r27, 0x00	; 0
    5058:	e7 e2       	ldi	r30, 0x27	; 39
    505a:	f0 e0       	ldi	r31, 0x00	; 0
    505c:	80 81       	ld	r24, Z
    505e:	8f 7d       	andi	r24, 0xDF	; 223
    5060:	8c 93       	st	X, r24

	// Assign the values of the reference selection regesters
	agn_bit(ADC_ADMUX, ADC_REFS0_pin, ADC_REFS0);
    5062:	a7 e2       	ldi	r26, 0x27	; 39
    5064:	b0 e0       	ldi	r27, 0x00	; 0
    5066:	e7 e2       	ldi	r30, 0x27	; 39
    5068:	f0 e0       	ldi	r31, 0x00	; 0
    506a:	80 81       	ld	r24, Z
    506c:	80 64       	ori	r24, 0x40	; 64
    506e:	8c 93       	st	X, r24
	agn_bit(ADC_ADMUX, ADC_REFS1_pin, ADC_REFS1);
    5070:	a7 e2       	ldi	r26, 0x27	; 39
    5072:	b0 e0       	ldi	r27, 0x00	; 0
    5074:	e7 e2       	ldi	r30, 0x27	; 39
    5076:	f0 e0       	ldi	r31, 0x00	; 0
    5078:	80 81       	ld	r24, Z
    507a:	8f 77       	andi	r24, 0x7F	; 127
    507c:	8c 93       	st	X, r24

	// Assign the value of the enable bit
	agn_bit(ADC_ADCSRA, ADC_ADEN_pin, ADC_ADEN);
    507e:	a6 e2       	ldi	r26, 0x26	; 38
    5080:	b0 e0       	ldi	r27, 0x00	; 0
    5082:	e6 e2       	ldi	r30, 0x26	; 38
    5084:	f0 e0       	ldi	r31, 0x00	; 0
    5086:	80 81       	ld	r24, Z
    5088:	80 68       	ori	r24, 0x80	; 128
    508a:	8c 93       	st	X, r24
}
    508c:	cf 91       	pop	r28
    508e:	df 91       	pop	r29
    5090:	08 95       	ret

00005092 <ADC_void_config>:


void ADC_void_config(ADC_config_struct* ptr_config){
    5092:	df 93       	push	r29
    5094:	cf 93       	push	r28
    5096:	00 d0       	rcall	.+0      	; 0x5098 <ADC_void_config+0x6>
    5098:	cd b7       	in	r28, 0x3d	; 61
    509a:	de b7       	in	r29, 0x3e	; 62
    509c:	9a 83       	std	Y+2, r25	; 0x02
    509e:	89 83       	std	Y+1, r24	; 0x01
	 *		ptr_config>> Pointer to ADC configurations Struct.
	 *	
	 *	Function does not return any values, Hence it needs to be called every time you need to reconfigure the ADC.
	 */
	// Configure the analog channel and gain selection bits
	ADC_ADMUX &= ADC_MUX_clear;
    50a0:	a7 e2       	ldi	r26, 0x27	; 39
    50a2:	b0 e0       	ldi	r27, 0x00	; 0
    50a4:	e7 e2       	ldi	r30, 0x27	; 39
    50a6:	f0 e0       	ldi	r31, 0x00	; 0
    50a8:	80 81       	ld	r24, Z
    50aa:	80 7e       	andi	r24, 0xE0	; 224
    50ac:	8c 93       	st	X, r24
	ADC_ADMUX |= ptr_config -> MUX;
    50ae:	a7 e2       	ldi	r26, 0x27	; 39
    50b0:	b0 e0       	ldi	r27, 0x00	; 0
    50b2:	e7 e2       	ldi	r30, 0x27	; 39
    50b4:	f0 e0       	ldi	r31, 0x00	; 0
    50b6:	90 81       	ld	r25, Z
    50b8:	e9 81       	ldd	r30, Y+1	; 0x01
    50ba:	fa 81       	ldd	r31, Y+2	; 0x02
    50bc:	80 81       	ld	r24, Z
    50be:	8f 71       	andi	r24, 0x1F	; 31
    50c0:	89 2b       	or	r24, r25
    50c2:	8c 93       	st	X, r24

	// Configure the ADC prescaler select bits
	ADC_ADCSRA &= ADC_ADPS_clear;
    50c4:	a6 e2       	ldi	r26, 0x26	; 38
    50c6:	b0 e0       	ldi	r27, 0x00	; 0
    50c8:	e6 e2       	ldi	r30, 0x26	; 38
    50ca:	f0 e0       	ldi	r31, 0x00	; 0
    50cc:	80 81       	ld	r24, Z
    50ce:	88 7f       	andi	r24, 0xF8	; 248
    50d0:	8c 93       	st	X, r24
	ADC_ADCSRA |= ptr_config -> ADPS;
    50d2:	a6 e2       	ldi	r26, 0x26	; 38
    50d4:	b0 e0       	ldi	r27, 0x00	; 0
    50d6:	e6 e2       	ldi	r30, 0x26	; 38
    50d8:	f0 e0       	ldi	r31, 0x00	; 0
    50da:	90 81       	ld	r25, Z
    50dc:	e9 81       	ldd	r30, Y+1	; 0x01
    50de:	fa 81       	ldd	r31, Y+2	; 0x02
    50e0:	80 81       	ld	r24, Z
    50e2:	82 95       	swap	r24
    50e4:	86 95       	lsr	r24
    50e6:	87 70       	andi	r24, 0x07	; 7
    50e8:	89 2b       	or	r24, r25
    50ea:	8c 93       	st	X, r24

	// Configure the ADC auto trigger source bits
	ADC_SFIOR &= ADC_ADTS_clear;
    50ec:	a0 e5       	ldi	r26, 0x50	; 80
    50ee:	b0 e0       	ldi	r27, 0x00	; 0
    50f0:	e0 e5       	ldi	r30, 0x50	; 80
    50f2:	f0 e0       	ldi	r31, 0x00	; 0
    50f4:	80 81       	ld	r24, Z
    50f6:	8f 71       	andi	r24, 0x1F	; 31
    50f8:	8c 93       	st	X, r24
	ADC_SFIOR |= ptr_config -> ADTS;
    50fa:	a0 e5       	ldi	r26, 0x50	; 80
    50fc:	b0 e0       	ldi	r27, 0x00	; 0
    50fe:	e0 e5       	ldi	r30, 0x50	; 80
    5100:	f0 e0       	ldi	r31, 0x00	; 0
    5102:	90 81       	ld	r25, Z
    5104:	e9 81       	ldd	r30, Y+1	; 0x01
    5106:	fa 81       	ldd	r31, Y+2	; 0x02
    5108:	81 81       	ldd	r24, Z+1	; 0x01
    510a:	86 95       	lsr	r24
    510c:	87 70       	andi	r24, 0x07	; 7
    510e:	89 2b       	or	r24, r25
    5110:	8c 93       	st	X, r24

	// Configure the ADC auto trigger enable bit
	agn_bit(ADC_ADCSRA, ADC_ADATE_pin, ptr_config -> ADATE);
    5112:	e9 81       	ldd	r30, Y+1	; 0x01
    5114:	fa 81       	ldd	r31, Y+2	; 0x02
    5116:	81 81       	ldd	r24, Z+1	; 0x01
    5118:	81 70       	andi	r24, 0x01	; 1
    511a:	88 23       	and	r24, r24
    511c:	41 f0       	breq	.+16     	; 0x512e <ADC_void_config+0x9c>
    511e:	a6 e2       	ldi	r26, 0x26	; 38
    5120:	b0 e0       	ldi	r27, 0x00	; 0
    5122:	e6 e2       	ldi	r30, 0x26	; 38
    5124:	f0 e0       	ldi	r31, 0x00	; 0
    5126:	80 81       	ld	r24, Z
    5128:	80 62       	ori	r24, 0x20	; 32
    512a:	8c 93       	st	X, r24
    512c:	07 c0       	rjmp	.+14     	; 0x513c <ADC_void_config+0xaa>
    512e:	a6 e2       	ldi	r26, 0x26	; 38
    5130:	b0 e0       	ldi	r27, 0x00	; 0
    5132:	e6 e2       	ldi	r30, 0x26	; 38
    5134:	f0 e0       	ldi	r31, 0x00	; 0
    5136:	80 81       	ld	r24, Z
    5138:	8f 7d       	andi	r24, 0xDF	; 223
    513a:	8c 93       	st	X, r24

	// Configure the ADC interrupt enable bit
	agn_bit(ADC_ADCSRA, ADC_ADIE_pin, ptr_config -> ADIE);
    513c:	e9 81       	ldd	r30, Y+1	; 0x01
    513e:	fa 81       	ldd	r31, Y+2	; 0x02
    5140:	81 81       	ldd	r24, Z+1	; 0x01
    5142:	80 71       	andi	r24, 0x10	; 16
    5144:	88 23       	and	r24, r24
    5146:	41 f0       	breq	.+16     	; 0x5158 <ADC_void_config+0xc6>
    5148:	a6 e2       	ldi	r26, 0x26	; 38
    514a:	b0 e0       	ldi	r27, 0x00	; 0
    514c:	e6 e2       	ldi	r30, 0x26	; 38
    514e:	f0 e0       	ldi	r31, 0x00	; 0
    5150:	80 81       	ld	r24, Z
    5152:	88 60       	ori	r24, 0x08	; 8
    5154:	8c 93       	st	X, r24
    5156:	07 c0       	rjmp	.+14     	; 0x5166 <ADC_void_config+0xd4>
    5158:	a6 e2       	ldi	r26, 0x26	; 38
    515a:	b0 e0       	ldi	r27, 0x00	; 0
    515c:	e6 e2       	ldi	r30, 0x26	; 38
    515e:	f0 e0       	ldi	r31, 0x00	; 0
    5160:	80 81       	ld	r24, Z
    5162:	87 7f       	andi	r24, 0xF7	; 247
    5164:	8c 93       	st	X, r24

	// Configure the Global interupt bit
	agn_bit(ADC_SREG, ADC_Global_INT, ptr_config -> ADIE);
    5166:	e9 81       	ldd	r30, Y+1	; 0x01
    5168:	fa 81       	ldd	r31, Y+2	; 0x02
    516a:	81 81       	ldd	r24, Z+1	; 0x01
    516c:	80 71       	andi	r24, 0x10	; 16
    516e:	88 23       	and	r24, r24
    5170:	41 f0       	breq	.+16     	; 0x5182 <ADC_void_config+0xf0>
    5172:	af e5       	ldi	r26, 0x5F	; 95
    5174:	b0 e0       	ldi	r27, 0x00	; 0
    5176:	ef e5       	ldi	r30, 0x5F	; 95
    5178:	f0 e0       	ldi	r31, 0x00	; 0
    517a:	80 81       	ld	r24, Z
    517c:	80 68       	ori	r24, 0x80	; 128
    517e:	8c 93       	st	X, r24
    5180:	07 c0       	rjmp	.+14     	; 0x5190 <ADC_void_config+0xfe>
    5182:	af e5       	ldi	r26, 0x5F	; 95
    5184:	b0 e0       	ldi	r27, 0x00	; 0
    5186:	ef e5       	ldi	r30, 0x5F	; 95
    5188:	f0 e0       	ldi	r31, 0x00	; 0
    518a:	80 81       	ld	r24, Z
    518c:	8f 77       	andi	r24, 0x7F	; 127
    518e:	8c 93       	st	X, r24
}
    5190:	0f 90       	pop	r0
    5192:	0f 90       	pop	r0
    5194:	cf 91       	pop	r28
    5196:	df 91       	pop	r29
    5198:	08 95       	ret

0000519a <ADC_void_start_conv>:

void ADC_void_start_conv(void){
    519a:	df 93       	push	r29
    519c:	cf 93       	push	r28
    519e:	cd b7       	in	r28, 0x3d	; 61
    51a0:	de b7       	in	r29, 0x3e	; 62
	 *	No inputs to the function.
	 *
	 *	No return from the function.
	 */
	// Enable ADC start conversion bit
	agn_bit(ADC_ADCSRA, ADC_ADSC_pin, ADC_ADSC);
    51a2:	a6 e2       	ldi	r26, 0x26	; 38
    51a4:	b0 e0       	ldi	r27, 0x00	; 0
    51a6:	e6 e2       	ldi	r30, 0x26	; 38
    51a8:	f0 e0       	ldi	r31, 0x00	; 0
    51aa:	80 81       	ld	r24, Z
    51ac:	80 64       	ori	r24, 0x40	; 64
    51ae:	8c 93       	st	X, r24
}
    51b0:	cf 91       	pop	r28
    51b2:	df 91       	pop	r29
    51b4:	08 95       	ret

000051b6 <ADC_void_read_data>:

void ADC_void_read_data(u16* ptr_result){
    51b6:	df 93       	push	r29
    51b8:	cf 93       	push	r28
    51ba:	00 d0       	rcall	.+0      	; 0x51bc <ADC_void_read_data+0x6>
    51bc:	cd b7       	in	r28, 0x3d	; 61
    51be:	de b7       	in	r29, 0x3e	; 62
    51c0:	9a 83       	std	Y+2, r25	; 0x02
    51c2:	89 83       	std	Y+1, r24	; 0x01
	 *		ptr_result>> pointer to the ADC value container variable.
	 *	
	 *	Function does not retuen any data, Hence it needs to be called when a value update is needed.
	 */
	// Enable ADC start conversion bit
	agn_bit(ADC_ADCSRA, ADC_ADSC_pin, ADC_ADSC);
    51c4:	a6 e2       	ldi	r26, 0x26	; 38
    51c6:	b0 e0       	ldi	r27, 0x00	; 0
    51c8:	e6 e2       	ldi	r30, 0x26	; 38
    51ca:	f0 e0       	ldi	r31, 0x00	; 0
    51cc:	80 81       	ld	r24, Z
    51ce:	80 64       	ori	r24, 0x40	; 64
    51d0:	8c 93       	st	X, r24

	// Polling on the ADC interrupt flag bit
	while(get_bit(ADC_ADCSRA, ADC_ADIF_pin) == 0);
    51d2:	e6 e2       	ldi	r30, 0x26	; 38
    51d4:	f0 e0       	ldi	r31, 0x00	; 0
    51d6:	80 81       	ld	r24, Z
    51d8:	82 95       	swap	r24
    51da:	8f 70       	andi	r24, 0x0F	; 15
    51dc:	88 2f       	mov	r24, r24
    51de:	90 e0       	ldi	r25, 0x00	; 0
    51e0:	81 70       	andi	r24, 0x01	; 1
    51e2:	90 70       	andi	r25, 0x00	; 0
    51e4:	00 97       	sbiw	r24, 0x00	; 0
    51e6:	a9 f3       	breq	.-22     	; 0x51d2 <ADC_void_read_data+0x1c>

	// Resit the ADC interrupt flag bit
	set_bit(ADC_ADCSRA, ADC_ADIF_pin);
    51e8:	a6 e2       	ldi	r26, 0x26	; 38
    51ea:	b0 e0       	ldi	r27, 0x00	; 0
    51ec:	e6 e2       	ldi	r30, 0x26	; 38
    51ee:	f0 e0       	ldi	r31, 0x00	; 0
    51f0:	80 81       	ld	r24, Z
    51f2:	80 61       	ori	r24, 0x10	; 16
    51f4:	8c 93       	st	X, r24

	// Return the digital value
	*(ptr_result)= ADC_ADCD_16bit;
    51f6:	e4 e2       	ldi	r30, 0x24	; 36
    51f8:	f0 e0       	ldi	r31, 0x00	; 0
    51fa:	80 81       	ld	r24, Z
    51fc:	91 81       	ldd	r25, Z+1	; 0x01
    51fe:	e9 81       	ldd	r30, Y+1	; 0x01
    5200:	fa 81       	ldd	r31, Y+2	; 0x02
    5202:	91 83       	std	Z+1, r25	; 0x01
    5204:	80 83       	st	Z, r24
}
    5206:	0f 90       	pop	r0
    5208:	0f 90       	pop	r0
    520a:	cf 91       	pop	r28
    520c:	df 91       	pop	r29
    520e:	08 95       	ret

00005210 <ADC_void_INIT_callback>:


void ADC_void_INIT_callback(void (*ptr_callback_function)(u16 ) ){
    5210:	df 93       	push	r29
    5212:	cf 93       	push	r28
    5214:	00 d0       	rcall	.+0      	; 0x5216 <ADC_void_INIT_callback+0x6>
    5216:	cd b7       	in	r28, 0x3d	; 61
    5218:	de b7       	in	r29, 0x3e	; 62
    521a:	9a 83       	std	Y+2, r25	; 0x02
    521c:	89 83       	std	Y+1, r24	; 0x01
	 *	Inputs::
	 *		ptr_callback_function>> pointer to the callback function.
	 *
	 *	Function does not return any value and anly called when addressing the callback function.
	 */
	callback_functions_address= ptr_callback_function;
    521e:	89 81       	ldd	r24, Y+1	; 0x01
    5220:	9a 81       	ldd	r25, Y+2	; 0x02
    5222:	90 93 ce 04 	sts	0x04CE, r25
    5226:	80 93 cd 04 	sts	0x04CD, r24
}
    522a:	0f 90       	pop	r0
    522c:	0f 90       	pop	r0
    522e:	cf 91       	pop	r28
    5230:	df 91       	pop	r29
    5232:	08 95       	ret

00005234 <__vector_16>:

void __vector_16(void){
    5234:	1f 92       	push	r1
    5236:	0f 92       	push	r0
    5238:	0f b6       	in	r0, 0x3f	; 63
    523a:	0f 92       	push	r0
    523c:	11 24       	eor	r1, r1
    523e:	2f 93       	push	r18
    5240:	3f 93       	push	r19
    5242:	4f 93       	push	r20
    5244:	5f 93       	push	r21
    5246:	6f 93       	push	r22
    5248:	7f 93       	push	r23
    524a:	8f 93       	push	r24
    524c:	9f 93       	push	r25
    524e:	af 93       	push	r26
    5250:	bf 93       	push	r27
    5252:	ef 93       	push	r30
    5254:	ff 93       	push	r31
    5256:	df 93       	push	r29
    5258:	cf 93       	push	r28
    525a:	cd b7       	in	r28, 0x3d	; 61
    525c:	de b7       	in	r29, 0x3e	; 62
	/*
	 *	ADC flag ISR
	 */
	if(callback_functions_address != NULL){
    525e:	80 91 cd 04 	lds	r24, 0x04CD
    5262:	90 91 ce 04 	lds	r25, 0x04CE
    5266:	00 97       	sbiw	r24, 0x00	; 0
    5268:	49 f0       	breq	.+18     	; 0x527c <__vector_16+0x48>
		callback_functions_address(ADC_ADCD_16bit);
    526a:	e0 91 cd 04 	lds	r30, 0x04CD
    526e:	f0 91 ce 04 	lds	r31, 0x04CE
    5272:	a4 e2       	ldi	r26, 0x24	; 36
    5274:	b0 e0       	ldi	r27, 0x00	; 0
    5276:	8d 91       	ld	r24, X+
    5278:	9c 91       	ld	r25, X
    527a:	09 95       	icall
	}
}
    527c:	cf 91       	pop	r28
    527e:	df 91       	pop	r29
    5280:	ff 91       	pop	r31
    5282:	ef 91       	pop	r30
    5284:	bf 91       	pop	r27
    5286:	af 91       	pop	r26
    5288:	9f 91       	pop	r25
    528a:	8f 91       	pop	r24
    528c:	7f 91       	pop	r23
    528e:	6f 91       	pop	r22
    5290:	5f 91       	pop	r21
    5292:	4f 91       	pop	r20
    5294:	3f 91       	pop	r19
    5296:	2f 91       	pop	r18
    5298:	0f 90       	pop	r0
    529a:	0f be       	out	0x3f, r0	; 63
    529c:	0f 90       	pop	r0
    529e:	1f 90       	pop	r1
    52a0:	18 95       	reti

000052a2 <Temp_sensor_voidInit>:
ADC_config_struct Temp_sensor_config = {Temp_ADC_def_ch, Temp_sensor_Prescaler, Temp_sensor_ADATE, Temp_sensor_ADTS, Temp_sensor_ADIE};


/* Implementing of the driver functions */
// Initiate the sensor through a given ADC channel
void Temp_sensor_voidInit(u8 copy_u8_ADC_ch){
    52a2:	df 93       	push	r29
    52a4:	cf 93       	push	r28
    52a6:	0f 92       	push	r0
    52a8:	cd b7       	in	r28, 0x3d	; 61
    52aa:	de b7       	in	r29, 0x3e	; 62
    52ac:	89 83       	std	Y+1, r24	; 0x01
	/*
	 *
	 */
	if((copy_u8_ADC_ch <= Temp_ADC_max_ch)){
    52ae:	89 81       	ldd	r24, Y+1	; 0x01
    52b0:	88 30       	cpi	r24, 0x08	; 8
    52b2:	50 f4       	brcc	.+20     	; 0x52c8 <Temp_sensor_voidInit+0x26>
		Temp_sensor_config.MUX = copy_u8_ADC_ch;
    52b4:	89 81       	ldd	r24, Y+1	; 0x01
    52b6:	8f 71       	andi	r24, 0x1F	; 31
    52b8:	98 2f       	mov	r25, r24
    52ba:	9f 71       	andi	r25, 0x1F	; 31
    52bc:	80 91 cf 04 	lds	r24, 0x04CF
    52c0:	80 7e       	andi	r24, 0xE0	; 224
    52c2:	89 2b       	or	r24, r25
    52c4:	80 93 cf 04 	sts	0x04CF, r24
	}
	else{

	}
	ADC_void_init();
    52c8:	0e 94 26 28 	call	0x504c	; 0x504c <ADC_void_init>
}
    52cc:	0f 90       	pop	r0
    52ce:	cf 91       	pop	r28
    52d0:	df 91       	pop	r29
    52d2:	08 95       	ret

000052d4 <Temp_sensor_voidClcTemp>:

// Calculate the current data and return it
f64 Temp_sensor_voidClcTemp(void ){
    52d4:	df 93       	push	r29
    52d6:	cf 93       	push	r28
    52d8:	cd b7       	in	r28, 0x3d	; 61
    52da:	de b7       	in	r29, 0x3e	; 62
    52dc:	29 97       	sbiw	r28, 0x09	; 9
    52de:	0f b6       	in	r0, 0x3f	; 63
    52e0:	f8 94       	cli
    52e2:	de bf       	out	0x3e, r29	; 62
    52e4:	0f be       	out	0x3f, r0	; 63
    52e6:	cd bf       	out	0x3d, r28	; 61
	/*
	 *
	 */
	u16 currentAccumulator = Temp_sensor_Val_flour;
    52e8:	1f 82       	std	Y+7, r1	; 0x07
    52ea:	1e 82       	std	Y+6, r1	; 0x06
	u16 current_ADC_data = Temp_sensor_Val_flour;
    52ec:	19 86       	std	Y+9, r1	; 0x09
    52ee:	18 86       	std	Y+8, r1	; 0x08
	ADC_void_config(&Temp_sensor_config);
    52f0:	8f ec       	ldi	r24, 0xCF	; 207
    52f2:	94 e0       	ldi	r25, 0x04	; 4
    52f4:	0e 94 49 28 	call	0x5092	; 0x5092 <ADC_void_config>
	for(u8 acc_counter= Temp_sensor_Val_flour; acc_counter < Temp_sensor_Acc; acc_counter++){
    52f8:	19 82       	std	Y+1, r1	; 0x01
    52fa:	0f c0       	rjmp	.+30     	; 0x531a <Temp_sensor_voidClcTemp+0x46>
		ADC_void_read_data(&current_ADC_data);
    52fc:	ce 01       	movw	r24, r28
    52fe:	08 96       	adiw	r24, 0x08	; 8
    5300:	0e 94 db 28 	call	0x51b6	; 0x51b6 <ADC_void_read_data>
		currentAccumulator+= current_ADC_data;
    5304:	28 85       	ldd	r18, Y+8	; 0x08
    5306:	39 85       	ldd	r19, Y+9	; 0x09
    5308:	8e 81       	ldd	r24, Y+6	; 0x06
    530a:	9f 81       	ldd	r25, Y+7	; 0x07
    530c:	82 0f       	add	r24, r18
    530e:	93 1f       	adc	r25, r19
    5310:	9f 83       	std	Y+7, r25	; 0x07
    5312:	8e 83       	std	Y+6, r24	; 0x06
	 *
	 */
	u16 currentAccumulator = Temp_sensor_Val_flour;
	u16 current_ADC_data = Temp_sensor_Val_flour;
	ADC_void_config(&Temp_sensor_config);
	for(u8 acc_counter= Temp_sensor_Val_flour; acc_counter < Temp_sensor_Acc; acc_counter++){
    5314:	89 81       	ldd	r24, Y+1	; 0x01
    5316:	8f 5f       	subi	r24, 0xFF	; 255
    5318:	89 83       	std	Y+1, r24	; 0x01
    531a:	89 81       	ldd	r24, Y+1	; 0x01
    531c:	8a 30       	cpi	r24, 0x0A	; 10
    531e:	70 f3       	brcs	.-36     	; 0x52fc <Temp_sensor_voidClcTemp+0x28>
		ADC_void_read_data(&current_ADC_data);
		currentAccumulator+= current_ADC_data;
	}
	current_ADC_data = currentAccumulator/Temp_sensor_Acc;
    5320:	8e 81       	ldd	r24, Y+6	; 0x06
    5322:	9f 81       	ldd	r25, Y+7	; 0x07
    5324:	2a e0       	ldi	r18, 0x0A	; 10
    5326:	30 e0       	ldi	r19, 0x00	; 0
    5328:	b9 01       	movw	r22, r18
    532a:	0e 94 86 4c 	call	0x990c	; 0x990c <__udivmodhi4>
    532e:	cb 01       	movw	r24, r22
    5330:	99 87       	std	Y+9, r25	; 0x09
    5332:	88 87       	std	Y+8, r24	; 0x08
	f64 current_data = ((current_ADC_data/Temp_sensor_ADC_max)*Temp_V_ref)/Volt_temp_ref;
    5334:	88 85       	ldd	r24, Y+8	; 0x08
    5336:	99 85       	ldd	r25, Y+9	; 0x09
    5338:	cc 01       	movw	r24, r24
    533a:	a0 e0       	ldi	r26, 0x00	; 0
    533c:	b0 e0       	ldi	r27, 0x00	; 0
    533e:	bc 01       	movw	r22, r24
    5340:	cd 01       	movw	r24, r26
    5342:	0e 94 07 05 	call	0xa0e	; 0xa0e <__floatunsisf>
    5346:	dc 01       	movw	r26, r24
    5348:	cb 01       	movw	r24, r22
    534a:	bc 01       	movw	r22, r24
    534c:	cd 01       	movw	r24, r26
    534e:	20 e0       	ldi	r18, 0x00	; 0
    5350:	30 e0       	ldi	r19, 0x00	; 0
    5352:	40 e8       	ldi	r20, 0x80	; 128
    5354:	54 e4       	ldi	r21, 0x44	; 68
    5356:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    535a:	dc 01       	movw	r26, r24
    535c:	cb 01       	movw	r24, r22
    535e:	bc 01       	movw	r22, r24
    5360:	cd 01       	movw	r24, r26
    5362:	20 e0       	ldi	r18, 0x00	; 0
    5364:	30 e4       	ldi	r19, 0x40	; 64
    5366:	4c e9       	ldi	r20, 0x9C	; 156
    5368:	55 e4       	ldi	r21, 0x45	; 69
    536a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    536e:	dc 01       	movw	r26, r24
    5370:	cb 01       	movw	r24, r22
    5372:	bc 01       	movw	r22, r24
    5374:	cd 01       	movw	r24, r26
    5376:	20 e0       	ldi	r18, 0x00	; 0
    5378:	30 e0       	ldi	r19, 0x00	; 0
    537a:	40 e2       	ldi	r20, 0x20	; 32
    537c:	51 e4       	ldi	r21, 0x41	; 65
    537e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    5382:	dc 01       	movw	r26, r24
    5384:	cb 01       	movw	r24, r22
    5386:	8a 83       	std	Y+2, r24	; 0x02
    5388:	9b 83       	std	Y+3, r25	; 0x03
    538a:	ac 83       	std	Y+4, r26	; 0x04
    538c:	bd 83       	std	Y+5, r27	; 0x05
	return current_data;
    538e:	8a 81       	ldd	r24, Y+2	; 0x02
    5390:	9b 81       	ldd	r25, Y+3	; 0x03
    5392:	ac 81       	ldd	r26, Y+4	; 0x04
    5394:	bd 81       	ldd	r27, Y+5	; 0x05
}
    5396:	bc 01       	movw	r22, r24
    5398:	cd 01       	movw	r24, r26
    539a:	29 96       	adiw	r28, 0x09	; 9
    539c:	0f b6       	in	r0, 0x3f	; 63
    539e:	f8 94       	cli
    53a0:	de bf       	out	0x3e, r29	; 62
    53a2:	0f be       	out	0x3f, r0	; 63
    53a4:	cd bf       	out	0x3d, r28	; 61
    53a6:	cf 91       	pop	r28
    53a8:	df 91       	pop	r29
    53aa:	08 95       	ret

000053ac <LCD_pow>:
#include "../../MCAL/DIO/DIO_interface.h"

/******************************************************************************/

/* LCD helper functions implementation */
s32 LCD_pow(u8 val, u8 power){
    53ac:	df 93       	push	r29
    53ae:	cf 93       	push	r28
    53b0:	cd b7       	in	r28, 0x3d	; 61
    53b2:	de b7       	in	r29, 0x3e	; 62
    53b4:	27 97       	sbiw	r28, 0x07	; 7
    53b6:	0f b6       	in	r0, 0x3f	; 63
    53b8:	f8 94       	cli
    53ba:	de bf       	out	0x3e, r29	; 62
    53bc:	0f be       	out	0x3f, r0	; 63
    53be:	cd bf       	out	0x3d, r28	; 61
    53c0:	8e 83       	std	Y+6, r24	; 0x06
    53c2:	6f 83       	std	Y+7, r22	; 0x07
	 *	Return::
	 *		power_res>> the result of the exponential function
	 *	Function is helper and not allowed to be used out side of the driver.
	 */
	// Create a container for the power result and set its inital value
	s32 power_res= val;
    53c4:	8e 81       	ldd	r24, Y+6	; 0x06
    53c6:	88 2f       	mov	r24, r24
    53c8:	90 e0       	ldi	r25, 0x00	; 0
    53ca:	a0 e0       	ldi	r26, 0x00	; 0
    53cc:	b0 e0       	ldi	r27, 0x00	; 0
    53ce:	8a 83       	std	Y+2, r24	; 0x02
    53d0:	9b 83       	std	Y+3, r25	; 0x03
    53d2:	ac 83       	std	Y+4, r26	; 0x04
    53d4:	bd 83       	std	Y+5, r27	; 0x05
	// Loop in the power order
	for(u8 i= 0; i< power-1; i++)
    53d6:	19 82       	std	Y+1, r1	; 0x01
    53d8:	16 c0       	rjmp	.+44     	; 0x5406 <LCD_pow+0x5a>
		// Remultibly the value by itself
		power_res*= val;
    53da:	8e 81       	ldd	r24, Y+6	; 0x06
    53dc:	28 2f       	mov	r18, r24
    53de:	30 e0       	ldi	r19, 0x00	; 0
    53e0:	40 e0       	ldi	r20, 0x00	; 0
    53e2:	50 e0       	ldi	r21, 0x00	; 0
    53e4:	8a 81       	ldd	r24, Y+2	; 0x02
    53e6:	9b 81       	ldd	r25, Y+3	; 0x03
    53e8:	ac 81       	ldd	r26, Y+4	; 0x04
    53ea:	bd 81       	ldd	r27, Y+5	; 0x05
    53ec:	bc 01       	movw	r22, r24
    53ee:	cd 01       	movw	r24, r26
    53f0:	0e 94 67 4c 	call	0x98ce	; 0x98ce <__mulsi3>
    53f4:	dc 01       	movw	r26, r24
    53f6:	cb 01       	movw	r24, r22
    53f8:	8a 83       	std	Y+2, r24	; 0x02
    53fa:	9b 83       	std	Y+3, r25	; 0x03
    53fc:	ac 83       	std	Y+4, r26	; 0x04
    53fe:	bd 83       	std	Y+5, r27	; 0x05
	 *	Function is helper and not allowed to be used out side of the driver.
	 */
	// Create a container for the power result and set its inital value
	s32 power_res= val;
	// Loop in the power order
	for(u8 i= 0; i< power-1; i++)
    5400:	89 81       	ldd	r24, Y+1	; 0x01
    5402:	8f 5f       	subi	r24, 0xFF	; 255
    5404:	89 83       	std	Y+1, r24	; 0x01
    5406:	89 81       	ldd	r24, Y+1	; 0x01
    5408:	28 2f       	mov	r18, r24
    540a:	30 e0       	ldi	r19, 0x00	; 0
    540c:	8f 81       	ldd	r24, Y+7	; 0x07
    540e:	88 2f       	mov	r24, r24
    5410:	90 e0       	ldi	r25, 0x00	; 0
    5412:	01 97       	sbiw	r24, 0x01	; 1
    5414:	28 17       	cp	r18, r24
    5416:	39 07       	cpc	r19, r25
    5418:	04 f3       	brlt	.-64     	; 0x53da <LCD_pow+0x2e>
		// Remultibly the value by itself
		power_res*= val;
	// Return the result in the container
	return power_res;
    541a:	8a 81       	ldd	r24, Y+2	; 0x02
    541c:	9b 81       	ldd	r25, Y+3	; 0x03
    541e:	ac 81       	ldd	r26, Y+4	; 0x04
    5420:	bd 81       	ldd	r27, Y+5	; 0x05
}
    5422:	bc 01       	movw	r22, r24
    5424:	cd 01       	movw	r24, r26
    5426:	27 96       	adiw	r28, 0x07	; 7
    5428:	0f b6       	in	r0, 0x3f	; 63
    542a:	f8 94       	cli
    542c:	de bf       	out	0x3e, r29	; 62
    542e:	0f be       	out	0x3f, r0	; 63
    5430:	cd bf       	out	0x3d, r28	; 61
    5432:	cf 91       	pop	r28
    5434:	df 91       	pop	r29
    5436:	08 95       	ret

00005438 <LCD_write_data_8bit>:

/******************************************************************************/

/* LCD 8bit interfacing functions implementation */
void LCD_write_data_8bit(u8 lcd_copy_word_8bit){
    5438:	df 93       	push	r29
    543a:	cf 93       	push	r28
    543c:	cd b7       	in	r28, 0x3d	; 61
    543e:	de b7       	in	r29, 0x3e	; 62
    5440:	e1 97       	sbiw	r28, 0x31	; 49
    5442:	0f b6       	in	r0, 0x3f	; 63
    5444:	f8 94       	cli
    5446:	de bf       	out	0x3e, r29	; 62
    5448:	0f be       	out	0x3f, r0	; 63
    544a:	cd bf       	out	0x3d, r28	; 61
    544c:	89 ab       	std	Y+49, r24	; 0x31
	 *		lcd_copy_word_8bit>> The data byte that needs to be sent to the LCD
	 *
	 *	Function does not return any  valus and it is helper and not allowed to be used out side of the driver.
	 */
	// Configure RS/RW pins to recive data
	DIO_void_set_pin(lcd_ctrl_port, lcd_RS);
    544e:	82 e0       	ldi	r24, 0x02	; 2
    5450:	62 e0       	ldi	r22, 0x02	; 2
    5452:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RW);
    5456:	82 e0       	ldi	r24, 0x02	; 2
    5458:	61 e0       	ldi	r22, 0x01	; 1
    545a:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    545e:	80 e0       	ldi	r24, 0x00	; 0
    5460:	90 e0       	ldi	r25, 0x00	; 0
    5462:	a0 e8       	ldi	r26, 0x80	; 128
    5464:	bf e3       	ldi	r27, 0x3F	; 63
    5466:	8d a7       	std	Y+45, r24	; 0x2d
    5468:	9e a7       	std	Y+46, r25	; 0x2e
    546a:	af a7       	std	Y+47, r26	; 0x2f
    546c:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    546e:	6d a5       	ldd	r22, Y+45	; 0x2d
    5470:	7e a5       	ldd	r23, Y+46	; 0x2e
    5472:	8f a5       	ldd	r24, Y+47	; 0x2f
    5474:	98 a9       	ldd	r25, Y+48	; 0x30
    5476:	2b ea       	ldi	r18, 0xAB	; 171
    5478:	3a ea       	ldi	r19, 0xAA	; 170
    547a:	4a ea       	ldi	r20, 0xAA	; 170
    547c:	50 e4       	ldi	r21, 0x40	; 64
    547e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5482:	dc 01       	movw	r26, r24
    5484:	cb 01       	movw	r24, r22
    5486:	89 a7       	std	Y+41, r24	; 0x29
    5488:	9a a7       	std	Y+42, r25	; 0x2a
    548a:	ab a7       	std	Y+43, r26	; 0x2b
    548c:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    548e:	69 a5       	ldd	r22, Y+41	; 0x29
    5490:	7a a5       	ldd	r23, Y+42	; 0x2a
    5492:	8b a5       	ldd	r24, Y+43	; 0x2b
    5494:	9c a5       	ldd	r25, Y+44	; 0x2c
    5496:	20 e0       	ldi	r18, 0x00	; 0
    5498:	30 e0       	ldi	r19, 0x00	; 0
    549a:	40 e8       	ldi	r20, 0x80	; 128
    549c:	5f e3       	ldi	r21, 0x3F	; 63
    549e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    54a2:	88 23       	and	r24, r24
    54a4:	1c f4       	brge	.+6      	; 0x54ac <LCD_write_data_8bit+0x74>
		__ticks = 1;
    54a6:	81 e0       	ldi	r24, 0x01	; 1
    54a8:	88 a7       	std	Y+40, r24	; 0x28
    54aa:	91 c0       	rjmp	.+290    	; 0x55ce <LCD_write_data_8bit+0x196>
	else if (__tmp > 255)
    54ac:	69 a5       	ldd	r22, Y+41	; 0x29
    54ae:	7a a5       	ldd	r23, Y+42	; 0x2a
    54b0:	8b a5       	ldd	r24, Y+43	; 0x2b
    54b2:	9c a5       	ldd	r25, Y+44	; 0x2c
    54b4:	20 e0       	ldi	r18, 0x00	; 0
    54b6:	30 e0       	ldi	r19, 0x00	; 0
    54b8:	4f e7       	ldi	r20, 0x7F	; 127
    54ba:	53 e4       	ldi	r21, 0x43	; 67
    54bc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    54c0:	18 16       	cp	r1, r24
    54c2:	0c f0       	brlt	.+2      	; 0x54c6 <LCD_write_data_8bit+0x8e>
    54c4:	7b c0       	rjmp	.+246    	; 0x55bc <LCD_write_data_8bit+0x184>
	{
		_delay_ms(__us / 1000.0);
    54c6:	6d a5       	ldd	r22, Y+45	; 0x2d
    54c8:	7e a5       	ldd	r23, Y+46	; 0x2e
    54ca:	8f a5       	ldd	r24, Y+47	; 0x2f
    54cc:	98 a9       	ldd	r25, Y+48	; 0x30
    54ce:	20 e0       	ldi	r18, 0x00	; 0
    54d0:	30 e0       	ldi	r19, 0x00	; 0
    54d2:	4a e7       	ldi	r20, 0x7A	; 122
    54d4:	54 e4       	ldi	r21, 0x44	; 68
    54d6:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    54da:	dc 01       	movw	r26, r24
    54dc:	cb 01       	movw	r24, r22
    54de:	8c a3       	std	Y+36, r24	; 0x24
    54e0:	9d a3       	std	Y+37, r25	; 0x25
    54e2:	ae a3       	std	Y+38, r26	; 0x26
    54e4:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    54e6:	6c a1       	ldd	r22, Y+36	; 0x24
    54e8:	7d a1       	ldd	r23, Y+37	; 0x25
    54ea:	8e a1       	ldd	r24, Y+38	; 0x26
    54ec:	9f a1       	ldd	r25, Y+39	; 0x27
    54ee:	20 e0       	ldi	r18, 0x00	; 0
    54f0:	30 e0       	ldi	r19, 0x00	; 0
    54f2:	4a e7       	ldi	r20, 0x7A	; 122
    54f4:	55 e4       	ldi	r21, 0x45	; 69
    54f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    54fa:	dc 01       	movw	r26, r24
    54fc:	cb 01       	movw	r24, r22
    54fe:	88 a3       	std	Y+32, r24	; 0x20
    5500:	99 a3       	std	Y+33, r25	; 0x21
    5502:	aa a3       	std	Y+34, r26	; 0x22
    5504:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    5506:	68 a1       	ldd	r22, Y+32	; 0x20
    5508:	79 a1       	ldd	r23, Y+33	; 0x21
    550a:	8a a1       	ldd	r24, Y+34	; 0x22
    550c:	9b a1       	ldd	r25, Y+35	; 0x23
    550e:	20 e0       	ldi	r18, 0x00	; 0
    5510:	30 e0       	ldi	r19, 0x00	; 0
    5512:	40 e8       	ldi	r20, 0x80	; 128
    5514:	5f e3       	ldi	r21, 0x3F	; 63
    5516:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    551a:	88 23       	and	r24, r24
    551c:	2c f4       	brge	.+10     	; 0x5528 <LCD_write_data_8bit+0xf0>
		__ticks = 1;
    551e:	81 e0       	ldi	r24, 0x01	; 1
    5520:	90 e0       	ldi	r25, 0x00	; 0
    5522:	9f 8f       	std	Y+31, r25	; 0x1f
    5524:	8e 8f       	std	Y+30, r24	; 0x1e
    5526:	3f c0       	rjmp	.+126    	; 0x55a6 <LCD_write_data_8bit+0x16e>
	else if (__tmp > 65535)
    5528:	68 a1       	ldd	r22, Y+32	; 0x20
    552a:	79 a1       	ldd	r23, Y+33	; 0x21
    552c:	8a a1       	ldd	r24, Y+34	; 0x22
    552e:	9b a1       	ldd	r25, Y+35	; 0x23
    5530:	20 e0       	ldi	r18, 0x00	; 0
    5532:	3f ef       	ldi	r19, 0xFF	; 255
    5534:	4f e7       	ldi	r20, 0x7F	; 127
    5536:	57 e4       	ldi	r21, 0x47	; 71
    5538:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    553c:	18 16       	cp	r1, r24
    553e:	4c f5       	brge	.+82     	; 0x5592 <LCD_write_data_8bit+0x15a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5540:	6c a1       	ldd	r22, Y+36	; 0x24
    5542:	7d a1       	ldd	r23, Y+37	; 0x25
    5544:	8e a1       	ldd	r24, Y+38	; 0x26
    5546:	9f a1       	ldd	r25, Y+39	; 0x27
    5548:	20 e0       	ldi	r18, 0x00	; 0
    554a:	30 e0       	ldi	r19, 0x00	; 0
    554c:	40 e2       	ldi	r20, 0x20	; 32
    554e:	51 e4       	ldi	r21, 0x41	; 65
    5550:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5554:	dc 01       	movw	r26, r24
    5556:	cb 01       	movw	r24, r22
    5558:	bc 01       	movw	r22, r24
    555a:	cd 01       	movw	r24, r26
    555c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5560:	dc 01       	movw	r26, r24
    5562:	cb 01       	movw	r24, r22
    5564:	9f 8f       	std	Y+31, r25	; 0x1f
    5566:	8e 8f       	std	Y+30, r24	; 0x1e
    5568:	0f c0       	rjmp	.+30     	; 0x5588 <LCD_write_data_8bit+0x150>
    556a:	80 e9       	ldi	r24, 0x90	; 144
    556c:	91 e0       	ldi	r25, 0x01	; 1
    556e:	9d 8f       	std	Y+29, r25	; 0x1d
    5570:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5572:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5574:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5576:	01 97       	sbiw	r24, 0x01	; 1
    5578:	f1 f7       	brne	.-4      	; 0x5576 <LCD_write_data_8bit+0x13e>
    557a:	9d 8f       	std	Y+29, r25	; 0x1d
    557c:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    557e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    5580:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5582:	01 97       	sbiw	r24, 0x01	; 1
    5584:	9f 8f       	std	Y+31, r25	; 0x1f
    5586:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5588:	8e 8d       	ldd	r24, Y+30	; 0x1e
    558a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    558c:	00 97       	sbiw	r24, 0x00	; 0
    558e:	69 f7       	brne	.-38     	; 0x556a <LCD_write_data_8bit+0x132>
    5590:	24 c0       	rjmp	.+72     	; 0x55da <LCD_write_data_8bit+0x1a2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5592:	68 a1       	ldd	r22, Y+32	; 0x20
    5594:	79 a1       	ldd	r23, Y+33	; 0x21
    5596:	8a a1       	ldd	r24, Y+34	; 0x22
    5598:	9b a1       	ldd	r25, Y+35	; 0x23
    559a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    559e:	dc 01       	movw	r26, r24
    55a0:	cb 01       	movw	r24, r22
    55a2:	9f 8f       	std	Y+31, r25	; 0x1f
    55a4:	8e 8f       	std	Y+30, r24	; 0x1e
    55a6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    55a8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    55aa:	9b 8f       	std	Y+27, r25	; 0x1b
    55ac:	8a 8f       	std	Y+26, r24	; 0x1a
    55ae:	8a 8d       	ldd	r24, Y+26	; 0x1a
    55b0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    55b2:	01 97       	sbiw	r24, 0x01	; 1
    55b4:	f1 f7       	brne	.-4      	; 0x55b2 <LCD_write_data_8bit+0x17a>
    55b6:	9b 8f       	std	Y+27, r25	; 0x1b
    55b8:	8a 8f       	std	Y+26, r24	; 0x1a
    55ba:	0f c0       	rjmp	.+30     	; 0x55da <LCD_write_data_8bit+0x1a2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    55bc:	69 a5       	ldd	r22, Y+41	; 0x29
    55be:	7a a5       	ldd	r23, Y+42	; 0x2a
    55c0:	8b a5       	ldd	r24, Y+43	; 0x2b
    55c2:	9c a5       	ldd	r25, Y+44	; 0x2c
    55c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    55c8:	dc 01       	movw	r26, r24
    55ca:	cb 01       	movw	r24, r22
    55cc:	88 a7       	std	Y+40, r24	; 0x28
    55ce:	88 a5       	ldd	r24, Y+40	; 0x28
    55d0:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    55d2:	89 8d       	ldd	r24, Y+25	; 0x19
    55d4:	8a 95       	dec	r24
    55d6:	f1 f7       	brne	.-4      	; 0x55d4 <LCD_write_data_8bit+0x19c>
    55d8:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1);
	// Enable pin is high to send the packet
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    55da:	82 e0       	ldi	r24, 0x02	; 2
    55dc:	60 e0       	ldi	r22, 0x00	; 0
    55de:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    55e2:	80 e0       	ldi	r24, 0x00	; 0
    55e4:	90 e0       	ldi	r25, 0x00	; 0
    55e6:	a0 e8       	ldi	r26, 0x80	; 128
    55e8:	bf e3       	ldi	r27, 0x3F	; 63
    55ea:	8d 8b       	std	Y+21, r24	; 0x15
    55ec:	9e 8b       	std	Y+22, r25	; 0x16
    55ee:	af 8b       	std	Y+23, r26	; 0x17
    55f0:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    55f2:	6d 89       	ldd	r22, Y+21	; 0x15
    55f4:	7e 89       	ldd	r23, Y+22	; 0x16
    55f6:	8f 89       	ldd	r24, Y+23	; 0x17
    55f8:	98 8d       	ldd	r25, Y+24	; 0x18
    55fa:	2b ea       	ldi	r18, 0xAB	; 171
    55fc:	3a ea       	ldi	r19, 0xAA	; 170
    55fe:	4a ea       	ldi	r20, 0xAA	; 170
    5600:	50 e4       	ldi	r21, 0x40	; 64
    5602:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5606:	dc 01       	movw	r26, r24
    5608:	cb 01       	movw	r24, r22
    560a:	89 8b       	std	Y+17, r24	; 0x11
    560c:	9a 8b       	std	Y+18, r25	; 0x12
    560e:	ab 8b       	std	Y+19, r26	; 0x13
    5610:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    5612:	69 89       	ldd	r22, Y+17	; 0x11
    5614:	7a 89       	ldd	r23, Y+18	; 0x12
    5616:	8b 89       	ldd	r24, Y+19	; 0x13
    5618:	9c 89       	ldd	r25, Y+20	; 0x14
    561a:	20 e0       	ldi	r18, 0x00	; 0
    561c:	30 e0       	ldi	r19, 0x00	; 0
    561e:	40 e8       	ldi	r20, 0x80	; 128
    5620:	5f e3       	ldi	r21, 0x3F	; 63
    5622:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5626:	88 23       	and	r24, r24
    5628:	1c f4       	brge	.+6      	; 0x5630 <LCD_write_data_8bit+0x1f8>
		__ticks = 1;
    562a:	81 e0       	ldi	r24, 0x01	; 1
    562c:	88 8b       	std	Y+16, r24	; 0x10
    562e:	91 c0       	rjmp	.+290    	; 0x5752 <LCD_write_data_8bit+0x31a>
	else if (__tmp > 255)
    5630:	69 89       	ldd	r22, Y+17	; 0x11
    5632:	7a 89       	ldd	r23, Y+18	; 0x12
    5634:	8b 89       	ldd	r24, Y+19	; 0x13
    5636:	9c 89       	ldd	r25, Y+20	; 0x14
    5638:	20 e0       	ldi	r18, 0x00	; 0
    563a:	30 e0       	ldi	r19, 0x00	; 0
    563c:	4f e7       	ldi	r20, 0x7F	; 127
    563e:	53 e4       	ldi	r21, 0x43	; 67
    5640:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5644:	18 16       	cp	r1, r24
    5646:	0c f0       	brlt	.+2      	; 0x564a <LCD_write_data_8bit+0x212>
    5648:	7b c0       	rjmp	.+246    	; 0x5740 <LCD_write_data_8bit+0x308>
	{
		_delay_ms(__us / 1000.0);
    564a:	6d 89       	ldd	r22, Y+21	; 0x15
    564c:	7e 89       	ldd	r23, Y+22	; 0x16
    564e:	8f 89       	ldd	r24, Y+23	; 0x17
    5650:	98 8d       	ldd	r25, Y+24	; 0x18
    5652:	20 e0       	ldi	r18, 0x00	; 0
    5654:	30 e0       	ldi	r19, 0x00	; 0
    5656:	4a e7       	ldi	r20, 0x7A	; 122
    5658:	54 e4       	ldi	r21, 0x44	; 68
    565a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    565e:	dc 01       	movw	r26, r24
    5660:	cb 01       	movw	r24, r22
    5662:	8c 87       	std	Y+12, r24	; 0x0c
    5664:	9d 87       	std	Y+13, r25	; 0x0d
    5666:	ae 87       	std	Y+14, r26	; 0x0e
    5668:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    566a:	6c 85       	ldd	r22, Y+12	; 0x0c
    566c:	7d 85       	ldd	r23, Y+13	; 0x0d
    566e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5670:	9f 85       	ldd	r25, Y+15	; 0x0f
    5672:	20 e0       	ldi	r18, 0x00	; 0
    5674:	30 e0       	ldi	r19, 0x00	; 0
    5676:	4a e7       	ldi	r20, 0x7A	; 122
    5678:	55 e4       	ldi	r21, 0x45	; 69
    567a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    567e:	dc 01       	movw	r26, r24
    5680:	cb 01       	movw	r24, r22
    5682:	88 87       	std	Y+8, r24	; 0x08
    5684:	99 87       	std	Y+9, r25	; 0x09
    5686:	aa 87       	std	Y+10, r26	; 0x0a
    5688:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    568a:	68 85       	ldd	r22, Y+8	; 0x08
    568c:	79 85       	ldd	r23, Y+9	; 0x09
    568e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5690:	9b 85       	ldd	r25, Y+11	; 0x0b
    5692:	20 e0       	ldi	r18, 0x00	; 0
    5694:	30 e0       	ldi	r19, 0x00	; 0
    5696:	40 e8       	ldi	r20, 0x80	; 128
    5698:	5f e3       	ldi	r21, 0x3F	; 63
    569a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    569e:	88 23       	and	r24, r24
    56a0:	2c f4       	brge	.+10     	; 0x56ac <LCD_write_data_8bit+0x274>
		__ticks = 1;
    56a2:	81 e0       	ldi	r24, 0x01	; 1
    56a4:	90 e0       	ldi	r25, 0x00	; 0
    56a6:	9f 83       	std	Y+7, r25	; 0x07
    56a8:	8e 83       	std	Y+6, r24	; 0x06
    56aa:	3f c0       	rjmp	.+126    	; 0x572a <LCD_write_data_8bit+0x2f2>
	else if (__tmp > 65535)
    56ac:	68 85       	ldd	r22, Y+8	; 0x08
    56ae:	79 85       	ldd	r23, Y+9	; 0x09
    56b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    56b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    56b4:	20 e0       	ldi	r18, 0x00	; 0
    56b6:	3f ef       	ldi	r19, 0xFF	; 255
    56b8:	4f e7       	ldi	r20, 0x7F	; 127
    56ba:	57 e4       	ldi	r21, 0x47	; 71
    56bc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    56c0:	18 16       	cp	r1, r24
    56c2:	4c f5       	brge	.+82     	; 0x5716 <LCD_write_data_8bit+0x2de>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    56c4:	6c 85       	ldd	r22, Y+12	; 0x0c
    56c6:	7d 85       	ldd	r23, Y+13	; 0x0d
    56c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    56ca:	9f 85       	ldd	r25, Y+15	; 0x0f
    56cc:	20 e0       	ldi	r18, 0x00	; 0
    56ce:	30 e0       	ldi	r19, 0x00	; 0
    56d0:	40 e2       	ldi	r20, 0x20	; 32
    56d2:	51 e4       	ldi	r21, 0x41	; 65
    56d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    56d8:	dc 01       	movw	r26, r24
    56da:	cb 01       	movw	r24, r22
    56dc:	bc 01       	movw	r22, r24
    56de:	cd 01       	movw	r24, r26
    56e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    56e4:	dc 01       	movw	r26, r24
    56e6:	cb 01       	movw	r24, r22
    56e8:	9f 83       	std	Y+7, r25	; 0x07
    56ea:	8e 83       	std	Y+6, r24	; 0x06
    56ec:	0f c0       	rjmp	.+30     	; 0x570c <LCD_write_data_8bit+0x2d4>
    56ee:	80 e9       	ldi	r24, 0x90	; 144
    56f0:	91 e0       	ldi	r25, 0x01	; 1
    56f2:	9d 83       	std	Y+5, r25	; 0x05
    56f4:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    56f6:	8c 81       	ldd	r24, Y+4	; 0x04
    56f8:	9d 81       	ldd	r25, Y+5	; 0x05
    56fa:	01 97       	sbiw	r24, 0x01	; 1
    56fc:	f1 f7       	brne	.-4      	; 0x56fa <LCD_write_data_8bit+0x2c2>
    56fe:	9d 83       	std	Y+5, r25	; 0x05
    5700:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5702:	8e 81       	ldd	r24, Y+6	; 0x06
    5704:	9f 81       	ldd	r25, Y+7	; 0x07
    5706:	01 97       	sbiw	r24, 0x01	; 1
    5708:	9f 83       	std	Y+7, r25	; 0x07
    570a:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    570c:	8e 81       	ldd	r24, Y+6	; 0x06
    570e:	9f 81       	ldd	r25, Y+7	; 0x07
    5710:	00 97       	sbiw	r24, 0x00	; 0
    5712:	69 f7       	brne	.-38     	; 0x56ee <LCD_write_data_8bit+0x2b6>
    5714:	24 c0       	rjmp	.+72     	; 0x575e <LCD_write_data_8bit+0x326>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5716:	68 85       	ldd	r22, Y+8	; 0x08
    5718:	79 85       	ldd	r23, Y+9	; 0x09
    571a:	8a 85       	ldd	r24, Y+10	; 0x0a
    571c:	9b 85       	ldd	r25, Y+11	; 0x0b
    571e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5722:	dc 01       	movw	r26, r24
    5724:	cb 01       	movw	r24, r22
    5726:	9f 83       	std	Y+7, r25	; 0x07
    5728:	8e 83       	std	Y+6, r24	; 0x06
    572a:	8e 81       	ldd	r24, Y+6	; 0x06
    572c:	9f 81       	ldd	r25, Y+7	; 0x07
    572e:	9b 83       	std	Y+3, r25	; 0x03
    5730:	8a 83       	std	Y+2, r24	; 0x02
    5732:	8a 81       	ldd	r24, Y+2	; 0x02
    5734:	9b 81       	ldd	r25, Y+3	; 0x03
    5736:	01 97       	sbiw	r24, 0x01	; 1
    5738:	f1 f7       	brne	.-4      	; 0x5736 <LCD_write_data_8bit+0x2fe>
    573a:	9b 83       	std	Y+3, r25	; 0x03
    573c:	8a 83       	std	Y+2, r24	; 0x02
    573e:	0f c0       	rjmp	.+30     	; 0x575e <LCD_write_data_8bit+0x326>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5740:	69 89       	ldd	r22, Y+17	; 0x11
    5742:	7a 89       	ldd	r23, Y+18	; 0x12
    5744:	8b 89       	ldd	r24, Y+19	; 0x13
    5746:	9c 89       	ldd	r25, Y+20	; 0x14
    5748:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    574c:	dc 01       	movw	r26, r24
    574e:	cb 01       	movw	r24, r22
    5750:	88 8b       	std	Y+16, r24	; 0x10
    5752:	88 89       	ldd	r24, Y+16	; 0x10
    5754:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5756:	89 81       	ldd	r24, Y+1	; 0x01
    5758:	8a 95       	dec	r24
    575a:	f1 f7       	brne	.-4      	; 0x5758 <LCD_write_data_8bit+0x320>
    575c:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	// Sent the data packet
	DIO_void_assign_port(lcd_data_port, lcd_copy_word_8bit);
    575e:	82 e0       	ldi	r24, 0x02	; 2
    5760:	69 a9       	ldd	r22, Y+49	; 0x31
    5762:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <DIO_void_assign_port>
	// Enable pin low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    5766:	82 e0       	ldi	r24, 0x02	; 2
    5768:	60 e0       	ldi	r22, 0x00	; 0
    576a:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
}
    576e:	e1 96       	adiw	r28, 0x31	; 49
    5770:	0f b6       	in	r0, 0x3f	; 63
    5772:	f8 94       	cli
    5774:	de bf       	out	0x3e, r29	; 62
    5776:	0f be       	out	0x3f, r0	; 63
    5778:	cd bf       	out	0x3d, r28	; 61
    577a:	cf 91       	pop	r28
    577c:	df 91       	pop	r29
    577e:	08 95       	ret

00005780 <LCD_write_cmd_8bit>:

void LCD_write_cmd_8bit(u8 lcd_copy_cmd_8bit){
    5780:	df 93       	push	r29
    5782:	cf 93       	push	r28
    5784:	cd b7       	in	r28, 0x3d	; 61
    5786:	de b7       	in	r29, 0x3e	; 62
    5788:	e1 97       	sbiw	r28, 0x31	; 49
    578a:	0f b6       	in	r0, 0x3f	; 63
    578c:	f8 94       	cli
    578e:	de bf       	out	0x3e, r29	; 62
    5790:	0f be       	out	0x3f, r0	; 63
    5792:	cd bf       	out	0x3d, r28	; 61
    5794:	89 ab       	std	Y+49, r24	; 0x31
	 *		lcd_copy_cmd_8bit>> The comand byte that needs to be sent to the LCD
	 *
	 *	Function does not return any  valus and it is helper and not allowed to be used out side of the driver.
	 */
	// Configure RS/RW pins to recive command
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RS);
    5796:	82 e0       	ldi	r24, 0x02	; 2
    5798:	62 e0       	ldi	r22, 0x02	; 2
    579a:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RW);
    579e:	82 e0       	ldi	r24, 0x02	; 2
    57a0:	61 e0       	ldi	r22, 0x01	; 1
    57a2:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    57a6:	80 e0       	ldi	r24, 0x00	; 0
    57a8:	90 e0       	ldi	r25, 0x00	; 0
    57aa:	a0 e8       	ldi	r26, 0x80	; 128
    57ac:	bf e3       	ldi	r27, 0x3F	; 63
    57ae:	8d a7       	std	Y+45, r24	; 0x2d
    57b0:	9e a7       	std	Y+46, r25	; 0x2e
    57b2:	af a7       	std	Y+47, r26	; 0x2f
    57b4:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    57b6:	6d a5       	ldd	r22, Y+45	; 0x2d
    57b8:	7e a5       	ldd	r23, Y+46	; 0x2e
    57ba:	8f a5       	ldd	r24, Y+47	; 0x2f
    57bc:	98 a9       	ldd	r25, Y+48	; 0x30
    57be:	2b ea       	ldi	r18, 0xAB	; 171
    57c0:	3a ea       	ldi	r19, 0xAA	; 170
    57c2:	4a ea       	ldi	r20, 0xAA	; 170
    57c4:	50 e4       	ldi	r21, 0x40	; 64
    57c6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    57ca:	dc 01       	movw	r26, r24
    57cc:	cb 01       	movw	r24, r22
    57ce:	89 a7       	std	Y+41, r24	; 0x29
    57d0:	9a a7       	std	Y+42, r25	; 0x2a
    57d2:	ab a7       	std	Y+43, r26	; 0x2b
    57d4:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    57d6:	69 a5       	ldd	r22, Y+41	; 0x29
    57d8:	7a a5       	ldd	r23, Y+42	; 0x2a
    57da:	8b a5       	ldd	r24, Y+43	; 0x2b
    57dc:	9c a5       	ldd	r25, Y+44	; 0x2c
    57de:	20 e0       	ldi	r18, 0x00	; 0
    57e0:	30 e0       	ldi	r19, 0x00	; 0
    57e2:	40 e8       	ldi	r20, 0x80	; 128
    57e4:	5f e3       	ldi	r21, 0x3F	; 63
    57e6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    57ea:	88 23       	and	r24, r24
    57ec:	1c f4       	brge	.+6      	; 0x57f4 <LCD_write_cmd_8bit+0x74>
		__ticks = 1;
    57ee:	81 e0       	ldi	r24, 0x01	; 1
    57f0:	88 a7       	std	Y+40, r24	; 0x28
    57f2:	91 c0       	rjmp	.+290    	; 0x5916 <LCD_write_cmd_8bit+0x196>
	else if (__tmp > 255)
    57f4:	69 a5       	ldd	r22, Y+41	; 0x29
    57f6:	7a a5       	ldd	r23, Y+42	; 0x2a
    57f8:	8b a5       	ldd	r24, Y+43	; 0x2b
    57fa:	9c a5       	ldd	r25, Y+44	; 0x2c
    57fc:	20 e0       	ldi	r18, 0x00	; 0
    57fe:	30 e0       	ldi	r19, 0x00	; 0
    5800:	4f e7       	ldi	r20, 0x7F	; 127
    5802:	53 e4       	ldi	r21, 0x43	; 67
    5804:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5808:	18 16       	cp	r1, r24
    580a:	0c f0       	brlt	.+2      	; 0x580e <LCD_write_cmd_8bit+0x8e>
    580c:	7b c0       	rjmp	.+246    	; 0x5904 <LCD_write_cmd_8bit+0x184>
	{
		_delay_ms(__us / 1000.0);
    580e:	6d a5       	ldd	r22, Y+45	; 0x2d
    5810:	7e a5       	ldd	r23, Y+46	; 0x2e
    5812:	8f a5       	ldd	r24, Y+47	; 0x2f
    5814:	98 a9       	ldd	r25, Y+48	; 0x30
    5816:	20 e0       	ldi	r18, 0x00	; 0
    5818:	30 e0       	ldi	r19, 0x00	; 0
    581a:	4a e7       	ldi	r20, 0x7A	; 122
    581c:	54 e4       	ldi	r21, 0x44	; 68
    581e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    5822:	dc 01       	movw	r26, r24
    5824:	cb 01       	movw	r24, r22
    5826:	8c a3       	std	Y+36, r24	; 0x24
    5828:	9d a3       	std	Y+37, r25	; 0x25
    582a:	ae a3       	std	Y+38, r26	; 0x26
    582c:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    582e:	6c a1       	ldd	r22, Y+36	; 0x24
    5830:	7d a1       	ldd	r23, Y+37	; 0x25
    5832:	8e a1       	ldd	r24, Y+38	; 0x26
    5834:	9f a1       	ldd	r25, Y+39	; 0x27
    5836:	20 e0       	ldi	r18, 0x00	; 0
    5838:	30 e0       	ldi	r19, 0x00	; 0
    583a:	4a e7       	ldi	r20, 0x7A	; 122
    583c:	55 e4       	ldi	r21, 0x45	; 69
    583e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5842:	dc 01       	movw	r26, r24
    5844:	cb 01       	movw	r24, r22
    5846:	88 a3       	std	Y+32, r24	; 0x20
    5848:	99 a3       	std	Y+33, r25	; 0x21
    584a:	aa a3       	std	Y+34, r26	; 0x22
    584c:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    584e:	68 a1       	ldd	r22, Y+32	; 0x20
    5850:	79 a1       	ldd	r23, Y+33	; 0x21
    5852:	8a a1       	ldd	r24, Y+34	; 0x22
    5854:	9b a1       	ldd	r25, Y+35	; 0x23
    5856:	20 e0       	ldi	r18, 0x00	; 0
    5858:	30 e0       	ldi	r19, 0x00	; 0
    585a:	40 e8       	ldi	r20, 0x80	; 128
    585c:	5f e3       	ldi	r21, 0x3F	; 63
    585e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5862:	88 23       	and	r24, r24
    5864:	2c f4       	brge	.+10     	; 0x5870 <LCD_write_cmd_8bit+0xf0>
		__ticks = 1;
    5866:	81 e0       	ldi	r24, 0x01	; 1
    5868:	90 e0       	ldi	r25, 0x00	; 0
    586a:	9f 8f       	std	Y+31, r25	; 0x1f
    586c:	8e 8f       	std	Y+30, r24	; 0x1e
    586e:	3f c0       	rjmp	.+126    	; 0x58ee <LCD_write_cmd_8bit+0x16e>
	else if (__tmp > 65535)
    5870:	68 a1       	ldd	r22, Y+32	; 0x20
    5872:	79 a1       	ldd	r23, Y+33	; 0x21
    5874:	8a a1       	ldd	r24, Y+34	; 0x22
    5876:	9b a1       	ldd	r25, Y+35	; 0x23
    5878:	20 e0       	ldi	r18, 0x00	; 0
    587a:	3f ef       	ldi	r19, 0xFF	; 255
    587c:	4f e7       	ldi	r20, 0x7F	; 127
    587e:	57 e4       	ldi	r21, 0x47	; 71
    5880:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5884:	18 16       	cp	r1, r24
    5886:	4c f5       	brge	.+82     	; 0x58da <LCD_write_cmd_8bit+0x15a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5888:	6c a1       	ldd	r22, Y+36	; 0x24
    588a:	7d a1       	ldd	r23, Y+37	; 0x25
    588c:	8e a1       	ldd	r24, Y+38	; 0x26
    588e:	9f a1       	ldd	r25, Y+39	; 0x27
    5890:	20 e0       	ldi	r18, 0x00	; 0
    5892:	30 e0       	ldi	r19, 0x00	; 0
    5894:	40 e2       	ldi	r20, 0x20	; 32
    5896:	51 e4       	ldi	r21, 0x41	; 65
    5898:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    589c:	dc 01       	movw	r26, r24
    589e:	cb 01       	movw	r24, r22
    58a0:	bc 01       	movw	r22, r24
    58a2:	cd 01       	movw	r24, r26
    58a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    58a8:	dc 01       	movw	r26, r24
    58aa:	cb 01       	movw	r24, r22
    58ac:	9f 8f       	std	Y+31, r25	; 0x1f
    58ae:	8e 8f       	std	Y+30, r24	; 0x1e
    58b0:	0f c0       	rjmp	.+30     	; 0x58d0 <LCD_write_cmd_8bit+0x150>
    58b2:	80 e9       	ldi	r24, 0x90	; 144
    58b4:	91 e0       	ldi	r25, 0x01	; 1
    58b6:	9d 8f       	std	Y+29, r25	; 0x1d
    58b8:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    58ba:	8c 8d       	ldd	r24, Y+28	; 0x1c
    58bc:	9d 8d       	ldd	r25, Y+29	; 0x1d
    58be:	01 97       	sbiw	r24, 0x01	; 1
    58c0:	f1 f7       	brne	.-4      	; 0x58be <LCD_write_cmd_8bit+0x13e>
    58c2:	9d 8f       	std	Y+29, r25	; 0x1d
    58c4:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    58c6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    58c8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    58ca:	01 97       	sbiw	r24, 0x01	; 1
    58cc:	9f 8f       	std	Y+31, r25	; 0x1f
    58ce:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    58d0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    58d2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    58d4:	00 97       	sbiw	r24, 0x00	; 0
    58d6:	69 f7       	brne	.-38     	; 0x58b2 <LCD_write_cmd_8bit+0x132>
    58d8:	24 c0       	rjmp	.+72     	; 0x5922 <LCD_write_cmd_8bit+0x1a2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    58da:	68 a1       	ldd	r22, Y+32	; 0x20
    58dc:	79 a1       	ldd	r23, Y+33	; 0x21
    58de:	8a a1       	ldd	r24, Y+34	; 0x22
    58e0:	9b a1       	ldd	r25, Y+35	; 0x23
    58e2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    58e6:	dc 01       	movw	r26, r24
    58e8:	cb 01       	movw	r24, r22
    58ea:	9f 8f       	std	Y+31, r25	; 0x1f
    58ec:	8e 8f       	std	Y+30, r24	; 0x1e
    58ee:	8e 8d       	ldd	r24, Y+30	; 0x1e
    58f0:	9f 8d       	ldd	r25, Y+31	; 0x1f
    58f2:	9b 8f       	std	Y+27, r25	; 0x1b
    58f4:	8a 8f       	std	Y+26, r24	; 0x1a
    58f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    58f8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    58fa:	01 97       	sbiw	r24, 0x01	; 1
    58fc:	f1 f7       	brne	.-4      	; 0x58fa <LCD_write_cmd_8bit+0x17a>
    58fe:	9b 8f       	std	Y+27, r25	; 0x1b
    5900:	8a 8f       	std	Y+26, r24	; 0x1a
    5902:	0f c0       	rjmp	.+30     	; 0x5922 <LCD_write_cmd_8bit+0x1a2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5904:	69 a5       	ldd	r22, Y+41	; 0x29
    5906:	7a a5       	ldd	r23, Y+42	; 0x2a
    5908:	8b a5       	ldd	r24, Y+43	; 0x2b
    590a:	9c a5       	ldd	r25, Y+44	; 0x2c
    590c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5910:	dc 01       	movw	r26, r24
    5912:	cb 01       	movw	r24, r22
    5914:	88 a7       	std	Y+40, r24	; 0x28
    5916:	88 a5       	ldd	r24, Y+40	; 0x28
    5918:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    591a:	89 8d       	ldd	r24, Y+25	; 0x19
    591c:	8a 95       	dec	r24
    591e:	f1 f7       	brne	.-4      	; 0x591c <LCD_write_cmd_8bit+0x19c>
    5920:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1);
	// Enable pin is high to send the packet
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    5922:	82 e0       	ldi	r24, 0x02	; 2
    5924:	60 e0       	ldi	r22, 0x00	; 0
    5926:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    592a:	80 e0       	ldi	r24, 0x00	; 0
    592c:	90 e0       	ldi	r25, 0x00	; 0
    592e:	a0 e8       	ldi	r26, 0x80	; 128
    5930:	bf e3       	ldi	r27, 0x3F	; 63
    5932:	8d 8b       	std	Y+21, r24	; 0x15
    5934:	9e 8b       	std	Y+22, r25	; 0x16
    5936:	af 8b       	std	Y+23, r26	; 0x17
    5938:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    593a:	6d 89       	ldd	r22, Y+21	; 0x15
    593c:	7e 89       	ldd	r23, Y+22	; 0x16
    593e:	8f 89       	ldd	r24, Y+23	; 0x17
    5940:	98 8d       	ldd	r25, Y+24	; 0x18
    5942:	2b ea       	ldi	r18, 0xAB	; 171
    5944:	3a ea       	ldi	r19, 0xAA	; 170
    5946:	4a ea       	ldi	r20, 0xAA	; 170
    5948:	50 e4       	ldi	r21, 0x40	; 64
    594a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    594e:	dc 01       	movw	r26, r24
    5950:	cb 01       	movw	r24, r22
    5952:	89 8b       	std	Y+17, r24	; 0x11
    5954:	9a 8b       	std	Y+18, r25	; 0x12
    5956:	ab 8b       	std	Y+19, r26	; 0x13
    5958:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    595a:	69 89       	ldd	r22, Y+17	; 0x11
    595c:	7a 89       	ldd	r23, Y+18	; 0x12
    595e:	8b 89       	ldd	r24, Y+19	; 0x13
    5960:	9c 89       	ldd	r25, Y+20	; 0x14
    5962:	20 e0       	ldi	r18, 0x00	; 0
    5964:	30 e0       	ldi	r19, 0x00	; 0
    5966:	40 e8       	ldi	r20, 0x80	; 128
    5968:	5f e3       	ldi	r21, 0x3F	; 63
    596a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    596e:	88 23       	and	r24, r24
    5970:	1c f4       	brge	.+6      	; 0x5978 <LCD_write_cmd_8bit+0x1f8>
		__ticks = 1;
    5972:	81 e0       	ldi	r24, 0x01	; 1
    5974:	88 8b       	std	Y+16, r24	; 0x10
    5976:	91 c0       	rjmp	.+290    	; 0x5a9a <LCD_write_cmd_8bit+0x31a>
	else if (__tmp > 255)
    5978:	69 89       	ldd	r22, Y+17	; 0x11
    597a:	7a 89       	ldd	r23, Y+18	; 0x12
    597c:	8b 89       	ldd	r24, Y+19	; 0x13
    597e:	9c 89       	ldd	r25, Y+20	; 0x14
    5980:	20 e0       	ldi	r18, 0x00	; 0
    5982:	30 e0       	ldi	r19, 0x00	; 0
    5984:	4f e7       	ldi	r20, 0x7F	; 127
    5986:	53 e4       	ldi	r21, 0x43	; 67
    5988:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    598c:	18 16       	cp	r1, r24
    598e:	0c f0       	brlt	.+2      	; 0x5992 <LCD_write_cmd_8bit+0x212>
    5990:	7b c0       	rjmp	.+246    	; 0x5a88 <LCD_write_cmd_8bit+0x308>
	{
		_delay_ms(__us / 1000.0);
    5992:	6d 89       	ldd	r22, Y+21	; 0x15
    5994:	7e 89       	ldd	r23, Y+22	; 0x16
    5996:	8f 89       	ldd	r24, Y+23	; 0x17
    5998:	98 8d       	ldd	r25, Y+24	; 0x18
    599a:	20 e0       	ldi	r18, 0x00	; 0
    599c:	30 e0       	ldi	r19, 0x00	; 0
    599e:	4a e7       	ldi	r20, 0x7A	; 122
    59a0:	54 e4       	ldi	r21, 0x44	; 68
    59a2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    59a6:	dc 01       	movw	r26, r24
    59a8:	cb 01       	movw	r24, r22
    59aa:	8c 87       	std	Y+12, r24	; 0x0c
    59ac:	9d 87       	std	Y+13, r25	; 0x0d
    59ae:	ae 87       	std	Y+14, r26	; 0x0e
    59b0:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    59b2:	6c 85       	ldd	r22, Y+12	; 0x0c
    59b4:	7d 85       	ldd	r23, Y+13	; 0x0d
    59b6:	8e 85       	ldd	r24, Y+14	; 0x0e
    59b8:	9f 85       	ldd	r25, Y+15	; 0x0f
    59ba:	20 e0       	ldi	r18, 0x00	; 0
    59bc:	30 e0       	ldi	r19, 0x00	; 0
    59be:	4a e7       	ldi	r20, 0x7A	; 122
    59c0:	55 e4       	ldi	r21, 0x45	; 69
    59c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    59c6:	dc 01       	movw	r26, r24
    59c8:	cb 01       	movw	r24, r22
    59ca:	88 87       	std	Y+8, r24	; 0x08
    59cc:	99 87       	std	Y+9, r25	; 0x09
    59ce:	aa 87       	std	Y+10, r26	; 0x0a
    59d0:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    59d2:	68 85       	ldd	r22, Y+8	; 0x08
    59d4:	79 85       	ldd	r23, Y+9	; 0x09
    59d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    59d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    59da:	20 e0       	ldi	r18, 0x00	; 0
    59dc:	30 e0       	ldi	r19, 0x00	; 0
    59de:	40 e8       	ldi	r20, 0x80	; 128
    59e0:	5f e3       	ldi	r21, 0x3F	; 63
    59e2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    59e6:	88 23       	and	r24, r24
    59e8:	2c f4       	brge	.+10     	; 0x59f4 <LCD_write_cmd_8bit+0x274>
		__ticks = 1;
    59ea:	81 e0       	ldi	r24, 0x01	; 1
    59ec:	90 e0       	ldi	r25, 0x00	; 0
    59ee:	9f 83       	std	Y+7, r25	; 0x07
    59f0:	8e 83       	std	Y+6, r24	; 0x06
    59f2:	3f c0       	rjmp	.+126    	; 0x5a72 <LCD_write_cmd_8bit+0x2f2>
	else if (__tmp > 65535)
    59f4:	68 85       	ldd	r22, Y+8	; 0x08
    59f6:	79 85       	ldd	r23, Y+9	; 0x09
    59f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    59fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    59fc:	20 e0       	ldi	r18, 0x00	; 0
    59fe:	3f ef       	ldi	r19, 0xFF	; 255
    5a00:	4f e7       	ldi	r20, 0x7F	; 127
    5a02:	57 e4       	ldi	r21, 0x47	; 71
    5a04:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5a08:	18 16       	cp	r1, r24
    5a0a:	4c f5       	brge	.+82     	; 0x5a5e <LCD_write_cmd_8bit+0x2de>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5a0c:	6c 85       	ldd	r22, Y+12	; 0x0c
    5a0e:	7d 85       	ldd	r23, Y+13	; 0x0d
    5a10:	8e 85       	ldd	r24, Y+14	; 0x0e
    5a12:	9f 85       	ldd	r25, Y+15	; 0x0f
    5a14:	20 e0       	ldi	r18, 0x00	; 0
    5a16:	30 e0       	ldi	r19, 0x00	; 0
    5a18:	40 e2       	ldi	r20, 0x20	; 32
    5a1a:	51 e4       	ldi	r21, 0x41	; 65
    5a1c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5a20:	dc 01       	movw	r26, r24
    5a22:	cb 01       	movw	r24, r22
    5a24:	bc 01       	movw	r22, r24
    5a26:	cd 01       	movw	r24, r26
    5a28:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5a2c:	dc 01       	movw	r26, r24
    5a2e:	cb 01       	movw	r24, r22
    5a30:	9f 83       	std	Y+7, r25	; 0x07
    5a32:	8e 83       	std	Y+6, r24	; 0x06
    5a34:	0f c0       	rjmp	.+30     	; 0x5a54 <LCD_write_cmd_8bit+0x2d4>
    5a36:	80 e9       	ldi	r24, 0x90	; 144
    5a38:	91 e0       	ldi	r25, 0x01	; 1
    5a3a:	9d 83       	std	Y+5, r25	; 0x05
    5a3c:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5a3e:	8c 81       	ldd	r24, Y+4	; 0x04
    5a40:	9d 81       	ldd	r25, Y+5	; 0x05
    5a42:	01 97       	sbiw	r24, 0x01	; 1
    5a44:	f1 f7       	brne	.-4      	; 0x5a42 <LCD_write_cmd_8bit+0x2c2>
    5a46:	9d 83       	std	Y+5, r25	; 0x05
    5a48:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5a4a:	8e 81       	ldd	r24, Y+6	; 0x06
    5a4c:	9f 81       	ldd	r25, Y+7	; 0x07
    5a4e:	01 97       	sbiw	r24, 0x01	; 1
    5a50:	9f 83       	std	Y+7, r25	; 0x07
    5a52:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5a54:	8e 81       	ldd	r24, Y+6	; 0x06
    5a56:	9f 81       	ldd	r25, Y+7	; 0x07
    5a58:	00 97       	sbiw	r24, 0x00	; 0
    5a5a:	69 f7       	brne	.-38     	; 0x5a36 <LCD_write_cmd_8bit+0x2b6>
    5a5c:	24 c0       	rjmp	.+72     	; 0x5aa6 <LCD_write_cmd_8bit+0x326>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5a5e:	68 85       	ldd	r22, Y+8	; 0x08
    5a60:	79 85       	ldd	r23, Y+9	; 0x09
    5a62:	8a 85       	ldd	r24, Y+10	; 0x0a
    5a64:	9b 85       	ldd	r25, Y+11	; 0x0b
    5a66:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5a6a:	dc 01       	movw	r26, r24
    5a6c:	cb 01       	movw	r24, r22
    5a6e:	9f 83       	std	Y+7, r25	; 0x07
    5a70:	8e 83       	std	Y+6, r24	; 0x06
    5a72:	8e 81       	ldd	r24, Y+6	; 0x06
    5a74:	9f 81       	ldd	r25, Y+7	; 0x07
    5a76:	9b 83       	std	Y+3, r25	; 0x03
    5a78:	8a 83       	std	Y+2, r24	; 0x02
    5a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    5a7c:	9b 81       	ldd	r25, Y+3	; 0x03
    5a7e:	01 97       	sbiw	r24, 0x01	; 1
    5a80:	f1 f7       	brne	.-4      	; 0x5a7e <LCD_write_cmd_8bit+0x2fe>
    5a82:	9b 83       	std	Y+3, r25	; 0x03
    5a84:	8a 83       	std	Y+2, r24	; 0x02
    5a86:	0f c0       	rjmp	.+30     	; 0x5aa6 <LCD_write_cmd_8bit+0x326>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5a88:	69 89       	ldd	r22, Y+17	; 0x11
    5a8a:	7a 89       	ldd	r23, Y+18	; 0x12
    5a8c:	8b 89       	ldd	r24, Y+19	; 0x13
    5a8e:	9c 89       	ldd	r25, Y+20	; 0x14
    5a90:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5a94:	dc 01       	movw	r26, r24
    5a96:	cb 01       	movw	r24, r22
    5a98:	88 8b       	std	Y+16, r24	; 0x10
    5a9a:	88 89       	ldd	r24, Y+16	; 0x10
    5a9c:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5a9e:	89 81       	ldd	r24, Y+1	; 0x01
    5aa0:	8a 95       	dec	r24
    5aa2:	f1 f7       	brne	.-4      	; 0x5aa0 <LCD_write_cmd_8bit+0x320>
    5aa4:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	// Sent the command packet
	DIO_void_assign_port(lcd_data_port, lcd_copy_cmd_8bit);
    5aa6:	82 e0       	ldi	r24, 0x02	; 2
    5aa8:	69 a9       	ldd	r22, Y+49	; 0x31
    5aaa:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <DIO_void_assign_port>
	// Enable pin low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    5aae:	82 e0       	ldi	r24, 0x02	; 2
    5ab0:	60 e0       	ldi	r22, 0x00	; 0
    5ab2:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
}
    5ab6:	e1 96       	adiw	r28, 0x31	; 49
    5ab8:	0f b6       	in	r0, 0x3f	; 63
    5aba:	f8 94       	cli
    5abc:	de bf       	out	0x3e, r29	; 62
    5abe:	0f be       	out	0x3f, r0	; 63
    5ac0:	cd bf       	out	0x3d, r28	; 61
    5ac2:	cf 91       	pop	r28
    5ac4:	df 91       	pop	r29
    5ac6:	08 95       	ret

00005ac8 <LCD_read_address_8bit>:

u8 LCD_read_address_8bit(void ){
    5ac8:	df 93       	push	r29
    5aca:	cf 93       	push	r28
    5acc:	cd b7       	in	r28, 0x3d	; 61
    5ace:	de b7       	in	r29, 0x3e	; 62
    5ad0:	ef 97       	sbiw	r28, 0x3f	; 63
    5ad2:	0f b6       	in	r0, 0x3f	; 63
    5ad4:	f8 94       	cli
    5ad6:	de bf       	out	0x3e, r29	; 62
    5ad8:	0f be       	out	0x3f, r0	; 63
    5ada:	cd bf       	out	0x3d, r28	; 61
	 *	No inputs to the function
	 *
	 *	Function return the current address.
	 */
	// Configure the data port to input
	DIO_void_set_port_dir(lcd_data_port, INPUT);
    5adc:	82 e0       	ldi	r24, 0x02	; 2
    5ade:	60 e0       	ldi	r22, 0x00	; 0
    5ae0:	0e 94 34 25 	call	0x4a68	; 0x4a68 <DIO_void_set_port_dir>
    5ae4:	80 e0       	ldi	r24, 0x00	; 0
    5ae6:	90 e0       	ldi	r25, 0x00	; 0
    5ae8:	a8 e4       	ldi	r26, 0x48	; 72
    5aea:	b2 e4       	ldi	r27, 0x42	; 66
    5aec:	8b af       	std	Y+59, r24	; 0x3b
    5aee:	9c af       	std	Y+60, r25	; 0x3c
    5af0:	ad af       	std	Y+61, r26	; 0x3d
    5af2:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5af4:	6b ad       	ldd	r22, Y+59	; 0x3b
    5af6:	7c ad       	ldd	r23, Y+60	; 0x3c
    5af8:	8d ad       	ldd	r24, Y+61	; 0x3d
    5afa:	9e ad       	ldd	r25, Y+62	; 0x3e
    5afc:	20 e0       	ldi	r18, 0x00	; 0
    5afe:	30 e0       	ldi	r19, 0x00	; 0
    5b00:	4a e7       	ldi	r20, 0x7A	; 122
    5b02:	55 e4       	ldi	r21, 0x45	; 69
    5b04:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5b08:	dc 01       	movw	r26, r24
    5b0a:	cb 01       	movw	r24, r22
    5b0c:	8f ab       	std	Y+55, r24	; 0x37
    5b0e:	98 af       	std	Y+56, r25	; 0x38
    5b10:	a9 af       	std	Y+57, r26	; 0x39
    5b12:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    5b14:	6f a9       	ldd	r22, Y+55	; 0x37
    5b16:	78 ad       	ldd	r23, Y+56	; 0x38
    5b18:	89 ad       	ldd	r24, Y+57	; 0x39
    5b1a:	9a ad       	ldd	r25, Y+58	; 0x3a
    5b1c:	20 e0       	ldi	r18, 0x00	; 0
    5b1e:	30 e0       	ldi	r19, 0x00	; 0
    5b20:	40 e8       	ldi	r20, 0x80	; 128
    5b22:	5f e3       	ldi	r21, 0x3F	; 63
    5b24:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5b28:	88 23       	and	r24, r24
    5b2a:	2c f4       	brge	.+10     	; 0x5b36 <LCD_read_address_8bit+0x6e>
		__ticks = 1;
    5b2c:	81 e0       	ldi	r24, 0x01	; 1
    5b2e:	90 e0       	ldi	r25, 0x00	; 0
    5b30:	9e ab       	std	Y+54, r25	; 0x36
    5b32:	8d ab       	std	Y+53, r24	; 0x35
    5b34:	3f c0       	rjmp	.+126    	; 0x5bb4 <LCD_read_address_8bit+0xec>
	else if (__tmp > 65535)
    5b36:	6f a9       	ldd	r22, Y+55	; 0x37
    5b38:	78 ad       	ldd	r23, Y+56	; 0x38
    5b3a:	89 ad       	ldd	r24, Y+57	; 0x39
    5b3c:	9a ad       	ldd	r25, Y+58	; 0x3a
    5b3e:	20 e0       	ldi	r18, 0x00	; 0
    5b40:	3f ef       	ldi	r19, 0xFF	; 255
    5b42:	4f e7       	ldi	r20, 0x7F	; 127
    5b44:	57 e4       	ldi	r21, 0x47	; 71
    5b46:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5b4a:	18 16       	cp	r1, r24
    5b4c:	4c f5       	brge	.+82     	; 0x5ba0 <LCD_read_address_8bit+0xd8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5b4e:	6b ad       	ldd	r22, Y+59	; 0x3b
    5b50:	7c ad       	ldd	r23, Y+60	; 0x3c
    5b52:	8d ad       	ldd	r24, Y+61	; 0x3d
    5b54:	9e ad       	ldd	r25, Y+62	; 0x3e
    5b56:	20 e0       	ldi	r18, 0x00	; 0
    5b58:	30 e0       	ldi	r19, 0x00	; 0
    5b5a:	40 e2       	ldi	r20, 0x20	; 32
    5b5c:	51 e4       	ldi	r21, 0x41	; 65
    5b5e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5b62:	dc 01       	movw	r26, r24
    5b64:	cb 01       	movw	r24, r22
    5b66:	bc 01       	movw	r22, r24
    5b68:	cd 01       	movw	r24, r26
    5b6a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5b6e:	dc 01       	movw	r26, r24
    5b70:	cb 01       	movw	r24, r22
    5b72:	9e ab       	std	Y+54, r25	; 0x36
    5b74:	8d ab       	std	Y+53, r24	; 0x35
    5b76:	0f c0       	rjmp	.+30     	; 0x5b96 <LCD_read_address_8bit+0xce>
    5b78:	80 e9       	ldi	r24, 0x90	; 144
    5b7a:	91 e0       	ldi	r25, 0x01	; 1
    5b7c:	9c ab       	std	Y+52, r25	; 0x34
    5b7e:	8b ab       	std	Y+51, r24	; 0x33
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5b80:	8b a9       	ldd	r24, Y+51	; 0x33
    5b82:	9c a9       	ldd	r25, Y+52	; 0x34
    5b84:	01 97       	sbiw	r24, 0x01	; 1
    5b86:	f1 f7       	brne	.-4      	; 0x5b84 <LCD_read_address_8bit+0xbc>
    5b88:	9c ab       	std	Y+52, r25	; 0x34
    5b8a:	8b ab       	std	Y+51, r24	; 0x33
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5b8c:	8d a9       	ldd	r24, Y+53	; 0x35
    5b8e:	9e a9       	ldd	r25, Y+54	; 0x36
    5b90:	01 97       	sbiw	r24, 0x01	; 1
    5b92:	9e ab       	std	Y+54, r25	; 0x36
    5b94:	8d ab       	std	Y+53, r24	; 0x35
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5b96:	8d a9       	ldd	r24, Y+53	; 0x35
    5b98:	9e a9       	ldd	r25, Y+54	; 0x36
    5b9a:	00 97       	sbiw	r24, 0x00	; 0
    5b9c:	69 f7       	brne	.-38     	; 0x5b78 <LCD_read_address_8bit+0xb0>
    5b9e:	14 c0       	rjmp	.+40     	; 0x5bc8 <LCD_read_address_8bit+0x100>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5ba0:	6f a9       	ldd	r22, Y+55	; 0x37
    5ba2:	78 ad       	ldd	r23, Y+56	; 0x38
    5ba4:	89 ad       	ldd	r24, Y+57	; 0x39
    5ba6:	9a ad       	ldd	r25, Y+58	; 0x3a
    5ba8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5bac:	dc 01       	movw	r26, r24
    5bae:	cb 01       	movw	r24, r22
    5bb0:	9e ab       	std	Y+54, r25	; 0x36
    5bb2:	8d ab       	std	Y+53, r24	; 0x35
    5bb4:	8d a9       	ldd	r24, Y+53	; 0x35
    5bb6:	9e a9       	ldd	r25, Y+54	; 0x36
    5bb8:	9a ab       	std	Y+50, r25	; 0x32
    5bba:	89 ab       	std	Y+49, r24	; 0x31
    5bbc:	89 a9       	ldd	r24, Y+49	; 0x31
    5bbe:	9a a9       	ldd	r25, Y+50	; 0x32
    5bc0:	01 97       	sbiw	r24, 0x01	; 1
    5bc2:	f1 f7       	brne	.-4      	; 0x5bc0 <LCD_read_address_8bit+0xf8>
    5bc4:	9a ab       	std	Y+50, r25	; 0x32
    5bc6:	89 ab       	std	Y+49, r24	; 0x31
	_delay_ms(50);
	// Configure RS/RW pins to send address
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RS);
    5bc8:	82 e0       	ldi	r24, 0x02	; 2
    5bca:	62 e0       	ldi	r22, 0x02	; 2
    5bcc:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
	DIO_void_set_pin(lcd_ctrl_port, lcd_RW);
    5bd0:	82 e0       	ldi	r24, 0x02	; 2
    5bd2:	61 e0       	ldi	r22, 0x01	; 1
    5bd4:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    5bd8:	80 e0       	ldi	r24, 0x00	; 0
    5bda:	90 e0       	ldi	r25, 0x00	; 0
    5bdc:	a0 e8       	ldi	r26, 0x80	; 128
    5bde:	bf e3       	ldi	r27, 0x3F	; 63
    5be0:	8d a7       	std	Y+45, r24	; 0x2d
    5be2:	9e a7       	std	Y+46, r25	; 0x2e
    5be4:	af a7       	std	Y+47, r26	; 0x2f
    5be6:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    5be8:	6d a5       	ldd	r22, Y+45	; 0x2d
    5bea:	7e a5       	ldd	r23, Y+46	; 0x2e
    5bec:	8f a5       	ldd	r24, Y+47	; 0x2f
    5bee:	98 a9       	ldd	r25, Y+48	; 0x30
    5bf0:	2b ea       	ldi	r18, 0xAB	; 171
    5bf2:	3a ea       	ldi	r19, 0xAA	; 170
    5bf4:	4a ea       	ldi	r20, 0xAA	; 170
    5bf6:	50 e4       	ldi	r21, 0x40	; 64
    5bf8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5bfc:	dc 01       	movw	r26, r24
    5bfe:	cb 01       	movw	r24, r22
    5c00:	89 a7       	std	Y+41, r24	; 0x29
    5c02:	9a a7       	std	Y+42, r25	; 0x2a
    5c04:	ab a7       	std	Y+43, r26	; 0x2b
    5c06:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    5c08:	69 a5       	ldd	r22, Y+41	; 0x29
    5c0a:	7a a5       	ldd	r23, Y+42	; 0x2a
    5c0c:	8b a5       	ldd	r24, Y+43	; 0x2b
    5c0e:	9c a5       	ldd	r25, Y+44	; 0x2c
    5c10:	20 e0       	ldi	r18, 0x00	; 0
    5c12:	30 e0       	ldi	r19, 0x00	; 0
    5c14:	40 e8       	ldi	r20, 0x80	; 128
    5c16:	5f e3       	ldi	r21, 0x3F	; 63
    5c18:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5c1c:	88 23       	and	r24, r24
    5c1e:	1c f4       	brge	.+6      	; 0x5c26 <LCD_read_address_8bit+0x15e>
		__ticks = 1;
    5c20:	81 e0       	ldi	r24, 0x01	; 1
    5c22:	88 a7       	std	Y+40, r24	; 0x28
    5c24:	91 c0       	rjmp	.+290    	; 0x5d48 <LCD_read_address_8bit+0x280>
	else if (__tmp > 255)
    5c26:	69 a5       	ldd	r22, Y+41	; 0x29
    5c28:	7a a5       	ldd	r23, Y+42	; 0x2a
    5c2a:	8b a5       	ldd	r24, Y+43	; 0x2b
    5c2c:	9c a5       	ldd	r25, Y+44	; 0x2c
    5c2e:	20 e0       	ldi	r18, 0x00	; 0
    5c30:	30 e0       	ldi	r19, 0x00	; 0
    5c32:	4f e7       	ldi	r20, 0x7F	; 127
    5c34:	53 e4       	ldi	r21, 0x43	; 67
    5c36:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5c3a:	18 16       	cp	r1, r24
    5c3c:	0c f0       	brlt	.+2      	; 0x5c40 <LCD_read_address_8bit+0x178>
    5c3e:	7b c0       	rjmp	.+246    	; 0x5d36 <LCD_read_address_8bit+0x26e>
	{
		_delay_ms(__us / 1000.0);
    5c40:	6d a5       	ldd	r22, Y+45	; 0x2d
    5c42:	7e a5       	ldd	r23, Y+46	; 0x2e
    5c44:	8f a5       	ldd	r24, Y+47	; 0x2f
    5c46:	98 a9       	ldd	r25, Y+48	; 0x30
    5c48:	20 e0       	ldi	r18, 0x00	; 0
    5c4a:	30 e0       	ldi	r19, 0x00	; 0
    5c4c:	4a e7       	ldi	r20, 0x7A	; 122
    5c4e:	54 e4       	ldi	r21, 0x44	; 68
    5c50:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    5c54:	dc 01       	movw	r26, r24
    5c56:	cb 01       	movw	r24, r22
    5c58:	8c a3       	std	Y+36, r24	; 0x24
    5c5a:	9d a3       	std	Y+37, r25	; 0x25
    5c5c:	ae a3       	std	Y+38, r26	; 0x26
    5c5e:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5c60:	6c a1       	ldd	r22, Y+36	; 0x24
    5c62:	7d a1       	ldd	r23, Y+37	; 0x25
    5c64:	8e a1       	ldd	r24, Y+38	; 0x26
    5c66:	9f a1       	ldd	r25, Y+39	; 0x27
    5c68:	20 e0       	ldi	r18, 0x00	; 0
    5c6a:	30 e0       	ldi	r19, 0x00	; 0
    5c6c:	4a e7       	ldi	r20, 0x7A	; 122
    5c6e:	55 e4       	ldi	r21, 0x45	; 69
    5c70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5c74:	dc 01       	movw	r26, r24
    5c76:	cb 01       	movw	r24, r22
    5c78:	88 a3       	std	Y+32, r24	; 0x20
    5c7a:	99 a3       	std	Y+33, r25	; 0x21
    5c7c:	aa a3       	std	Y+34, r26	; 0x22
    5c7e:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    5c80:	68 a1       	ldd	r22, Y+32	; 0x20
    5c82:	79 a1       	ldd	r23, Y+33	; 0x21
    5c84:	8a a1       	ldd	r24, Y+34	; 0x22
    5c86:	9b a1       	ldd	r25, Y+35	; 0x23
    5c88:	20 e0       	ldi	r18, 0x00	; 0
    5c8a:	30 e0       	ldi	r19, 0x00	; 0
    5c8c:	40 e8       	ldi	r20, 0x80	; 128
    5c8e:	5f e3       	ldi	r21, 0x3F	; 63
    5c90:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5c94:	88 23       	and	r24, r24
    5c96:	2c f4       	brge	.+10     	; 0x5ca2 <LCD_read_address_8bit+0x1da>
		__ticks = 1;
    5c98:	81 e0       	ldi	r24, 0x01	; 1
    5c9a:	90 e0       	ldi	r25, 0x00	; 0
    5c9c:	9f 8f       	std	Y+31, r25	; 0x1f
    5c9e:	8e 8f       	std	Y+30, r24	; 0x1e
    5ca0:	3f c0       	rjmp	.+126    	; 0x5d20 <LCD_read_address_8bit+0x258>
	else if (__tmp > 65535)
    5ca2:	68 a1       	ldd	r22, Y+32	; 0x20
    5ca4:	79 a1       	ldd	r23, Y+33	; 0x21
    5ca6:	8a a1       	ldd	r24, Y+34	; 0x22
    5ca8:	9b a1       	ldd	r25, Y+35	; 0x23
    5caa:	20 e0       	ldi	r18, 0x00	; 0
    5cac:	3f ef       	ldi	r19, 0xFF	; 255
    5cae:	4f e7       	ldi	r20, 0x7F	; 127
    5cb0:	57 e4       	ldi	r21, 0x47	; 71
    5cb2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5cb6:	18 16       	cp	r1, r24
    5cb8:	4c f5       	brge	.+82     	; 0x5d0c <LCD_read_address_8bit+0x244>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5cba:	6c a1       	ldd	r22, Y+36	; 0x24
    5cbc:	7d a1       	ldd	r23, Y+37	; 0x25
    5cbe:	8e a1       	ldd	r24, Y+38	; 0x26
    5cc0:	9f a1       	ldd	r25, Y+39	; 0x27
    5cc2:	20 e0       	ldi	r18, 0x00	; 0
    5cc4:	30 e0       	ldi	r19, 0x00	; 0
    5cc6:	40 e2       	ldi	r20, 0x20	; 32
    5cc8:	51 e4       	ldi	r21, 0x41	; 65
    5cca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5cce:	dc 01       	movw	r26, r24
    5cd0:	cb 01       	movw	r24, r22
    5cd2:	bc 01       	movw	r22, r24
    5cd4:	cd 01       	movw	r24, r26
    5cd6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5cda:	dc 01       	movw	r26, r24
    5cdc:	cb 01       	movw	r24, r22
    5cde:	9f 8f       	std	Y+31, r25	; 0x1f
    5ce0:	8e 8f       	std	Y+30, r24	; 0x1e
    5ce2:	0f c0       	rjmp	.+30     	; 0x5d02 <LCD_read_address_8bit+0x23a>
    5ce4:	80 e9       	ldi	r24, 0x90	; 144
    5ce6:	91 e0       	ldi	r25, 0x01	; 1
    5ce8:	9d 8f       	std	Y+29, r25	; 0x1d
    5cea:	8c 8f       	std	Y+28, r24	; 0x1c
    5cec:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5cee:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5cf0:	01 97       	sbiw	r24, 0x01	; 1
    5cf2:	f1 f7       	brne	.-4      	; 0x5cf0 <LCD_read_address_8bit+0x228>
    5cf4:	9d 8f       	std	Y+29, r25	; 0x1d
    5cf6:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5cf8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    5cfa:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5cfc:	01 97       	sbiw	r24, 0x01	; 1
    5cfe:	9f 8f       	std	Y+31, r25	; 0x1f
    5d00:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5d02:	8e 8d       	ldd	r24, Y+30	; 0x1e
    5d04:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5d06:	00 97       	sbiw	r24, 0x00	; 0
    5d08:	69 f7       	brne	.-38     	; 0x5ce4 <LCD_read_address_8bit+0x21c>
    5d0a:	24 c0       	rjmp	.+72     	; 0x5d54 <LCD_read_address_8bit+0x28c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5d0c:	68 a1       	ldd	r22, Y+32	; 0x20
    5d0e:	79 a1       	ldd	r23, Y+33	; 0x21
    5d10:	8a a1       	ldd	r24, Y+34	; 0x22
    5d12:	9b a1       	ldd	r25, Y+35	; 0x23
    5d14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5d18:	dc 01       	movw	r26, r24
    5d1a:	cb 01       	movw	r24, r22
    5d1c:	9f 8f       	std	Y+31, r25	; 0x1f
    5d1e:	8e 8f       	std	Y+30, r24	; 0x1e
    5d20:	8e 8d       	ldd	r24, Y+30	; 0x1e
    5d22:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5d24:	9b 8f       	std	Y+27, r25	; 0x1b
    5d26:	8a 8f       	std	Y+26, r24	; 0x1a
    5d28:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5d2a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    5d2c:	01 97       	sbiw	r24, 0x01	; 1
    5d2e:	f1 f7       	brne	.-4      	; 0x5d2c <LCD_read_address_8bit+0x264>
    5d30:	9b 8f       	std	Y+27, r25	; 0x1b
    5d32:	8a 8f       	std	Y+26, r24	; 0x1a
    5d34:	0f c0       	rjmp	.+30     	; 0x5d54 <LCD_read_address_8bit+0x28c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5d36:	69 a5       	ldd	r22, Y+41	; 0x29
    5d38:	7a a5       	ldd	r23, Y+42	; 0x2a
    5d3a:	8b a5       	ldd	r24, Y+43	; 0x2b
    5d3c:	9c a5       	ldd	r25, Y+44	; 0x2c
    5d3e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5d42:	dc 01       	movw	r26, r24
    5d44:	cb 01       	movw	r24, r22
    5d46:	88 a7       	std	Y+40, r24	; 0x28
    5d48:	88 a5       	ldd	r24, Y+40	; 0x28
    5d4a:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5d4c:	89 8d       	ldd	r24, Y+25	; 0x19
    5d4e:	8a 95       	dec	r24
    5d50:	f1 f7       	brne	.-4      	; 0x5d4e <LCD_read_address_8bit+0x286>
    5d52:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1);
	// Enable pin is high to recive the packet
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    5d54:	82 e0       	ldi	r24, 0x02	; 2
    5d56:	60 e0       	ldi	r22, 0x00	; 0
    5d58:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    5d5c:	80 e0       	ldi	r24, 0x00	; 0
    5d5e:	90 e0       	ldi	r25, 0x00	; 0
    5d60:	a0 e8       	ldi	r26, 0x80	; 128
    5d62:	bf e3       	ldi	r27, 0x3F	; 63
    5d64:	8d 8b       	std	Y+21, r24	; 0x15
    5d66:	9e 8b       	std	Y+22, r25	; 0x16
    5d68:	af 8b       	std	Y+23, r26	; 0x17
    5d6a:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    5d6c:	6d 89       	ldd	r22, Y+21	; 0x15
    5d6e:	7e 89       	ldd	r23, Y+22	; 0x16
    5d70:	8f 89       	ldd	r24, Y+23	; 0x17
    5d72:	98 8d       	ldd	r25, Y+24	; 0x18
    5d74:	2b ea       	ldi	r18, 0xAB	; 171
    5d76:	3a ea       	ldi	r19, 0xAA	; 170
    5d78:	4a ea       	ldi	r20, 0xAA	; 170
    5d7a:	50 e4       	ldi	r21, 0x40	; 64
    5d7c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5d80:	dc 01       	movw	r26, r24
    5d82:	cb 01       	movw	r24, r22
    5d84:	89 8b       	std	Y+17, r24	; 0x11
    5d86:	9a 8b       	std	Y+18, r25	; 0x12
    5d88:	ab 8b       	std	Y+19, r26	; 0x13
    5d8a:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    5d8c:	69 89       	ldd	r22, Y+17	; 0x11
    5d8e:	7a 89       	ldd	r23, Y+18	; 0x12
    5d90:	8b 89       	ldd	r24, Y+19	; 0x13
    5d92:	9c 89       	ldd	r25, Y+20	; 0x14
    5d94:	20 e0       	ldi	r18, 0x00	; 0
    5d96:	30 e0       	ldi	r19, 0x00	; 0
    5d98:	40 e8       	ldi	r20, 0x80	; 128
    5d9a:	5f e3       	ldi	r21, 0x3F	; 63
    5d9c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5da0:	88 23       	and	r24, r24
    5da2:	1c f4       	brge	.+6      	; 0x5daa <LCD_read_address_8bit+0x2e2>
		__ticks = 1;
    5da4:	81 e0       	ldi	r24, 0x01	; 1
    5da6:	88 8b       	std	Y+16, r24	; 0x10
    5da8:	91 c0       	rjmp	.+290    	; 0x5ecc <LCD_read_address_8bit+0x404>
	else if (__tmp > 255)
    5daa:	69 89       	ldd	r22, Y+17	; 0x11
    5dac:	7a 89       	ldd	r23, Y+18	; 0x12
    5dae:	8b 89       	ldd	r24, Y+19	; 0x13
    5db0:	9c 89       	ldd	r25, Y+20	; 0x14
    5db2:	20 e0       	ldi	r18, 0x00	; 0
    5db4:	30 e0       	ldi	r19, 0x00	; 0
    5db6:	4f e7       	ldi	r20, 0x7F	; 127
    5db8:	53 e4       	ldi	r21, 0x43	; 67
    5dba:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5dbe:	18 16       	cp	r1, r24
    5dc0:	0c f0       	brlt	.+2      	; 0x5dc4 <LCD_read_address_8bit+0x2fc>
    5dc2:	7b c0       	rjmp	.+246    	; 0x5eba <LCD_read_address_8bit+0x3f2>
	{
		_delay_ms(__us / 1000.0);
    5dc4:	6d 89       	ldd	r22, Y+21	; 0x15
    5dc6:	7e 89       	ldd	r23, Y+22	; 0x16
    5dc8:	8f 89       	ldd	r24, Y+23	; 0x17
    5dca:	98 8d       	ldd	r25, Y+24	; 0x18
    5dcc:	20 e0       	ldi	r18, 0x00	; 0
    5dce:	30 e0       	ldi	r19, 0x00	; 0
    5dd0:	4a e7       	ldi	r20, 0x7A	; 122
    5dd2:	54 e4       	ldi	r21, 0x44	; 68
    5dd4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    5dd8:	dc 01       	movw	r26, r24
    5dda:	cb 01       	movw	r24, r22
    5ddc:	8c 87       	std	Y+12, r24	; 0x0c
    5dde:	9d 87       	std	Y+13, r25	; 0x0d
    5de0:	ae 87       	std	Y+14, r26	; 0x0e
    5de2:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5de4:	6c 85       	ldd	r22, Y+12	; 0x0c
    5de6:	7d 85       	ldd	r23, Y+13	; 0x0d
    5de8:	8e 85       	ldd	r24, Y+14	; 0x0e
    5dea:	9f 85       	ldd	r25, Y+15	; 0x0f
    5dec:	20 e0       	ldi	r18, 0x00	; 0
    5dee:	30 e0       	ldi	r19, 0x00	; 0
    5df0:	4a e7       	ldi	r20, 0x7A	; 122
    5df2:	55 e4       	ldi	r21, 0x45	; 69
    5df4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5df8:	dc 01       	movw	r26, r24
    5dfa:	cb 01       	movw	r24, r22
    5dfc:	88 87       	std	Y+8, r24	; 0x08
    5dfe:	99 87       	std	Y+9, r25	; 0x09
    5e00:	aa 87       	std	Y+10, r26	; 0x0a
    5e02:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    5e04:	68 85       	ldd	r22, Y+8	; 0x08
    5e06:	79 85       	ldd	r23, Y+9	; 0x09
    5e08:	8a 85       	ldd	r24, Y+10	; 0x0a
    5e0a:	9b 85       	ldd	r25, Y+11	; 0x0b
    5e0c:	20 e0       	ldi	r18, 0x00	; 0
    5e0e:	30 e0       	ldi	r19, 0x00	; 0
    5e10:	40 e8       	ldi	r20, 0x80	; 128
    5e12:	5f e3       	ldi	r21, 0x3F	; 63
    5e14:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5e18:	88 23       	and	r24, r24
    5e1a:	2c f4       	brge	.+10     	; 0x5e26 <LCD_read_address_8bit+0x35e>
		__ticks = 1;
    5e1c:	81 e0       	ldi	r24, 0x01	; 1
    5e1e:	90 e0       	ldi	r25, 0x00	; 0
    5e20:	9f 83       	std	Y+7, r25	; 0x07
    5e22:	8e 83       	std	Y+6, r24	; 0x06
    5e24:	3f c0       	rjmp	.+126    	; 0x5ea4 <LCD_read_address_8bit+0x3dc>
	else if (__tmp > 65535)
    5e26:	68 85       	ldd	r22, Y+8	; 0x08
    5e28:	79 85       	ldd	r23, Y+9	; 0x09
    5e2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    5e2c:	9b 85       	ldd	r25, Y+11	; 0x0b
    5e2e:	20 e0       	ldi	r18, 0x00	; 0
    5e30:	3f ef       	ldi	r19, 0xFF	; 255
    5e32:	4f e7       	ldi	r20, 0x7F	; 127
    5e34:	57 e4       	ldi	r21, 0x47	; 71
    5e36:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5e3a:	18 16       	cp	r1, r24
    5e3c:	4c f5       	brge	.+82     	; 0x5e90 <LCD_read_address_8bit+0x3c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5e3e:	6c 85       	ldd	r22, Y+12	; 0x0c
    5e40:	7d 85       	ldd	r23, Y+13	; 0x0d
    5e42:	8e 85       	ldd	r24, Y+14	; 0x0e
    5e44:	9f 85       	ldd	r25, Y+15	; 0x0f
    5e46:	20 e0       	ldi	r18, 0x00	; 0
    5e48:	30 e0       	ldi	r19, 0x00	; 0
    5e4a:	40 e2       	ldi	r20, 0x20	; 32
    5e4c:	51 e4       	ldi	r21, 0x41	; 65
    5e4e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5e52:	dc 01       	movw	r26, r24
    5e54:	cb 01       	movw	r24, r22
    5e56:	bc 01       	movw	r22, r24
    5e58:	cd 01       	movw	r24, r26
    5e5a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5e5e:	dc 01       	movw	r26, r24
    5e60:	cb 01       	movw	r24, r22
    5e62:	9f 83       	std	Y+7, r25	; 0x07
    5e64:	8e 83       	std	Y+6, r24	; 0x06
    5e66:	0f c0       	rjmp	.+30     	; 0x5e86 <LCD_read_address_8bit+0x3be>
    5e68:	80 e9       	ldi	r24, 0x90	; 144
    5e6a:	91 e0       	ldi	r25, 0x01	; 1
    5e6c:	9d 83       	std	Y+5, r25	; 0x05
    5e6e:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5e70:	8c 81       	ldd	r24, Y+4	; 0x04
    5e72:	9d 81       	ldd	r25, Y+5	; 0x05
    5e74:	01 97       	sbiw	r24, 0x01	; 1
    5e76:	f1 f7       	brne	.-4      	; 0x5e74 <LCD_read_address_8bit+0x3ac>
    5e78:	9d 83       	std	Y+5, r25	; 0x05
    5e7a:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5e7c:	8e 81       	ldd	r24, Y+6	; 0x06
    5e7e:	9f 81       	ldd	r25, Y+7	; 0x07
    5e80:	01 97       	sbiw	r24, 0x01	; 1
    5e82:	9f 83       	std	Y+7, r25	; 0x07
    5e84:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5e86:	8e 81       	ldd	r24, Y+6	; 0x06
    5e88:	9f 81       	ldd	r25, Y+7	; 0x07
    5e8a:	00 97       	sbiw	r24, 0x00	; 0
    5e8c:	69 f7       	brne	.-38     	; 0x5e68 <LCD_read_address_8bit+0x3a0>
    5e8e:	24 c0       	rjmp	.+72     	; 0x5ed8 <LCD_read_address_8bit+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5e90:	68 85       	ldd	r22, Y+8	; 0x08
    5e92:	79 85       	ldd	r23, Y+9	; 0x09
    5e94:	8a 85       	ldd	r24, Y+10	; 0x0a
    5e96:	9b 85       	ldd	r25, Y+11	; 0x0b
    5e98:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5e9c:	dc 01       	movw	r26, r24
    5e9e:	cb 01       	movw	r24, r22
    5ea0:	9f 83       	std	Y+7, r25	; 0x07
    5ea2:	8e 83       	std	Y+6, r24	; 0x06
    5ea4:	8e 81       	ldd	r24, Y+6	; 0x06
    5ea6:	9f 81       	ldd	r25, Y+7	; 0x07
    5ea8:	9b 83       	std	Y+3, r25	; 0x03
    5eaa:	8a 83       	std	Y+2, r24	; 0x02
    5eac:	8a 81       	ldd	r24, Y+2	; 0x02
    5eae:	9b 81       	ldd	r25, Y+3	; 0x03
    5eb0:	01 97       	sbiw	r24, 0x01	; 1
    5eb2:	f1 f7       	brne	.-4      	; 0x5eb0 <LCD_read_address_8bit+0x3e8>
    5eb4:	9b 83       	std	Y+3, r25	; 0x03
    5eb6:	8a 83       	std	Y+2, r24	; 0x02
    5eb8:	0f c0       	rjmp	.+30     	; 0x5ed8 <LCD_read_address_8bit+0x410>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5eba:	69 89       	ldd	r22, Y+17	; 0x11
    5ebc:	7a 89       	ldd	r23, Y+18	; 0x12
    5ebe:	8b 89       	ldd	r24, Y+19	; 0x13
    5ec0:	9c 89       	ldd	r25, Y+20	; 0x14
    5ec2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5ec6:	dc 01       	movw	r26, r24
    5ec8:	cb 01       	movw	r24, r22
    5eca:	88 8b       	std	Y+16, r24	; 0x10
    5ecc:	88 89       	ldd	r24, Y+16	; 0x10
    5ece:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5ed0:	89 81       	ldd	r24, Y+1	; 0x01
    5ed2:	8a 95       	dec	r24
    5ed4:	f1 f7       	brne	.-4      	; 0x5ed2 <LCD_read_address_8bit+0x40a>
    5ed6:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	// Recive the packet
	u8 address= DIO_u8_get_port(lcd_data_port);
    5ed8:	82 e0       	ldi	r24, 0x02	; 2
    5eda:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <DIO_u8_get_port>
    5ede:	8f af       	std	Y+63, r24	; 0x3f
	// Enable pin low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    5ee0:	82 e0       	ldi	r24, 0x02	; 2
    5ee2:	60 e0       	ldi	r22, 0x00	; 0
    5ee4:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
	// clear the busy flag bit
	clr_bit(address, lcd_busy_flag);
    5ee8:	8f ad       	ldd	r24, Y+63	; 0x3f
    5eea:	8f 77       	andi	r24, 0x7F	; 127
    5eec:	8f af       	std	Y+63, r24	; 0x3f
	// Configure the data port back to output
	DIO_void_set_port_dir(lcd_data_port, OUTPUT);
    5eee:	82 e0       	ldi	r24, 0x02	; 2
    5ef0:	61 e0       	ldi	r22, 0x01	; 1
    5ef2:	0e 94 34 25 	call	0x4a68	; 0x4a68 <DIO_void_set_port_dir>
	return address;
    5ef6:	8f ad       	ldd	r24, Y+63	; 0x3f
}
    5ef8:	ef 96       	adiw	r28, 0x3f	; 63
    5efa:	0f b6       	in	r0, 0x3f	; 63
    5efc:	f8 94       	cli
    5efe:	de bf       	out	0x3e, r29	; 62
    5f00:	0f be       	out	0x3f, r0	; 63
    5f02:	cd bf       	out	0x3d, r28	; 61
    5f04:	cf 91       	pop	r28
    5f06:	df 91       	pop	r29
    5f08:	08 95       	ret

00005f0a <LCD_write_data_4bit>:

/******************************************************************************/

/* LCD 8bit interfacing functions implementation */
void LCD_write_data_4bit(u8 lcd_copy_word_4bit){
    5f0a:	0f 93       	push	r16
    5f0c:	1f 93       	push	r17
    5f0e:	df 93       	push	r29
    5f10:	cf 93       	push	r28
    5f12:	cd b7       	in	r28, 0x3d	; 61
    5f14:	de b7       	in	r29, 0x3e	; 62
    5f16:	c3 56       	subi	r28, 0x63	; 99
    5f18:	d0 40       	sbci	r29, 0x00	; 0
    5f1a:	0f b6       	in	r0, 0x3f	; 63
    5f1c:	f8 94       	cli
    5f1e:	de bf       	out	0x3e, r29	; 62
    5f20:	0f be       	out	0x3f, r0	; 63
    5f22:	cd bf       	out	0x3d, r28	; 61
    5f24:	fe 01       	movw	r30, r28
    5f26:	ed 59       	subi	r30, 0x9D	; 157
    5f28:	ff 4f       	sbci	r31, 0xFF	; 255
    5f2a:	80 83       	st	Z, r24
	 *		lcd_copy_word_4bit>> The data byte that needs to be sent to the LCD
	 *
	 *	Function does not return any  valus and it is helper and not allowed to be used out side of the driver.
	 */
	// Configure RS/RW pins to recive command
	DIO_void_set_pin(lcd_ctrl_port, lcd_RS);
    5f2c:	82 e0       	ldi	r24, 0x02	; 2
    5f2e:	62 e0       	ldi	r22, 0x02	; 2
    5f30:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RW);
    5f34:	82 e0       	ldi	r24, 0x02	; 2
    5f36:	61 e0       	ldi	r22, 0x01	; 1
    5f38:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    5f3c:	fe 01       	movw	r30, r28
    5f3e:	e3 5a       	subi	r30, 0xA3	; 163
    5f40:	ff 4f       	sbci	r31, 0xFF	; 255
    5f42:	80 e0       	ldi	r24, 0x00	; 0
    5f44:	90 e0       	ldi	r25, 0x00	; 0
    5f46:	a0 e8       	ldi	r26, 0x80	; 128
    5f48:	bf e3       	ldi	r27, 0x3F	; 63
    5f4a:	80 83       	st	Z, r24
    5f4c:	91 83       	std	Z+1, r25	; 0x01
    5f4e:	a2 83       	std	Z+2, r26	; 0x02
    5f50:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    5f52:	8e 01       	movw	r16, r28
    5f54:	07 5a       	subi	r16, 0xA7	; 167
    5f56:	1f 4f       	sbci	r17, 0xFF	; 255
    5f58:	fe 01       	movw	r30, r28
    5f5a:	e3 5a       	subi	r30, 0xA3	; 163
    5f5c:	ff 4f       	sbci	r31, 0xFF	; 255
    5f5e:	60 81       	ld	r22, Z
    5f60:	71 81       	ldd	r23, Z+1	; 0x01
    5f62:	82 81       	ldd	r24, Z+2	; 0x02
    5f64:	93 81       	ldd	r25, Z+3	; 0x03
    5f66:	2b ea       	ldi	r18, 0xAB	; 171
    5f68:	3a ea       	ldi	r19, 0xAA	; 170
    5f6a:	4a ea       	ldi	r20, 0xAA	; 170
    5f6c:	50 e4       	ldi	r21, 0x40	; 64
    5f6e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5f72:	dc 01       	movw	r26, r24
    5f74:	cb 01       	movw	r24, r22
    5f76:	f8 01       	movw	r30, r16
    5f78:	80 83       	st	Z, r24
    5f7a:	91 83       	std	Z+1, r25	; 0x01
    5f7c:	a2 83       	std	Z+2, r26	; 0x02
    5f7e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5f80:	fe 01       	movw	r30, r28
    5f82:	e7 5a       	subi	r30, 0xA7	; 167
    5f84:	ff 4f       	sbci	r31, 0xFF	; 255
    5f86:	60 81       	ld	r22, Z
    5f88:	71 81       	ldd	r23, Z+1	; 0x01
    5f8a:	82 81       	ldd	r24, Z+2	; 0x02
    5f8c:	93 81       	ldd	r25, Z+3	; 0x03
    5f8e:	20 e0       	ldi	r18, 0x00	; 0
    5f90:	30 e0       	ldi	r19, 0x00	; 0
    5f92:	40 e8       	ldi	r20, 0x80	; 128
    5f94:	5f e3       	ldi	r21, 0x3F	; 63
    5f96:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5f9a:	88 23       	and	r24, r24
    5f9c:	34 f4       	brge	.+12     	; 0x5faa <LCD_write_data_4bit+0xa0>
		__ticks = 1;
    5f9e:	fe 01       	movw	r30, r28
    5fa0:	e8 5a       	subi	r30, 0xA8	; 168
    5fa2:	ff 4f       	sbci	r31, 0xFF	; 255
    5fa4:	81 e0       	ldi	r24, 0x01	; 1
    5fa6:	80 83       	st	Z, r24
    5fa8:	e0 c0       	rjmp	.+448    	; 0x616a <LCD_write_data_4bit+0x260>
	else if (__tmp > 255)
    5faa:	fe 01       	movw	r30, r28
    5fac:	e7 5a       	subi	r30, 0xA7	; 167
    5fae:	ff 4f       	sbci	r31, 0xFF	; 255
    5fb0:	60 81       	ld	r22, Z
    5fb2:	71 81       	ldd	r23, Z+1	; 0x01
    5fb4:	82 81       	ldd	r24, Z+2	; 0x02
    5fb6:	93 81       	ldd	r25, Z+3	; 0x03
    5fb8:	20 e0       	ldi	r18, 0x00	; 0
    5fba:	30 e0       	ldi	r19, 0x00	; 0
    5fbc:	4f e7       	ldi	r20, 0x7F	; 127
    5fbe:	53 e4       	ldi	r21, 0x43	; 67
    5fc0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5fc4:	18 16       	cp	r1, r24
    5fc6:	0c f0       	brlt	.+2      	; 0x5fca <LCD_write_data_4bit+0xc0>
    5fc8:	c0 c0       	rjmp	.+384    	; 0x614a <LCD_write_data_4bit+0x240>
	{
		_delay_ms(__us / 1000.0);
    5fca:	fe 01       	movw	r30, r28
    5fcc:	e3 5a       	subi	r30, 0xA3	; 163
    5fce:	ff 4f       	sbci	r31, 0xFF	; 255
    5fd0:	60 81       	ld	r22, Z
    5fd2:	71 81       	ldd	r23, Z+1	; 0x01
    5fd4:	82 81       	ldd	r24, Z+2	; 0x02
    5fd6:	93 81       	ldd	r25, Z+3	; 0x03
    5fd8:	20 e0       	ldi	r18, 0x00	; 0
    5fda:	30 e0       	ldi	r19, 0x00	; 0
    5fdc:	4a e7       	ldi	r20, 0x7A	; 122
    5fde:	54 e4       	ldi	r21, 0x44	; 68
    5fe0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    5fe4:	dc 01       	movw	r26, r24
    5fe6:	cb 01       	movw	r24, r22
    5fe8:	fe 01       	movw	r30, r28
    5fea:	ec 5a       	subi	r30, 0xAC	; 172
    5fec:	ff 4f       	sbci	r31, 0xFF	; 255
    5fee:	80 83       	st	Z, r24
    5ff0:	91 83       	std	Z+1, r25	; 0x01
    5ff2:	a2 83       	std	Z+2, r26	; 0x02
    5ff4:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5ff6:	8e 01       	movw	r16, r28
    5ff8:	00 5b       	subi	r16, 0xB0	; 176
    5ffa:	1f 4f       	sbci	r17, 0xFF	; 255
    5ffc:	fe 01       	movw	r30, r28
    5ffe:	ec 5a       	subi	r30, 0xAC	; 172
    6000:	ff 4f       	sbci	r31, 0xFF	; 255
    6002:	60 81       	ld	r22, Z
    6004:	71 81       	ldd	r23, Z+1	; 0x01
    6006:	82 81       	ldd	r24, Z+2	; 0x02
    6008:	93 81       	ldd	r25, Z+3	; 0x03
    600a:	20 e0       	ldi	r18, 0x00	; 0
    600c:	30 e0       	ldi	r19, 0x00	; 0
    600e:	4a e7       	ldi	r20, 0x7A	; 122
    6010:	55 e4       	ldi	r21, 0x45	; 69
    6012:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6016:	dc 01       	movw	r26, r24
    6018:	cb 01       	movw	r24, r22
    601a:	f8 01       	movw	r30, r16
    601c:	80 83       	st	Z, r24
    601e:	91 83       	std	Z+1, r25	; 0x01
    6020:	a2 83       	std	Z+2, r26	; 0x02
    6022:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    6024:	fe 01       	movw	r30, r28
    6026:	e0 5b       	subi	r30, 0xB0	; 176
    6028:	ff 4f       	sbci	r31, 0xFF	; 255
    602a:	60 81       	ld	r22, Z
    602c:	71 81       	ldd	r23, Z+1	; 0x01
    602e:	82 81       	ldd	r24, Z+2	; 0x02
    6030:	93 81       	ldd	r25, Z+3	; 0x03
    6032:	20 e0       	ldi	r18, 0x00	; 0
    6034:	30 e0       	ldi	r19, 0x00	; 0
    6036:	40 e8       	ldi	r20, 0x80	; 128
    6038:	5f e3       	ldi	r21, 0x3F	; 63
    603a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    603e:	88 23       	and	r24, r24
    6040:	44 f4       	brge	.+16     	; 0x6052 <LCD_write_data_4bit+0x148>
		__ticks = 1;
    6042:	fe 01       	movw	r30, r28
    6044:	e2 5b       	subi	r30, 0xB2	; 178
    6046:	ff 4f       	sbci	r31, 0xFF	; 255
    6048:	81 e0       	ldi	r24, 0x01	; 1
    604a:	90 e0       	ldi	r25, 0x00	; 0
    604c:	91 83       	std	Z+1, r25	; 0x01
    604e:	80 83       	st	Z, r24
    6050:	64 c0       	rjmp	.+200    	; 0x611a <LCD_write_data_4bit+0x210>
	else if (__tmp > 65535)
    6052:	fe 01       	movw	r30, r28
    6054:	e0 5b       	subi	r30, 0xB0	; 176
    6056:	ff 4f       	sbci	r31, 0xFF	; 255
    6058:	60 81       	ld	r22, Z
    605a:	71 81       	ldd	r23, Z+1	; 0x01
    605c:	82 81       	ldd	r24, Z+2	; 0x02
    605e:	93 81       	ldd	r25, Z+3	; 0x03
    6060:	20 e0       	ldi	r18, 0x00	; 0
    6062:	3f ef       	ldi	r19, 0xFF	; 255
    6064:	4f e7       	ldi	r20, 0x7F	; 127
    6066:	57 e4       	ldi	r21, 0x47	; 71
    6068:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    606c:	18 16       	cp	r1, r24
    606e:	0c f0       	brlt	.+2      	; 0x6072 <LCD_write_data_4bit+0x168>
    6070:	43 c0       	rjmp	.+134    	; 0x60f8 <LCD_write_data_4bit+0x1ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6072:	fe 01       	movw	r30, r28
    6074:	ec 5a       	subi	r30, 0xAC	; 172
    6076:	ff 4f       	sbci	r31, 0xFF	; 255
    6078:	60 81       	ld	r22, Z
    607a:	71 81       	ldd	r23, Z+1	; 0x01
    607c:	82 81       	ldd	r24, Z+2	; 0x02
    607e:	93 81       	ldd	r25, Z+3	; 0x03
    6080:	20 e0       	ldi	r18, 0x00	; 0
    6082:	30 e0       	ldi	r19, 0x00	; 0
    6084:	40 e2       	ldi	r20, 0x20	; 32
    6086:	51 e4       	ldi	r21, 0x41	; 65
    6088:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    608c:	dc 01       	movw	r26, r24
    608e:	cb 01       	movw	r24, r22
    6090:	8e 01       	movw	r16, r28
    6092:	02 5b       	subi	r16, 0xB2	; 178
    6094:	1f 4f       	sbci	r17, 0xFF	; 255
    6096:	bc 01       	movw	r22, r24
    6098:	cd 01       	movw	r24, r26
    609a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    609e:	dc 01       	movw	r26, r24
    60a0:	cb 01       	movw	r24, r22
    60a2:	f8 01       	movw	r30, r16
    60a4:	91 83       	std	Z+1, r25	; 0x01
    60a6:	80 83       	st	Z, r24
    60a8:	1f c0       	rjmp	.+62     	; 0x60e8 <LCD_write_data_4bit+0x1de>
    60aa:	fe 01       	movw	r30, r28
    60ac:	e4 5b       	subi	r30, 0xB4	; 180
    60ae:	ff 4f       	sbci	r31, 0xFF	; 255
    60b0:	80 e9       	ldi	r24, 0x90	; 144
    60b2:	91 e0       	ldi	r25, 0x01	; 1
    60b4:	91 83       	std	Z+1, r25	; 0x01
    60b6:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    60b8:	fe 01       	movw	r30, r28
    60ba:	e4 5b       	subi	r30, 0xB4	; 180
    60bc:	ff 4f       	sbci	r31, 0xFF	; 255
    60be:	80 81       	ld	r24, Z
    60c0:	91 81       	ldd	r25, Z+1	; 0x01
    60c2:	01 97       	sbiw	r24, 0x01	; 1
    60c4:	f1 f7       	brne	.-4      	; 0x60c2 <LCD_write_data_4bit+0x1b8>
    60c6:	fe 01       	movw	r30, r28
    60c8:	e4 5b       	subi	r30, 0xB4	; 180
    60ca:	ff 4f       	sbci	r31, 0xFF	; 255
    60cc:	91 83       	std	Z+1, r25	; 0x01
    60ce:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    60d0:	de 01       	movw	r26, r28
    60d2:	a2 5b       	subi	r26, 0xB2	; 178
    60d4:	bf 4f       	sbci	r27, 0xFF	; 255
    60d6:	fe 01       	movw	r30, r28
    60d8:	e2 5b       	subi	r30, 0xB2	; 178
    60da:	ff 4f       	sbci	r31, 0xFF	; 255
    60dc:	80 81       	ld	r24, Z
    60de:	91 81       	ldd	r25, Z+1	; 0x01
    60e0:	01 97       	sbiw	r24, 0x01	; 1
    60e2:	11 96       	adiw	r26, 0x01	; 1
    60e4:	9c 93       	st	X, r25
    60e6:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    60e8:	fe 01       	movw	r30, r28
    60ea:	e2 5b       	subi	r30, 0xB2	; 178
    60ec:	ff 4f       	sbci	r31, 0xFF	; 255
    60ee:	80 81       	ld	r24, Z
    60f0:	91 81       	ldd	r25, Z+1	; 0x01
    60f2:	00 97       	sbiw	r24, 0x00	; 0
    60f4:	d1 f6       	brne	.-76     	; 0x60aa <LCD_write_data_4bit+0x1a0>
    60f6:	4b c0       	rjmp	.+150    	; 0x618e <LCD_write_data_4bit+0x284>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    60f8:	8e 01       	movw	r16, r28
    60fa:	02 5b       	subi	r16, 0xB2	; 178
    60fc:	1f 4f       	sbci	r17, 0xFF	; 255
    60fe:	fe 01       	movw	r30, r28
    6100:	e0 5b       	subi	r30, 0xB0	; 176
    6102:	ff 4f       	sbci	r31, 0xFF	; 255
    6104:	60 81       	ld	r22, Z
    6106:	71 81       	ldd	r23, Z+1	; 0x01
    6108:	82 81       	ldd	r24, Z+2	; 0x02
    610a:	93 81       	ldd	r25, Z+3	; 0x03
    610c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6110:	dc 01       	movw	r26, r24
    6112:	cb 01       	movw	r24, r22
    6114:	f8 01       	movw	r30, r16
    6116:	91 83       	std	Z+1, r25	; 0x01
    6118:	80 83       	st	Z, r24
    611a:	de 01       	movw	r26, r28
    611c:	a6 5b       	subi	r26, 0xB6	; 182
    611e:	bf 4f       	sbci	r27, 0xFF	; 255
    6120:	fe 01       	movw	r30, r28
    6122:	e2 5b       	subi	r30, 0xB2	; 178
    6124:	ff 4f       	sbci	r31, 0xFF	; 255
    6126:	80 81       	ld	r24, Z
    6128:	91 81       	ldd	r25, Z+1	; 0x01
    612a:	11 96       	adiw	r26, 0x01	; 1
    612c:	9c 93       	st	X, r25
    612e:	8e 93       	st	-X, r24
    6130:	fe 01       	movw	r30, r28
    6132:	e6 5b       	subi	r30, 0xB6	; 182
    6134:	ff 4f       	sbci	r31, 0xFF	; 255
    6136:	80 81       	ld	r24, Z
    6138:	91 81       	ldd	r25, Z+1	; 0x01
    613a:	01 97       	sbiw	r24, 0x01	; 1
    613c:	f1 f7       	brne	.-4      	; 0x613a <LCD_write_data_4bit+0x230>
    613e:	fe 01       	movw	r30, r28
    6140:	e6 5b       	subi	r30, 0xB6	; 182
    6142:	ff 4f       	sbci	r31, 0xFF	; 255
    6144:	91 83       	std	Z+1, r25	; 0x01
    6146:	80 83       	st	Z, r24
    6148:	22 c0       	rjmp	.+68     	; 0x618e <LCD_write_data_4bit+0x284>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    614a:	8e 01       	movw	r16, r28
    614c:	08 5a       	subi	r16, 0xA8	; 168
    614e:	1f 4f       	sbci	r17, 0xFF	; 255
    6150:	fe 01       	movw	r30, r28
    6152:	e7 5a       	subi	r30, 0xA7	; 167
    6154:	ff 4f       	sbci	r31, 0xFF	; 255
    6156:	60 81       	ld	r22, Z
    6158:	71 81       	ldd	r23, Z+1	; 0x01
    615a:	82 81       	ldd	r24, Z+2	; 0x02
    615c:	93 81       	ldd	r25, Z+3	; 0x03
    615e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6162:	dc 01       	movw	r26, r24
    6164:	cb 01       	movw	r24, r22
    6166:	f8 01       	movw	r30, r16
    6168:	80 83       	st	Z, r24
    616a:	de 01       	movw	r26, r28
    616c:	a7 5b       	subi	r26, 0xB7	; 183
    616e:	bf 4f       	sbci	r27, 0xFF	; 255
    6170:	fe 01       	movw	r30, r28
    6172:	e8 5a       	subi	r30, 0xA8	; 168
    6174:	ff 4f       	sbci	r31, 0xFF	; 255
    6176:	80 81       	ld	r24, Z
    6178:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    617a:	fe 01       	movw	r30, r28
    617c:	e7 5b       	subi	r30, 0xB7	; 183
    617e:	ff 4f       	sbci	r31, 0xFF	; 255
    6180:	80 81       	ld	r24, Z
    6182:	8a 95       	dec	r24
    6184:	f1 f7       	brne	.-4      	; 0x6182 <LCD_write_data_4bit+0x278>
    6186:	fe 01       	movw	r30, r28
    6188:	e7 5b       	subi	r30, 0xB7	; 183
    618a:	ff 4f       	sbci	r31, 0xFF	; 255
    618c:	80 83       	st	Z, r24
	_delay_us(1);
	// Enable pin is high to send the higher nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    618e:	82 e0       	ldi	r24, 0x02	; 2
    6190:	60 e0       	ldi	r22, 0x00	; 0
    6192:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    6196:	fe 01       	movw	r30, r28
    6198:	eb 5b       	subi	r30, 0xBB	; 187
    619a:	ff 4f       	sbci	r31, 0xFF	; 255
    619c:	80 e0       	ldi	r24, 0x00	; 0
    619e:	90 e0       	ldi	r25, 0x00	; 0
    61a0:	a0 e8       	ldi	r26, 0x80	; 128
    61a2:	bf e3       	ldi	r27, 0x3F	; 63
    61a4:	80 83       	st	Z, r24
    61a6:	91 83       	std	Z+1, r25	; 0x01
    61a8:	a2 83       	std	Z+2, r26	; 0x02
    61aa:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    61ac:	8e 01       	movw	r16, r28
    61ae:	0f 5b       	subi	r16, 0xBF	; 191
    61b0:	1f 4f       	sbci	r17, 0xFF	; 255
    61b2:	fe 01       	movw	r30, r28
    61b4:	eb 5b       	subi	r30, 0xBB	; 187
    61b6:	ff 4f       	sbci	r31, 0xFF	; 255
    61b8:	60 81       	ld	r22, Z
    61ba:	71 81       	ldd	r23, Z+1	; 0x01
    61bc:	82 81       	ldd	r24, Z+2	; 0x02
    61be:	93 81       	ldd	r25, Z+3	; 0x03
    61c0:	2b ea       	ldi	r18, 0xAB	; 171
    61c2:	3a ea       	ldi	r19, 0xAA	; 170
    61c4:	4a ea       	ldi	r20, 0xAA	; 170
    61c6:	50 e4       	ldi	r21, 0x40	; 64
    61c8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    61cc:	dc 01       	movw	r26, r24
    61ce:	cb 01       	movw	r24, r22
    61d0:	f8 01       	movw	r30, r16
    61d2:	80 83       	st	Z, r24
    61d4:	91 83       	std	Z+1, r25	; 0x01
    61d6:	a2 83       	std	Z+2, r26	; 0x02
    61d8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    61da:	fe 01       	movw	r30, r28
    61dc:	ef 5b       	subi	r30, 0xBF	; 191
    61de:	ff 4f       	sbci	r31, 0xFF	; 255
    61e0:	60 81       	ld	r22, Z
    61e2:	71 81       	ldd	r23, Z+1	; 0x01
    61e4:	82 81       	ldd	r24, Z+2	; 0x02
    61e6:	93 81       	ldd	r25, Z+3	; 0x03
    61e8:	20 e0       	ldi	r18, 0x00	; 0
    61ea:	30 e0       	ldi	r19, 0x00	; 0
    61ec:	40 e8       	ldi	r20, 0x80	; 128
    61ee:	5f e3       	ldi	r21, 0x3F	; 63
    61f0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    61f4:	88 23       	and	r24, r24
    61f6:	34 f4       	brge	.+12     	; 0x6204 <LCD_write_data_4bit+0x2fa>
		__ticks = 1;
    61f8:	81 e0       	ldi	r24, 0x01	; 1
    61fa:	fe 01       	movw	r30, r28
    61fc:	e0 5c       	subi	r30, 0xC0	; 192
    61fe:	ff 4f       	sbci	r31, 0xFF	; 255
    6200:	80 83       	st	Z, r24
    6202:	9d c0       	rjmp	.+314    	; 0x633e <LCD_write_data_4bit+0x434>
	else if (__tmp > 255)
    6204:	fe 01       	movw	r30, r28
    6206:	ef 5b       	subi	r30, 0xBF	; 191
    6208:	ff 4f       	sbci	r31, 0xFF	; 255
    620a:	60 81       	ld	r22, Z
    620c:	71 81       	ldd	r23, Z+1	; 0x01
    620e:	82 81       	ldd	r24, Z+2	; 0x02
    6210:	93 81       	ldd	r25, Z+3	; 0x03
    6212:	20 e0       	ldi	r18, 0x00	; 0
    6214:	30 e0       	ldi	r19, 0x00	; 0
    6216:	4f e7       	ldi	r20, 0x7F	; 127
    6218:	53 e4       	ldi	r21, 0x43	; 67
    621a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    621e:	18 16       	cp	r1, r24
    6220:	0c f0       	brlt	.+2      	; 0x6224 <LCD_write_data_4bit+0x31a>
    6222:	7e c0       	rjmp	.+252    	; 0x6320 <LCD_write_data_4bit+0x416>
	{
		_delay_ms(__us / 1000.0);
    6224:	fe 01       	movw	r30, r28
    6226:	eb 5b       	subi	r30, 0xBB	; 187
    6228:	ff 4f       	sbci	r31, 0xFF	; 255
    622a:	60 81       	ld	r22, Z
    622c:	71 81       	ldd	r23, Z+1	; 0x01
    622e:	82 81       	ldd	r24, Z+2	; 0x02
    6230:	93 81       	ldd	r25, Z+3	; 0x03
    6232:	20 e0       	ldi	r18, 0x00	; 0
    6234:	30 e0       	ldi	r19, 0x00	; 0
    6236:	4a e7       	ldi	r20, 0x7A	; 122
    6238:	54 e4       	ldi	r21, 0x44	; 68
    623a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    623e:	dc 01       	movw	r26, r24
    6240:	cb 01       	movw	r24, r22
    6242:	8c af       	std	Y+60, r24	; 0x3c
    6244:	9d af       	std	Y+61, r25	; 0x3d
    6246:	ae af       	std	Y+62, r26	; 0x3e
    6248:	bf af       	std	Y+63, r27	; 0x3f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    624a:	6c ad       	ldd	r22, Y+60	; 0x3c
    624c:	7d ad       	ldd	r23, Y+61	; 0x3d
    624e:	8e ad       	ldd	r24, Y+62	; 0x3e
    6250:	9f ad       	ldd	r25, Y+63	; 0x3f
    6252:	20 e0       	ldi	r18, 0x00	; 0
    6254:	30 e0       	ldi	r19, 0x00	; 0
    6256:	4a e7       	ldi	r20, 0x7A	; 122
    6258:	55 e4       	ldi	r21, 0x45	; 69
    625a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    625e:	dc 01       	movw	r26, r24
    6260:	cb 01       	movw	r24, r22
    6262:	88 af       	std	Y+56, r24	; 0x38
    6264:	99 af       	std	Y+57, r25	; 0x39
    6266:	aa af       	std	Y+58, r26	; 0x3a
    6268:	bb af       	std	Y+59, r27	; 0x3b
	if (__tmp < 1.0)
    626a:	68 ad       	ldd	r22, Y+56	; 0x38
    626c:	79 ad       	ldd	r23, Y+57	; 0x39
    626e:	8a ad       	ldd	r24, Y+58	; 0x3a
    6270:	9b ad       	ldd	r25, Y+59	; 0x3b
    6272:	20 e0       	ldi	r18, 0x00	; 0
    6274:	30 e0       	ldi	r19, 0x00	; 0
    6276:	40 e8       	ldi	r20, 0x80	; 128
    6278:	5f e3       	ldi	r21, 0x3F	; 63
    627a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    627e:	88 23       	and	r24, r24
    6280:	2c f4       	brge	.+10     	; 0x628c <LCD_write_data_4bit+0x382>
		__ticks = 1;
    6282:	81 e0       	ldi	r24, 0x01	; 1
    6284:	90 e0       	ldi	r25, 0x00	; 0
    6286:	9f ab       	std	Y+55, r25	; 0x37
    6288:	8e ab       	std	Y+54, r24	; 0x36
    628a:	3f c0       	rjmp	.+126    	; 0x630a <LCD_write_data_4bit+0x400>
	else if (__tmp > 65535)
    628c:	68 ad       	ldd	r22, Y+56	; 0x38
    628e:	79 ad       	ldd	r23, Y+57	; 0x39
    6290:	8a ad       	ldd	r24, Y+58	; 0x3a
    6292:	9b ad       	ldd	r25, Y+59	; 0x3b
    6294:	20 e0       	ldi	r18, 0x00	; 0
    6296:	3f ef       	ldi	r19, 0xFF	; 255
    6298:	4f e7       	ldi	r20, 0x7F	; 127
    629a:	57 e4       	ldi	r21, 0x47	; 71
    629c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    62a0:	18 16       	cp	r1, r24
    62a2:	4c f5       	brge	.+82     	; 0x62f6 <LCD_write_data_4bit+0x3ec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    62a4:	6c ad       	ldd	r22, Y+60	; 0x3c
    62a6:	7d ad       	ldd	r23, Y+61	; 0x3d
    62a8:	8e ad       	ldd	r24, Y+62	; 0x3e
    62aa:	9f ad       	ldd	r25, Y+63	; 0x3f
    62ac:	20 e0       	ldi	r18, 0x00	; 0
    62ae:	30 e0       	ldi	r19, 0x00	; 0
    62b0:	40 e2       	ldi	r20, 0x20	; 32
    62b2:	51 e4       	ldi	r21, 0x41	; 65
    62b4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    62b8:	dc 01       	movw	r26, r24
    62ba:	cb 01       	movw	r24, r22
    62bc:	bc 01       	movw	r22, r24
    62be:	cd 01       	movw	r24, r26
    62c0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    62c4:	dc 01       	movw	r26, r24
    62c6:	cb 01       	movw	r24, r22
    62c8:	9f ab       	std	Y+55, r25	; 0x37
    62ca:	8e ab       	std	Y+54, r24	; 0x36
    62cc:	0f c0       	rjmp	.+30     	; 0x62ec <LCD_write_data_4bit+0x3e2>
    62ce:	80 e9       	ldi	r24, 0x90	; 144
    62d0:	91 e0       	ldi	r25, 0x01	; 1
    62d2:	9d ab       	std	Y+53, r25	; 0x35
    62d4:	8c ab       	std	Y+52, r24	; 0x34
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    62d6:	8c a9       	ldd	r24, Y+52	; 0x34
    62d8:	9d a9       	ldd	r25, Y+53	; 0x35
    62da:	01 97       	sbiw	r24, 0x01	; 1
    62dc:	f1 f7       	brne	.-4      	; 0x62da <LCD_write_data_4bit+0x3d0>
    62de:	9d ab       	std	Y+53, r25	; 0x35
    62e0:	8c ab       	std	Y+52, r24	; 0x34
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    62e2:	8e a9       	ldd	r24, Y+54	; 0x36
    62e4:	9f a9       	ldd	r25, Y+55	; 0x37
    62e6:	01 97       	sbiw	r24, 0x01	; 1
    62e8:	9f ab       	std	Y+55, r25	; 0x37
    62ea:	8e ab       	std	Y+54, r24	; 0x36
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    62ec:	8e a9       	ldd	r24, Y+54	; 0x36
    62ee:	9f a9       	ldd	r25, Y+55	; 0x37
    62f0:	00 97       	sbiw	r24, 0x00	; 0
    62f2:	69 f7       	brne	.-38     	; 0x62ce <LCD_write_data_4bit+0x3c4>
    62f4:	2d c0       	rjmp	.+90     	; 0x6350 <LCD_write_data_4bit+0x446>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    62f6:	68 ad       	ldd	r22, Y+56	; 0x38
    62f8:	79 ad       	ldd	r23, Y+57	; 0x39
    62fa:	8a ad       	ldd	r24, Y+58	; 0x3a
    62fc:	9b ad       	ldd	r25, Y+59	; 0x3b
    62fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6302:	dc 01       	movw	r26, r24
    6304:	cb 01       	movw	r24, r22
    6306:	9f ab       	std	Y+55, r25	; 0x37
    6308:	8e ab       	std	Y+54, r24	; 0x36
    630a:	8e a9       	ldd	r24, Y+54	; 0x36
    630c:	9f a9       	ldd	r25, Y+55	; 0x37
    630e:	9b ab       	std	Y+51, r25	; 0x33
    6310:	8a ab       	std	Y+50, r24	; 0x32
    6312:	8a a9       	ldd	r24, Y+50	; 0x32
    6314:	9b a9       	ldd	r25, Y+51	; 0x33
    6316:	01 97       	sbiw	r24, 0x01	; 1
    6318:	f1 f7       	brne	.-4      	; 0x6316 <LCD_write_data_4bit+0x40c>
    631a:	9b ab       	std	Y+51, r25	; 0x33
    631c:	8a ab       	std	Y+50, r24	; 0x32
    631e:	18 c0       	rjmp	.+48     	; 0x6350 <LCD_write_data_4bit+0x446>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6320:	fe 01       	movw	r30, r28
    6322:	ef 5b       	subi	r30, 0xBF	; 191
    6324:	ff 4f       	sbci	r31, 0xFF	; 255
    6326:	60 81       	ld	r22, Z
    6328:	71 81       	ldd	r23, Z+1	; 0x01
    632a:	82 81       	ldd	r24, Z+2	; 0x02
    632c:	93 81       	ldd	r25, Z+3	; 0x03
    632e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6332:	dc 01       	movw	r26, r24
    6334:	cb 01       	movw	r24, r22
    6336:	fe 01       	movw	r30, r28
    6338:	e0 5c       	subi	r30, 0xC0	; 192
    633a:	ff 4f       	sbci	r31, 0xFF	; 255
    633c:	80 83       	st	Z, r24
    633e:	fe 01       	movw	r30, r28
    6340:	e0 5c       	subi	r30, 0xC0	; 192
    6342:	ff 4f       	sbci	r31, 0xFF	; 255
    6344:	80 81       	ld	r24, Z
    6346:	89 ab       	std	Y+49, r24	; 0x31
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6348:	89 a9       	ldd	r24, Y+49	; 0x31
    634a:	8a 95       	dec	r24
    634c:	f1 f7       	brne	.-4      	; 0x634a <LCD_write_data_4bit+0x440>
    634e:	89 ab       	std	Y+49, r24	; 0x31
	_delay_us(1);
	// Sent the higher nipple
	for(u8 i= 4; i< 8; i++)
    6350:	fe 01       	movw	r30, r28
    6352:	ee 59       	subi	r30, 0x9E	; 158
    6354:	ff 4f       	sbci	r31, 0xFF	; 255
    6356:	84 e0       	ldi	r24, 0x04	; 4
    6358:	80 83       	st	Z, r24
    635a:	26 c0       	rjmp	.+76     	; 0x63a8 <LCD_write_data_4bit+0x49e>
			DIO_void_assign_pin(lcd_data_port, i, get_bit(lcd_copy_word_4bit, i));
    635c:	fe 01       	movw	r30, r28
    635e:	ed 59       	subi	r30, 0x9D	; 157
    6360:	ff 4f       	sbci	r31, 0xFF	; 255
    6362:	80 81       	ld	r24, Z
    6364:	28 2f       	mov	r18, r24
    6366:	30 e0       	ldi	r19, 0x00	; 0
    6368:	fe 01       	movw	r30, r28
    636a:	ee 59       	subi	r30, 0x9E	; 158
    636c:	ff 4f       	sbci	r31, 0xFF	; 255
    636e:	80 81       	ld	r24, Z
    6370:	88 2f       	mov	r24, r24
    6372:	90 e0       	ldi	r25, 0x00	; 0
    6374:	a9 01       	movw	r20, r18
    6376:	02 c0       	rjmp	.+4      	; 0x637c <LCD_write_data_4bit+0x472>
    6378:	55 95       	asr	r21
    637a:	47 95       	ror	r20
    637c:	8a 95       	dec	r24
    637e:	e2 f7       	brpl	.-8      	; 0x6378 <LCD_write_data_4bit+0x46e>
    6380:	ca 01       	movw	r24, r20
    6382:	98 2f       	mov	r25, r24
    6384:	91 70       	andi	r25, 0x01	; 1
    6386:	fe 01       	movw	r30, r28
    6388:	ee 59       	subi	r30, 0x9E	; 158
    638a:	ff 4f       	sbci	r31, 0xFF	; 255
    638c:	82 e0       	ldi	r24, 0x02	; 2
    638e:	60 81       	ld	r22, Z
    6390:	49 2f       	mov	r20, r25
    6392:	0e 94 6a 27 	call	0x4ed4	; 0x4ed4 <DIO_void_assign_pin>
	_delay_us(1);
	// Enable pin is high to send the higher nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
	_delay_us(1);
	// Sent the higher nipple
	for(u8 i= 4; i< 8; i++)
    6396:	de 01       	movw	r26, r28
    6398:	ae 59       	subi	r26, 0x9E	; 158
    639a:	bf 4f       	sbci	r27, 0xFF	; 255
    639c:	fe 01       	movw	r30, r28
    639e:	ee 59       	subi	r30, 0x9E	; 158
    63a0:	ff 4f       	sbci	r31, 0xFF	; 255
    63a2:	80 81       	ld	r24, Z
    63a4:	8f 5f       	subi	r24, 0xFF	; 255
    63a6:	8c 93       	st	X, r24
    63a8:	fe 01       	movw	r30, r28
    63aa:	ee 59       	subi	r30, 0x9E	; 158
    63ac:	ff 4f       	sbci	r31, 0xFF	; 255
    63ae:	80 81       	ld	r24, Z
    63b0:	88 30       	cpi	r24, 0x08	; 8
    63b2:	a0 f2       	brcs	.-88     	; 0x635c <LCD_write_data_4bit+0x452>
			DIO_void_assign_pin(lcd_data_port, i, get_bit(lcd_copy_word_4bit, i));
	// Enable pin low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    63b4:	82 e0       	ldi	r24, 0x02	; 2
    63b6:	60 e0       	ldi	r22, 0x00	; 0
    63b8:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    63bc:	80 e0       	ldi	r24, 0x00	; 0
    63be:	90 e0       	ldi	r25, 0x00	; 0
    63c0:	a0 e2       	ldi	r26, 0x20	; 32
    63c2:	b1 e4       	ldi	r27, 0x41	; 65
    63c4:	8d a7       	std	Y+45, r24	; 0x2d
    63c6:	9e a7       	std	Y+46, r25	; 0x2e
    63c8:	af a7       	std	Y+47, r26	; 0x2f
    63ca:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    63cc:	6d a5       	ldd	r22, Y+45	; 0x2d
    63ce:	7e a5       	ldd	r23, Y+46	; 0x2e
    63d0:	8f a5       	ldd	r24, Y+47	; 0x2f
    63d2:	98 a9       	ldd	r25, Y+48	; 0x30
    63d4:	2b ea       	ldi	r18, 0xAB	; 171
    63d6:	3a ea       	ldi	r19, 0xAA	; 170
    63d8:	4a ea       	ldi	r20, 0xAA	; 170
    63da:	50 e4       	ldi	r21, 0x40	; 64
    63dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    63e0:	dc 01       	movw	r26, r24
    63e2:	cb 01       	movw	r24, r22
    63e4:	89 a7       	std	Y+41, r24	; 0x29
    63e6:	9a a7       	std	Y+42, r25	; 0x2a
    63e8:	ab a7       	std	Y+43, r26	; 0x2b
    63ea:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    63ec:	69 a5       	ldd	r22, Y+41	; 0x29
    63ee:	7a a5       	ldd	r23, Y+42	; 0x2a
    63f0:	8b a5       	ldd	r24, Y+43	; 0x2b
    63f2:	9c a5       	ldd	r25, Y+44	; 0x2c
    63f4:	20 e0       	ldi	r18, 0x00	; 0
    63f6:	30 e0       	ldi	r19, 0x00	; 0
    63f8:	40 e8       	ldi	r20, 0x80	; 128
    63fa:	5f e3       	ldi	r21, 0x3F	; 63
    63fc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6400:	88 23       	and	r24, r24
    6402:	1c f4       	brge	.+6      	; 0x640a <LCD_write_data_4bit+0x500>
		__ticks = 1;
    6404:	81 e0       	ldi	r24, 0x01	; 1
    6406:	88 a7       	std	Y+40, r24	; 0x28
    6408:	91 c0       	rjmp	.+290    	; 0x652c <LCD_write_data_4bit+0x622>
	else if (__tmp > 255)
    640a:	69 a5       	ldd	r22, Y+41	; 0x29
    640c:	7a a5       	ldd	r23, Y+42	; 0x2a
    640e:	8b a5       	ldd	r24, Y+43	; 0x2b
    6410:	9c a5       	ldd	r25, Y+44	; 0x2c
    6412:	20 e0       	ldi	r18, 0x00	; 0
    6414:	30 e0       	ldi	r19, 0x00	; 0
    6416:	4f e7       	ldi	r20, 0x7F	; 127
    6418:	53 e4       	ldi	r21, 0x43	; 67
    641a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    641e:	18 16       	cp	r1, r24
    6420:	0c f0       	brlt	.+2      	; 0x6424 <LCD_write_data_4bit+0x51a>
    6422:	7b c0       	rjmp	.+246    	; 0x651a <LCD_write_data_4bit+0x610>
	{
		_delay_ms(__us / 1000.0);
    6424:	6d a5       	ldd	r22, Y+45	; 0x2d
    6426:	7e a5       	ldd	r23, Y+46	; 0x2e
    6428:	8f a5       	ldd	r24, Y+47	; 0x2f
    642a:	98 a9       	ldd	r25, Y+48	; 0x30
    642c:	20 e0       	ldi	r18, 0x00	; 0
    642e:	30 e0       	ldi	r19, 0x00	; 0
    6430:	4a e7       	ldi	r20, 0x7A	; 122
    6432:	54 e4       	ldi	r21, 0x44	; 68
    6434:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6438:	dc 01       	movw	r26, r24
    643a:	cb 01       	movw	r24, r22
    643c:	8c a3       	std	Y+36, r24	; 0x24
    643e:	9d a3       	std	Y+37, r25	; 0x25
    6440:	ae a3       	std	Y+38, r26	; 0x26
    6442:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6444:	6c a1       	ldd	r22, Y+36	; 0x24
    6446:	7d a1       	ldd	r23, Y+37	; 0x25
    6448:	8e a1       	ldd	r24, Y+38	; 0x26
    644a:	9f a1       	ldd	r25, Y+39	; 0x27
    644c:	20 e0       	ldi	r18, 0x00	; 0
    644e:	30 e0       	ldi	r19, 0x00	; 0
    6450:	4a e7       	ldi	r20, 0x7A	; 122
    6452:	55 e4       	ldi	r21, 0x45	; 69
    6454:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6458:	dc 01       	movw	r26, r24
    645a:	cb 01       	movw	r24, r22
    645c:	88 a3       	std	Y+32, r24	; 0x20
    645e:	99 a3       	std	Y+33, r25	; 0x21
    6460:	aa a3       	std	Y+34, r26	; 0x22
    6462:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    6464:	68 a1       	ldd	r22, Y+32	; 0x20
    6466:	79 a1       	ldd	r23, Y+33	; 0x21
    6468:	8a a1       	ldd	r24, Y+34	; 0x22
    646a:	9b a1       	ldd	r25, Y+35	; 0x23
    646c:	20 e0       	ldi	r18, 0x00	; 0
    646e:	30 e0       	ldi	r19, 0x00	; 0
    6470:	40 e8       	ldi	r20, 0x80	; 128
    6472:	5f e3       	ldi	r21, 0x3F	; 63
    6474:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6478:	88 23       	and	r24, r24
    647a:	2c f4       	brge	.+10     	; 0x6486 <LCD_write_data_4bit+0x57c>
		__ticks = 1;
    647c:	81 e0       	ldi	r24, 0x01	; 1
    647e:	90 e0       	ldi	r25, 0x00	; 0
    6480:	9f 8f       	std	Y+31, r25	; 0x1f
    6482:	8e 8f       	std	Y+30, r24	; 0x1e
    6484:	3f c0       	rjmp	.+126    	; 0x6504 <LCD_write_data_4bit+0x5fa>
	else if (__tmp > 65535)
    6486:	68 a1       	ldd	r22, Y+32	; 0x20
    6488:	79 a1       	ldd	r23, Y+33	; 0x21
    648a:	8a a1       	ldd	r24, Y+34	; 0x22
    648c:	9b a1       	ldd	r25, Y+35	; 0x23
    648e:	20 e0       	ldi	r18, 0x00	; 0
    6490:	3f ef       	ldi	r19, 0xFF	; 255
    6492:	4f e7       	ldi	r20, 0x7F	; 127
    6494:	57 e4       	ldi	r21, 0x47	; 71
    6496:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    649a:	18 16       	cp	r1, r24
    649c:	4c f5       	brge	.+82     	; 0x64f0 <LCD_write_data_4bit+0x5e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    649e:	6c a1       	ldd	r22, Y+36	; 0x24
    64a0:	7d a1       	ldd	r23, Y+37	; 0x25
    64a2:	8e a1       	ldd	r24, Y+38	; 0x26
    64a4:	9f a1       	ldd	r25, Y+39	; 0x27
    64a6:	20 e0       	ldi	r18, 0x00	; 0
    64a8:	30 e0       	ldi	r19, 0x00	; 0
    64aa:	40 e2       	ldi	r20, 0x20	; 32
    64ac:	51 e4       	ldi	r21, 0x41	; 65
    64ae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    64b2:	dc 01       	movw	r26, r24
    64b4:	cb 01       	movw	r24, r22
    64b6:	bc 01       	movw	r22, r24
    64b8:	cd 01       	movw	r24, r26
    64ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    64be:	dc 01       	movw	r26, r24
    64c0:	cb 01       	movw	r24, r22
    64c2:	9f 8f       	std	Y+31, r25	; 0x1f
    64c4:	8e 8f       	std	Y+30, r24	; 0x1e
    64c6:	0f c0       	rjmp	.+30     	; 0x64e6 <LCD_write_data_4bit+0x5dc>
    64c8:	80 e9       	ldi	r24, 0x90	; 144
    64ca:	91 e0       	ldi	r25, 0x01	; 1
    64cc:	9d 8f       	std	Y+29, r25	; 0x1d
    64ce:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    64d0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    64d2:	9d 8d       	ldd	r25, Y+29	; 0x1d
    64d4:	01 97       	sbiw	r24, 0x01	; 1
    64d6:	f1 f7       	brne	.-4      	; 0x64d4 <LCD_write_data_4bit+0x5ca>
    64d8:	9d 8f       	std	Y+29, r25	; 0x1d
    64da:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    64dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    64de:	9f 8d       	ldd	r25, Y+31	; 0x1f
    64e0:	01 97       	sbiw	r24, 0x01	; 1
    64e2:	9f 8f       	std	Y+31, r25	; 0x1f
    64e4:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    64e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    64e8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    64ea:	00 97       	sbiw	r24, 0x00	; 0
    64ec:	69 f7       	brne	.-38     	; 0x64c8 <LCD_write_data_4bit+0x5be>
    64ee:	24 c0       	rjmp	.+72     	; 0x6538 <LCD_write_data_4bit+0x62e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    64f0:	68 a1       	ldd	r22, Y+32	; 0x20
    64f2:	79 a1       	ldd	r23, Y+33	; 0x21
    64f4:	8a a1       	ldd	r24, Y+34	; 0x22
    64f6:	9b a1       	ldd	r25, Y+35	; 0x23
    64f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    64fc:	dc 01       	movw	r26, r24
    64fe:	cb 01       	movw	r24, r22
    6500:	9f 8f       	std	Y+31, r25	; 0x1f
    6502:	8e 8f       	std	Y+30, r24	; 0x1e
    6504:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6506:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6508:	9b 8f       	std	Y+27, r25	; 0x1b
    650a:	8a 8f       	std	Y+26, r24	; 0x1a
    650c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    650e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6510:	01 97       	sbiw	r24, 0x01	; 1
    6512:	f1 f7       	brne	.-4      	; 0x6510 <LCD_write_data_4bit+0x606>
    6514:	9b 8f       	std	Y+27, r25	; 0x1b
    6516:	8a 8f       	std	Y+26, r24	; 0x1a
    6518:	0f c0       	rjmp	.+30     	; 0x6538 <LCD_write_data_4bit+0x62e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    651a:	69 a5       	ldd	r22, Y+41	; 0x29
    651c:	7a a5       	ldd	r23, Y+42	; 0x2a
    651e:	8b a5       	ldd	r24, Y+43	; 0x2b
    6520:	9c a5       	ldd	r25, Y+44	; 0x2c
    6522:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6526:	dc 01       	movw	r26, r24
    6528:	cb 01       	movw	r24, r22
    652a:	88 a7       	std	Y+40, r24	; 0x28
    652c:	88 a5       	ldd	r24, Y+40	; 0x28
    652e:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6530:	89 8d       	ldd	r24, Y+25	; 0x19
    6532:	8a 95       	dec	r24
    6534:	f1 f7       	brne	.-4      	; 0x6532 <LCD_write_data_4bit+0x628>
    6536:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(10);
	// Enable pin is high to send the Lower nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    6538:	82 e0       	ldi	r24, 0x02	; 2
    653a:	60 e0       	ldi	r22, 0x00	; 0
    653c:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    6540:	80 e0       	ldi	r24, 0x00	; 0
    6542:	90 e0       	ldi	r25, 0x00	; 0
    6544:	a0 e8       	ldi	r26, 0x80	; 128
    6546:	bf e3       	ldi	r27, 0x3F	; 63
    6548:	8d 8b       	std	Y+21, r24	; 0x15
    654a:	9e 8b       	std	Y+22, r25	; 0x16
    654c:	af 8b       	std	Y+23, r26	; 0x17
    654e:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    6550:	6d 89       	ldd	r22, Y+21	; 0x15
    6552:	7e 89       	ldd	r23, Y+22	; 0x16
    6554:	8f 89       	ldd	r24, Y+23	; 0x17
    6556:	98 8d       	ldd	r25, Y+24	; 0x18
    6558:	2b ea       	ldi	r18, 0xAB	; 171
    655a:	3a ea       	ldi	r19, 0xAA	; 170
    655c:	4a ea       	ldi	r20, 0xAA	; 170
    655e:	50 e4       	ldi	r21, 0x40	; 64
    6560:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6564:	dc 01       	movw	r26, r24
    6566:	cb 01       	movw	r24, r22
    6568:	89 8b       	std	Y+17, r24	; 0x11
    656a:	9a 8b       	std	Y+18, r25	; 0x12
    656c:	ab 8b       	std	Y+19, r26	; 0x13
    656e:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    6570:	69 89       	ldd	r22, Y+17	; 0x11
    6572:	7a 89       	ldd	r23, Y+18	; 0x12
    6574:	8b 89       	ldd	r24, Y+19	; 0x13
    6576:	9c 89       	ldd	r25, Y+20	; 0x14
    6578:	20 e0       	ldi	r18, 0x00	; 0
    657a:	30 e0       	ldi	r19, 0x00	; 0
    657c:	40 e8       	ldi	r20, 0x80	; 128
    657e:	5f e3       	ldi	r21, 0x3F	; 63
    6580:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6584:	88 23       	and	r24, r24
    6586:	1c f4       	brge	.+6      	; 0x658e <LCD_write_data_4bit+0x684>
		__ticks = 1;
    6588:	81 e0       	ldi	r24, 0x01	; 1
    658a:	88 8b       	std	Y+16, r24	; 0x10
    658c:	91 c0       	rjmp	.+290    	; 0x66b0 <LCD_write_data_4bit+0x7a6>
	else if (__tmp > 255)
    658e:	69 89       	ldd	r22, Y+17	; 0x11
    6590:	7a 89       	ldd	r23, Y+18	; 0x12
    6592:	8b 89       	ldd	r24, Y+19	; 0x13
    6594:	9c 89       	ldd	r25, Y+20	; 0x14
    6596:	20 e0       	ldi	r18, 0x00	; 0
    6598:	30 e0       	ldi	r19, 0x00	; 0
    659a:	4f e7       	ldi	r20, 0x7F	; 127
    659c:	53 e4       	ldi	r21, 0x43	; 67
    659e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    65a2:	18 16       	cp	r1, r24
    65a4:	0c f0       	brlt	.+2      	; 0x65a8 <LCD_write_data_4bit+0x69e>
    65a6:	7b c0       	rjmp	.+246    	; 0x669e <LCD_write_data_4bit+0x794>
	{
		_delay_ms(__us / 1000.0);
    65a8:	6d 89       	ldd	r22, Y+21	; 0x15
    65aa:	7e 89       	ldd	r23, Y+22	; 0x16
    65ac:	8f 89       	ldd	r24, Y+23	; 0x17
    65ae:	98 8d       	ldd	r25, Y+24	; 0x18
    65b0:	20 e0       	ldi	r18, 0x00	; 0
    65b2:	30 e0       	ldi	r19, 0x00	; 0
    65b4:	4a e7       	ldi	r20, 0x7A	; 122
    65b6:	54 e4       	ldi	r21, 0x44	; 68
    65b8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    65bc:	dc 01       	movw	r26, r24
    65be:	cb 01       	movw	r24, r22
    65c0:	8c 87       	std	Y+12, r24	; 0x0c
    65c2:	9d 87       	std	Y+13, r25	; 0x0d
    65c4:	ae 87       	std	Y+14, r26	; 0x0e
    65c6:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    65c8:	6c 85       	ldd	r22, Y+12	; 0x0c
    65ca:	7d 85       	ldd	r23, Y+13	; 0x0d
    65cc:	8e 85       	ldd	r24, Y+14	; 0x0e
    65ce:	9f 85       	ldd	r25, Y+15	; 0x0f
    65d0:	20 e0       	ldi	r18, 0x00	; 0
    65d2:	30 e0       	ldi	r19, 0x00	; 0
    65d4:	4a e7       	ldi	r20, 0x7A	; 122
    65d6:	55 e4       	ldi	r21, 0x45	; 69
    65d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    65dc:	dc 01       	movw	r26, r24
    65de:	cb 01       	movw	r24, r22
    65e0:	88 87       	std	Y+8, r24	; 0x08
    65e2:	99 87       	std	Y+9, r25	; 0x09
    65e4:	aa 87       	std	Y+10, r26	; 0x0a
    65e6:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    65e8:	68 85       	ldd	r22, Y+8	; 0x08
    65ea:	79 85       	ldd	r23, Y+9	; 0x09
    65ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    65ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    65f0:	20 e0       	ldi	r18, 0x00	; 0
    65f2:	30 e0       	ldi	r19, 0x00	; 0
    65f4:	40 e8       	ldi	r20, 0x80	; 128
    65f6:	5f e3       	ldi	r21, 0x3F	; 63
    65f8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    65fc:	88 23       	and	r24, r24
    65fe:	2c f4       	brge	.+10     	; 0x660a <LCD_write_data_4bit+0x700>
		__ticks = 1;
    6600:	81 e0       	ldi	r24, 0x01	; 1
    6602:	90 e0       	ldi	r25, 0x00	; 0
    6604:	9f 83       	std	Y+7, r25	; 0x07
    6606:	8e 83       	std	Y+6, r24	; 0x06
    6608:	3f c0       	rjmp	.+126    	; 0x6688 <LCD_write_data_4bit+0x77e>
	else if (__tmp > 65535)
    660a:	68 85       	ldd	r22, Y+8	; 0x08
    660c:	79 85       	ldd	r23, Y+9	; 0x09
    660e:	8a 85       	ldd	r24, Y+10	; 0x0a
    6610:	9b 85       	ldd	r25, Y+11	; 0x0b
    6612:	20 e0       	ldi	r18, 0x00	; 0
    6614:	3f ef       	ldi	r19, 0xFF	; 255
    6616:	4f e7       	ldi	r20, 0x7F	; 127
    6618:	57 e4       	ldi	r21, 0x47	; 71
    661a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    661e:	18 16       	cp	r1, r24
    6620:	4c f5       	brge	.+82     	; 0x6674 <LCD_write_data_4bit+0x76a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6622:	6c 85       	ldd	r22, Y+12	; 0x0c
    6624:	7d 85       	ldd	r23, Y+13	; 0x0d
    6626:	8e 85       	ldd	r24, Y+14	; 0x0e
    6628:	9f 85       	ldd	r25, Y+15	; 0x0f
    662a:	20 e0       	ldi	r18, 0x00	; 0
    662c:	30 e0       	ldi	r19, 0x00	; 0
    662e:	40 e2       	ldi	r20, 0x20	; 32
    6630:	51 e4       	ldi	r21, 0x41	; 65
    6632:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6636:	dc 01       	movw	r26, r24
    6638:	cb 01       	movw	r24, r22
    663a:	bc 01       	movw	r22, r24
    663c:	cd 01       	movw	r24, r26
    663e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6642:	dc 01       	movw	r26, r24
    6644:	cb 01       	movw	r24, r22
    6646:	9f 83       	std	Y+7, r25	; 0x07
    6648:	8e 83       	std	Y+6, r24	; 0x06
    664a:	0f c0       	rjmp	.+30     	; 0x666a <LCD_write_data_4bit+0x760>
    664c:	80 e9       	ldi	r24, 0x90	; 144
    664e:	91 e0       	ldi	r25, 0x01	; 1
    6650:	9d 83       	std	Y+5, r25	; 0x05
    6652:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6654:	8c 81       	ldd	r24, Y+4	; 0x04
    6656:	9d 81       	ldd	r25, Y+5	; 0x05
    6658:	01 97       	sbiw	r24, 0x01	; 1
    665a:	f1 f7       	brne	.-4      	; 0x6658 <LCD_write_data_4bit+0x74e>
    665c:	9d 83       	std	Y+5, r25	; 0x05
    665e:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6660:	8e 81       	ldd	r24, Y+6	; 0x06
    6662:	9f 81       	ldd	r25, Y+7	; 0x07
    6664:	01 97       	sbiw	r24, 0x01	; 1
    6666:	9f 83       	std	Y+7, r25	; 0x07
    6668:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    666a:	8e 81       	ldd	r24, Y+6	; 0x06
    666c:	9f 81       	ldd	r25, Y+7	; 0x07
    666e:	00 97       	sbiw	r24, 0x00	; 0
    6670:	69 f7       	brne	.-38     	; 0x664c <LCD_write_data_4bit+0x742>
    6672:	24 c0       	rjmp	.+72     	; 0x66bc <LCD_write_data_4bit+0x7b2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6674:	68 85       	ldd	r22, Y+8	; 0x08
    6676:	79 85       	ldd	r23, Y+9	; 0x09
    6678:	8a 85       	ldd	r24, Y+10	; 0x0a
    667a:	9b 85       	ldd	r25, Y+11	; 0x0b
    667c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6680:	dc 01       	movw	r26, r24
    6682:	cb 01       	movw	r24, r22
    6684:	9f 83       	std	Y+7, r25	; 0x07
    6686:	8e 83       	std	Y+6, r24	; 0x06
    6688:	8e 81       	ldd	r24, Y+6	; 0x06
    668a:	9f 81       	ldd	r25, Y+7	; 0x07
    668c:	9b 83       	std	Y+3, r25	; 0x03
    668e:	8a 83       	std	Y+2, r24	; 0x02
    6690:	8a 81       	ldd	r24, Y+2	; 0x02
    6692:	9b 81       	ldd	r25, Y+3	; 0x03
    6694:	01 97       	sbiw	r24, 0x01	; 1
    6696:	f1 f7       	brne	.-4      	; 0x6694 <LCD_write_data_4bit+0x78a>
    6698:	9b 83       	std	Y+3, r25	; 0x03
    669a:	8a 83       	std	Y+2, r24	; 0x02
    669c:	0f c0       	rjmp	.+30     	; 0x66bc <LCD_write_data_4bit+0x7b2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    669e:	69 89       	ldd	r22, Y+17	; 0x11
    66a0:	7a 89       	ldd	r23, Y+18	; 0x12
    66a2:	8b 89       	ldd	r24, Y+19	; 0x13
    66a4:	9c 89       	ldd	r25, Y+20	; 0x14
    66a6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    66aa:	dc 01       	movw	r26, r24
    66ac:	cb 01       	movw	r24, r22
    66ae:	88 8b       	std	Y+16, r24	; 0x10
    66b0:	88 89       	ldd	r24, Y+16	; 0x10
    66b2:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    66b4:	89 81       	ldd	r24, Y+1	; 0x01
    66b6:	8a 95       	dec	r24
    66b8:	f1 f7       	brne	.-4      	; 0x66b6 <LCD_write_data_4bit+0x7ac>
    66ba:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	// Sent the Lower nipple
	for(u8 i= 4; i< 8; i++)
    66bc:	fe 01       	movw	r30, r28
    66be:	ef 59       	subi	r30, 0x9F	; 159
    66c0:	ff 4f       	sbci	r31, 0xFF	; 255
    66c2:	84 e0       	ldi	r24, 0x04	; 4
    66c4:	80 83       	st	Z, r24
    66c6:	27 c0       	rjmp	.+78     	; 0x6716 <LCD_write_data_4bit+0x80c>
		DIO_void_assign_pin(lcd_data_port, i, get_bit(lcd_copy_word_4bit, i-4));
    66c8:	fe 01       	movw	r30, r28
    66ca:	ed 59       	subi	r30, 0x9D	; 157
    66cc:	ff 4f       	sbci	r31, 0xFF	; 255
    66ce:	80 81       	ld	r24, Z
    66d0:	28 2f       	mov	r18, r24
    66d2:	30 e0       	ldi	r19, 0x00	; 0
    66d4:	fe 01       	movw	r30, r28
    66d6:	ef 59       	subi	r30, 0x9F	; 159
    66d8:	ff 4f       	sbci	r31, 0xFF	; 255
    66da:	80 81       	ld	r24, Z
    66dc:	88 2f       	mov	r24, r24
    66de:	90 e0       	ldi	r25, 0x00	; 0
    66e0:	04 97       	sbiw	r24, 0x04	; 4
    66e2:	f9 01       	movw	r30, r18
    66e4:	02 c0       	rjmp	.+4      	; 0x66ea <LCD_write_data_4bit+0x7e0>
    66e6:	f5 95       	asr	r31
    66e8:	e7 95       	ror	r30
    66ea:	8a 95       	dec	r24
    66ec:	e2 f7       	brpl	.-8      	; 0x66e6 <LCD_write_data_4bit+0x7dc>
    66ee:	cf 01       	movw	r24, r30
    66f0:	98 2f       	mov	r25, r24
    66f2:	91 70       	andi	r25, 0x01	; 1
    66f4:	fe 01       	movw	r30, r28
    66f6:	ef 59       	subi	r30, 0x9F	; 159
    66f8:	ff 4f       	sbci	r31, 0xFF	; 255
    66fa:	82 e0       	ldi	r24, 0x02	; 2
    66fc:	60 81       	ld	r22, Z
    66fe:	49 2f       	mov	r20, r25
    6700:	0e 94 6a 27 	call	0x4ed4	; 0x4ed4 <DIO_void_assign_pin>
	_delay_us(10);
	// Enable pin is high to send the Lower nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
	_delay_us(1);
	// Sent the Lower nipple
	for(u8 i= 4; i< 8; i++)
    6704:	de 01       	movw	r26, r28
    6706:	af 59       	subi	r26, 0x9F	; 159
    6708:	bf 4f       	sbci	r27, 0xFF	; 255
    670a:	fe 01       	movw	r30, r28
    670c:	ef 59       	subi	r30, 0x9F	; 159
    670e:	ff 4f       	sbci	r31, 0xFF	; 255
    6710:	80 81       	ld	r24, Z
    6712:	8f 5f       	subi	r24, 0xFF	; 255
    6714:	8c 93       	st	X, r24
    6716:	fe 01       	movw	r30, r28
    6718:	ef 59       	subi	r30, 0x9F	; 159
    671a:	ff 4f       	sbci	r31, 0xFF	; 255
    671c:	80 81       	ld	r24, Z
    671e:	88 30       	cpi	r24, 0x08	; 8
    6720:	98 f2       	brcs	.-90     	; 0x66c8 <LCD_write_data_4bit+0x7be>
		DIO_void_assign_pin(lcd_data_port, i, get_bit(lcd_copy_word_4bit, i-4));
	// Enable pin low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    6722:	82 e0       	ldi	r24, 0x02	; 2
    6724:	60 e0       	ldi	r22, 0x00	; 0
    6726:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
}
    672a:	cd 59       	subi	r28, 0x9D	; 157
    672c:	df 4f       	sbci	r29, 0xFF	; 255
    672e:	0f b6       	in	r0, 0x3f	; 63
    6730:	f8 94       	cli
    6732:	de bf       	out	0x3e, r29	; 62
    6734:	0f be       	out	0x3f, r0	; 63
    6736:	cd bf       	out	0x3d, r28	; 61
    6738:	cf 91       	pop	r28
    673a:	df 91       	pop	r29
    673c:	1f 91       	pop	r17
    673e:	0f 91       	pop	r16
    6740:	08 95       	ret

00006742 <LCD_write_cmd_4bit>:

void LCD_write_cmd_4bit(u8 lcd_copy_cmd_4bit){
    6742:	0f 93       	push	r16
    6744:	1f 93       	push	r17
    6746:	df 93       	push	r29
    6748:	cf 93       	push	r28
    674a:	cd b7       	in	r28, 0x3d	; 61
    674c:	de b7       	in	r29, 0x3e	; 62
    674e:	c3 56       	subi	r28, 0x63	; 99
    6750:	d0 40       	sbci	r29, 0x00	; 0
    6752:	0f b6       	in	r0, 0x3f	; 63
    6754:	f8 94       	cli
    6756:	de bf       	out	0x3e, r29	; 62
    6758:	0f be       	out	0x3f, r0	; 63
    675a:	cd bf       	out	0x3d, r28	; 61
    675c:	fe 01       	movw	r30, r28
    675e:	ed 59       	subi	r30, 0x9D	; 157
    6760:	ff 4f       	sbci	r31, 0xFF	; 255
    6762:	80 83       	st	Z, r24
	 *		lcd_copy_cmd_4bit>> The comand byte that needs to be sent to the LCD
	 *
	 *	Function does not return any  valus and it is helper and not allowed to be used out side of the driver.
	 */
	// Configure RS/RW pins to recive command
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RS);
    6764:	82 e0       	ldi	r24, 0x02	; 2
    6766:	62 e0       	ldi	r22, 0x02	; 2
    6768:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RW);
    676c:	82 e0       	ldi	r24, 0x02	; 2
    676e:	61 e0       	ldi	r22, 0x01	; 1
    6770:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    6774:	fe 01       	movw	r30, r28
    6776:	e3 5a       	subi	r30, 0xA3	; 163
    6778:	ff 4f       	sbci	r31, 0xFF	; 255
    677a:	80 e0       	ldi	r24, 0x00	; 0
    677c:	90 e0       	ldi	r25, 0x00	; 0
    677e:	a0 e8       	ldi	r26, 0x80	; 128
    6780:	bf e3       	ldi	r27, 0x3F	; 63
    6782:	80 83       	st	Z, r24
    6784:	91 83       	std	Z+1, r25	; 0x01
    6786:	a2 83       	std	Z+2, r26	; 0x02
    6788:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    678a:	8e 01       	movw	r16, r28
    678c:	07 5a       	subi	r16, 0xA7	; 167
    678e:	1f 4f       	sbci	r17, 0xFF	; 255
    6790:	fe 01       	movw	r30, r28
    6792:	e3 5a       	subi	r30, 0xA3	; 163
    6794:	ff 4f       	sbci	r31, 0xFF	; 255
    6796:	60 81       	ld	r22, Z
    6798:	71 81       	ldd	r23, Z+1	; 0x01
    679a:	82 81       	ldd	r24, Z+2	; 0x02
    679c:	93 81       	ldd	r25, Z+3	; 0x03
    679e:	2b ea       	ldi	r18, 0xAB	; 171
    67a0:	3a ea       	ldi	r19, 0xAA	; 170
    67a2:	4a ea       	ldi	r20, 0xAA	; 170
    67a4:	50 e4       	ldi	r21, 0x40	; 64
    67a6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    67aa:	dc 01       	movw	r26, r24
    67ac:	cb 01       	movw	r24, r22
    67ae:	f8 01       	movw	r30, r16
    67b0:	80 83       	st	Z, r24
    67b2:	91 83       	std	Z+1, r25	; 0x01
    67b4:	a2 83       	std	Z+2, r26	; 0x02
    67b6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    67b8:	fe 01       	movw	r30, r28
    67ba:	e7 5a       	subi	r30, 0xA7	; 167
    67bc:	ff 4f       	sbci	r31, 0xFF	; 255
    67be:	60 81       	ld	r22, Z
    67c0:	71 81       	ldd	r23, Z+1	; 0x01
    67c2:	82 81       	ldd	r24, Z+2	; 0x02
    67c4:	93 81       	ldd	r25, Z+3	; 0x03
    67c6:	20 e0       	ldi	r18, 0x00	; 0
    67c8:	30 e0       	ldi	r19, 0x00	; 0
    67ca:	40 e8       	ldi	r20, 0x80	; 128
    67cc:	5f e3       	ldi	r21, 0x3F	; 63
    67ce:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    67d2:	88 23       	and	r24, r24
    67d4:	34 f4       	brge	.+12     	; 0x67e2 <LCD_write_cmd_4bit+0xa0>
		__ticks = 1;
    67d6:	fe 01       	movw	r30, r28
    67d8:	e8 5a       	subi	r30, 0xA8	; 168
    67da:	ff 4f       	sbci	r31, 0xFF	; 255
    67dc:	81 e0       	ldi	r24, 0x01	; 1
    67de:	80 83       	st	Z, r24
    67e0:	e0 c0       	rjmp	.+448    	; 0x69a2 <LCD_write_cmd_4bit+0x260>
	else if (__tmp > 255)
    67e2:	fe 01       	movw	r30, r28
    67e4:	e7 5a       	subi	r30, 0xA7	; 167
    67e6:	ff 4f       	sbci	r31, 0xFF	; 255
    67e8:	60 81       	ld	r22, Z
    67ea:	71 81       	ldd	r23, Z+1	; 0x01
    67ec:	82 81       	ldd	r24, Z+2	; 0x02
    67ee:	93 81       	ldd	r25, Z+3	; 0x03
    67f0:	20 e0       	ldi	r18, 0x00	; 0
    67f2:	30 e0       	ldi	r19, 0x00	; 0
    67f4:	4f e7       	ldi	r20, 0x7F	; 127
    67f6:	53 e4       	ldi	r21, 0x43	; 67
    67f8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    67fc:	18 16       	cp	r1, r24
    67fe:	0c f0       	brlt	.+2      	; 0x6802 <LCD_write_cmd_4bit+0xc0>
    6800:	c0 c0       	rjmp	.+384    	; 0x6982 <LCD_write_cmd_4bit+0x240>
	{
		_delay_ms(__us / 1000.0);
    6802:	fe 01       	movw	r30, r28
    6804:	e3 5a       	subi	r30, 0xA3	; 163
    6806:	ff 4f       	sbci	r31, 0xFF	; 255
    6808:	60 81       	ld	r22, Z
    680a:	71 81       	ldd	r23, Z+1	; 0x01
    680c:	82 81       	ldd	r24, Z+2	; 0x02
    680e:	93 81       	ldd	r25, Z+3	; 0x03
    6810:	20 e0       	ldi	r18, 0x00	; 0
    6812:	30 e0       	ldi	r19, 0x00	; 0
    6814:	4a e7       	ldi	r20, 0x7A	; 122
    6816:	54 e4       	ldi	r21, 0x44	; 68
    6818:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    681c:	dc 01       	movw	r26, r24
    681e:	cb 01       	movw	r24, r22
    6820:	fe 01       	movw	r30, r28
    6822:	ec 5a       	subi	r30, 0xAC	; 172
    6824:	ff 4f       	sbci	r31, 0xFF	; 255
    6826:	80 83       	st	Z, r24
    6828:	91 83       	std	Z+1, r25	; 0x01
    682a:	a2 83       	std	Z+2, r26	; 0x02
    682c:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    682e:	8e 01       	movw	r16, r28
    6830:	00 5b       	subi	r16, 0xB0	; 176
    6832:	1f 4f       	sbci	r17, 0xFF	; 255
    6834:	fe 01       	movw	r30, r28
    6836:	ec 5a       	subi	r30, 0xAC	; 172
    6838:	ff 4f       	sbci	r31, 0xFF	; 255
    683a:	60 81       	ld	r22, Z
    683c:	71 81       	ldd	r23, Z+1	; 0x01
    683e:	82 81       	ldd	r24, Z+2	; 0x02
    6840:	93 81       	ldd	r25, Z+3	; 0x03
    6842:	20 e0       	ldi	r18, 0x00	; 0
    6844:	30 e0       	ldi	r19, 0x00	; 0
    6846:	4a e7       	ldi	r20, 0x7A	; 122
    6848:	55 e4       	ldi	r21, 0x45	; 69
    684a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    684e:	dc 01       	movw	r26, r24
    6850:	cb 01       	movw	r24, r22
    6852:	f8 01       	movw	r30, r16
    6854:	80 83       	st	Z, r24
    6856:	91 83       	std	Z+1, r25	; 0x01
    6858:	a2 83       	std	Z+2, r26	; 0x02
    685a:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    685c:	fe 01       	movw	r30, r28
    685e:	e0 5b       	subi	r30, 0xB0	; 176
    6860:	ff 4f       	sbci	r31, 0xFF	; 255
    6862:	60 81       	ld	r22, Z
    6864:	71 81       	ldd	r23, Z+1	; 0x01
    6866:	82 81       	ldd	r24, Z+2	; 0x02
    6868:	93 81       	ldd	r25, Z+3	; 0x03
    686a:	20 e0       	ldi	r18, 0x00	; 0
    686c:	30 e0       	ldi	r19, 0x00	; 0
    686e:	40 e8       	ldi	r20, 0x80	; 128
    6870:	5f e3       	ldi	r21, 0x3F	; 63
    6872:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6876:	88 23       	and	r24, r24
    6878:	44 f4       	brge	.+16     	; 0x688a <LCD_write_cmd_4bit+0x148>
		__ticks = 1;
    687a:	fe 01       	movw	r30, r28
    687c:	e2 5b       	subi	r30, 0xB2	; 178
    687e:	ff 4f       	sbci	r31, 0xFF	; 255
    6880:	81 e0       	ldi	r24, 0x01	; 1
    6882:	90 e0       	ldi	r25, 0x00	; 0
    6884:	91 83       	std	Z+1, r25	; 0x01
    6886:	80 83       	st	Z, r24
    6888:	64 c0       	rjmp	.+200    	; 0x6952 <LCD_write_cmd_4bit+0x210>
	else if (__tmp > 65535)
    688a:	fe 01       	movw	r30, r28
    688c:	e0 5b       	subi	r30, 0xB0	; 176
    688e:	ff 4f       	sbci	r31, 0xFF	; 255
    6890:	60 81       	ld	r22, Z
    6892:	71 81       	ldd	r23, Z+1	; 0x01
    6894:	82 81       	ldd	r24, Z+2	; 0x02
    6896:	93 81       	ldd	r25, Z+3	; 0x03
    6898:	20 e0       	ldi	r18, 0x00	; 0
    689a:	3f ef       	ldi	r19, 0xFF	; 255
    689c:	4f e7       	ldi	r20, 0x7F	; 127
    689e:	57 e4       	ldi	r21, 0x47	; 71
    68a0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    68a4:	18 16       	cp	r1, r24
    68a6:	0c f0       	brlt	.+2      	; 0x68aa <LCD_write_cmd_4bit+0x168>
    68a8:	43 c0       	rjmp	.+134    	; 0x6930 <LCD_write_cmd_4bit+0x1ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    68aa:	fe 01       	movw	r30, r28
    68ac:	ec 5a       	subi	r30, 0xAC	; 172
    68ae:	ff 4f       	sbci	r31, 0xFF	; 255
    68b0:	60 81       	ld	r22, Z
    68b2:	71 81       	ldd	r23, Z+1	; 0x01
    68b4:	82 81       	ldd	r24, Z+2	; 0x02
    68b6:	93 81       	ldd	r25, Z+3	; 0x03
    68b8:	20 e0       	ldi	r18, 0x00	; 0
    68ba:	30 e0       	ldi	r19, 0x00	; 0
    68bc:	40 e2       	ldi	r20, 0x20	; 32
    68be:	51 e4       	ldi	r21, 0x41	; 65
    68c0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    68c4:	dc 01       	movw	r26, r24
    68c6:	cb 01       	movw	r24, r22
    68c8:	8e 01       	movw	r16, r28
    68ca:	02 5b       	subi	r16, 0xB2	; 178
    68cc:	1f 4f       	sbci	r17, 0xFF	; 255
    68ce:	bc 01       	movw	r22, r24
    68d0:	cd 01       	movw	r24, r26
    68d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    68d6:	dc 01       	movw	r26, r24
    68d8:	cb 01       	movw	r24, r22
    68da:	f8 01       	movw	r30, r16
    68dc:	91 83       	std	Z+1, r25	; 0x01
    68de:	80 83       	st	Z, r24
    68e0:	1f c0       	rjmp	.+62     	; 0x6920 <LCD_write_cmd_4bit+0x1de>
    68e2:	fe 01       	movw	r30, r28
    68e4:	e4 5b       	subi	r30, 0xB4	; 180
    68e6:	ff 4f       	sbci	r31, 0xFF	; 255
    68e8:	80 e9       	ldi	r24, 0x90	; 144
    68ea:	91 e0       	ldi	r25, 0x01	; 1
    68ec:	91 83       	std	Z+1, r25	; 0x01
    68ee:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    68f0:	fe 01       	movw	r30, r28
    68f2:	e4 5b       	subi	r30, 0xB4	; 180
    68f4:	ff 4f       	sbci	r31, 0xFF	; 255
    68f6:	80 81       	ld	r24, Z
    68f8:	91 81       	ldd	r25, Z+1	; 0x01
    68fa:	01 97       	sbiw	r24, 0x01	; 1
    68fc:	f1 f7       	brne	.-4      	; 0x68fa <LCD_write_cmd_4bit+0x1b8>
    68fe:	fe 01       	movw	r30, r28
    6900:	e4 5b       	subi	r30, 0xB4	; 180
    6902:	ff 4f       	sbci	r31, 0xFF	; 255
    6904:	91 83       	std	Z+1, r25	; 0x01
    6906:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6908:	de 01       	movw	r26, r28
    690a:	a2 5b       	subi	r26, 0xB2	; 178
    690c:	bf 4f       	sbci	r27, 0xFF	; 255
    690e:	fe 01       	movw	r30, r28
    6910:	e2 5b       	subi	r30, 0xB2	; 178
    6912:	ff 4f       	sbci	r31, 0xFF	; 255
    6914:	80 81       	ld	r24, Z
    6916:	91 81       	ldd	r25, Z+1	; 0x01
    6918:	01 97       	sbiw	r24, 0x01	; 1
    691a:	11 96       	adiw	r26, 0x01	; 1
    691c:	9c 93       	st	X, r25
    691e:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6920:	fe 01       	movw	r30, r28
    6922:	e2 5b       	subi	r30, 0xB2	; 178
    6924:	ff 4f       	sbci	r31, 0xFF	; 255
    6926:	80 81       	ld	r24, Z
    6928:	91 81       	ldd	r25, Z+1	; 0x01
    692a:	00 97       	sbiw	r24, 0x00	; 0
    692c:	d1 f6       	brne	.-76     	; 0x68e2 <LCD_write_cmd_4bit+0x1a0>
    692e:	4b c0       	rjmp	.+150    	; 0x69c6 <LCD_write_cmd_4bit+0x284>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6930:	8e 01       	movw	r16, r28
    6932:	02 5b       	subi	r16, 0xB2	; 178
    6934:	1f 4f       	sbci	r17, 0xFF	; 255
    6936:	fe 01       	movw	r30, r28
    6938:	e0 5b       	subi	r30, 0xB0	; 176
    693a:	ff 4f       	sbci	r31, 0xFF	; 255
    693c:	60 81       	ld	r22, Z
    693e:	71 81       	ldd	r23, Z+1	; 0x01
    6940:	82 81       	ldd	r24, Z+2	; 0x02
    6942:	93 81       	ldd	r25, Z+3	; 0x03
    6944:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6948:	dc 01       	movw	r26, r24
    694a:	cb 01       	movw	r24, r22
    694c:	f8 01       	movw	r30, r16
    694e:	91 83       	std	Z+1, r25	; 0x01
    6950:	80 83       	st	Z, r24
    6952:	de 01       	movw	r26, r28
    6954:	a6 5b       	subi	r26, 0xB6	; 182
    6956:	bf 4f       	sbci	r27, 0xFF	; 255
    6958:	fe 01       	movw	r30, r28
    695a:	e2 5b       	subi	r30, 0xB2	; 178
    695c:	ff 4f       	sbci	r31, 0xFF	; 255
    695e:	80 81       	ld	r24, Z
    6960:	91 81       	ldd	r25, Z+1	; 0x01
    6962:	11 96       	adiw	r26, 0x01	; 1
    6964:	9c 93       	st	X, r25
    6966:	8e 93       	st	-X, r24
    6968:	fe 01       	movw	r30, r28
    696a:	e6 5b       	subi	r30, 0xB6	; 182
    696c:	ff 4f       	sbci	r31, 0xFF	; 255
    696e:	80 81       	ld	r24, Z
    6970:	91 81       	ldd	r25, Z+1	; 0x01
    6972:	01 97       	sbiw	r24, 0x01	; 1
    6974:	f1 f7       	brne	.-4      	; 0x6972 <LCD_write_cmd_4bit+0x230>
    6976:	fe 01       	movw	r30, r28
    6978:	e6 5b       	subi	r30, 0xB6	; 182
    697a:	ff 4f       	sbci	r31, 0xFF	; 255
    697c:	91 83       	std	Z+1, r25	; 0x01
    697e:	80 83       	st	Z, r24
    6980:	22 c0       	rjmp	.+68     	; 0x69c6 <LCD_write_cmd_4bit+0x284>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6982:	8e 01       	movw	r16, r28
    6984:	08 5a       	subi	r16, 0xA8	; 168
    6986:	1f 4f       	sbci	r17, 0xFF	; 255
    6988:	fe 01       	movw	r30, r28
    698a:	e7 5a       	subi	r30, 0xA7	; 167
    698c:	ff 4f       	sbci	r31, 0xFF	; 255
    698e:	60 81       	ld	r22, Z
    6990:	71 81       	ldd	r23, Z+1	; 0x01
    6992:	82 81       	ldd	r24, Z+2	; 0x02
    6994:	93 81       	ldd	r25, Z+3	; 0x03
    6996:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    699a:	dc 01       	movw	r26, r24
    699c:	cb 01       	movw	r24, r22
    699e:	f8 01       	movw	r30, r16
    69a0:	80 83       	st	Z, r24
    69a2:	de 01       	movw	r26, r28
    69a4:	a7 5b       	subi	r26, 0xB7	; 183
    69a6:	bf 4f       	sbci	r27, 0xFF	; 255
    69a8:	fe 01       	movw	r30, r28
    69aa:	e8 5a       	subi	r30, 0xA8	; 168
    69ac:	ff 4f       	sbci	r31, 0xFF	; 255
    69ae:	80 81       	ld	r24, Z
    69b0:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    69b2:	fe 01       	movw	r30, r28
    69b4:	e7 5b       	subi	r30, 0xB7	; 183
    69b6:	ff 4f       	sbci	r31, 0xFF	; 255
    69b8:	80 81       	ld	r24, Z
    69ba:	8a 95       	dec	r24
    69bc:	f1 f7       	brne	.-4      	; 0x69ba <LCD_write_cmd_4bit+0x278>
    69be:	fe 01       	movw	r30, r28
    69c0:	e7 5b       	subi	r30, 0xB7	; 183
    69c2:	ff 4f       	sbci	r31, 0xFF	; 255
    69c4:	80 83       	st	Z, r24
	_delay_us(1);
	// Enable pin is high to send the higher nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    69c6:	82 e0       	ldi	r24, 0x02	; 2
    69c8:	60 e0       	ldi	r22, 0x00	; 0
    69ca:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    69ce:	fe 01       	movw	r30, r28
    69d0:	eb 5b       	subi	r30, 0xBB	; 187
    69d2:	ff 4f       	sbci	r31, 0xFF	; 255
    69d4:	80 e0       	ldi	r24, 0x00	; 0
    69d6:	90 e0       	ldi	r25, 0x00	; 0
    69d8:	a0 e8       	ldi	r26, 0x80	; 128
    69da:	bf e3       	ldi	r27, 0x3F	; 63
    69dc:	80 83       	st	Z, r24
    69de:	91 83       	std	Z+1, r25	; 0x01
    69e0:	a2 83       	std	Z+2, r26	; 0x02
    69e2:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    69e4:	8e 01       	movw	r16, r28
    69e6:	0f 5b       	subi	r16, 0xBF	; 191
    69e8:	1f 4f       	sbci	r17, 0xFF	; 255
    69ea:	fe 01       	movw	r30, r28
    69ec:	eb 5b       	subi	r30, 0xBB	; 187
    69ee:	ff 4f       	sbci	r31, 0xFF	; 255
    69f0:	60 81       	ld	r22, Z
    69f2:	71 81       	ldd	r23, Z+1	; 0x01
    69f4:	82 81       	ldd	r24, Z+2	; 0x02
    69f6:	93 81       	ldd	r25, Z+3	; 0x03
    69f8:	2b ea       	ldi	r18, 0xAB	; 171
    69fa:	3a ea       	ldi	r19, 0xAA	; 170
    69fc:	4a ea       	ldi	r20, 0xAA	; 170
    69fe:	50 e4       	ldi	r21, 0x40	; 64
    6a00:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6a04:	dc 01       	movw	r26, r24
    6a06:	cb 01       	movw	r24, r22
    6a08:	f8 01       	movw	r30, r16
    6a0a:	80 83       	st	Z, r24
    6a0c:	91 83       	std	Z+1, r25	; 0x01
    6a0e:	a2 83       	std	Z+2, r26	; 0x02
    6a10:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    6a12:	fe 01       	movw	r30, r28
    6a14:	ef 5b       	subi	r30, 0xBF	; 191
    6a16:	ff 4f       	sbci	r31, 0xFF	; 255
    6a18:	60 81       	ld	r22, Z
    6a1a:	71 81       	ldd	r23, Z+1	; 0x01
    6a1c:	82 81       	ldd	r24, Z+2	; 0x02
    6a1e:	93 81       	ldd	r25, Z+3	; 0x03
    6a20:	20 e0       	ldi	r18, 0x00	; 0
    6a22:	30 e0       	ldi	r19, 0x00	; 0
    6a24:	40 e8       	ldi	r20, 0x80	; 128
    6a26:	5f e3       	ldi	r21, 0x3F	; 63
    6a28:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6a2c:	88 23       	and	r24, r24
    6a2e:	34 f4       	brge	.+12     	; 0x6a3c <LCD_write_cmd_4bit+0x2fa>
		__ticks = 1;
    6a30:	81 e0       	ldi	r24, 0x01	; 1
    6a32:	fe 01       	movw	r30, r28
    6a34:	e0 5c       	subi	r30, 0xC0	; 192
    6a36:	ff 4f       	sbci	r31, 0xFF	; 255
    6a38:	80 83       	st	Z, r24
    6a3a:	9d c0       	rjmp	.+314    	; 0x6b76 <LCD_write_cmd_4bit+0x434>
	else if (__tmp > 255)
    6a3c:	fe 01       	movw	r30, r28
    6a3e:	ef 5b       	subi	r30, 0xBF	; 191
    6a40:	ff 4f       	sbci	r31, 0xFF	; 255
    6a42:	60 81       	ld	r22, Z
    6a44:	71 81       	ldd	r23, Z+1	; 0x01
    6a46:	82 81       	ldd	r24, Z+2	; 0x02
    6a48:	93 81       	ldd	r25, Z+3	; 0x03
    6a4a:	20 e0       	ldi	r18, 0x00	; 0
    6a4c:	30 e0       	ldi	r19, 0x00	; 0
    6a4e:	4f e7       	ldi	r20, 0x7F	; 127
    6a50:	53 e4       	ldi	r21, 0x43	; 67
    6a52:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6a56:	18 16       	cp	r1, r24
    6a58:	0c f0       	brlt	.+2      	; 0x6a5c <LCD_write_cmd_4bit+0x31a>
    6a5a:	7e c0       	rjmp	.+252    	; 0x6b58 <LCD_write_cmd_4bit+0x416>
	{
		_delay_ms(__us / 1000.0);
    6a5c:	fe 01       	movw	r30, r28
    6a5e:	eb 5b       	subi	r30, 0xBB	; 187
    6a60:	ff 4f       	sbci	r31, 0xFF	; 255
    6a62:	60 81       	ld	r22, Z
    6a64:	71 81       	ldd	r23, Z+1	; 0x01
    6a66:	82 81       	ldd	r24, Z+2	; 0x02
    6a68:	93 81       	ldd	r25, Z+3	; 0x03
    6a6a:	20 e0       	ldi	r18, 0x00	; 0
    6a6c:	30 e0       	ldi	r19, 0x00	; 0
    6a6e:	4a e7       	ldi	r20, 0x7A	; 122
    6a70:	54 e4       	ldi	r21, 0x44	; 68
    6a72:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6a76:	dc 01       	movw	r26, r24
    6a78:	cb 01       	movw	r24, r22
    6a7a:	8c af       	std	Y+60, r24	; 0x3c
    6a7c:	9d af       	std	Y+61, r25	; 0x3d
    6a7e:	ae af       	std	Y+62, r26	; 0x3e
    6a80:	bf af       	std	Y+63, r27	; 0x3f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6a82:	6c ad       	ldd	r22, Y+60	; 0x3c
    6a84:	7d ad       	ldd	r23, Y+61	; 0x3d
    6a86:	8e ad       	ldd	r24, Y+62	; 0x3e
    6a88:	9f ad       	ldd	r25, Y+63	; 0x3f
    6a8a:	20 e0       	ldi	r18, 0x00	; 0
    6a8c:	30 e0       	ldi	r19, 0x00	; 0
    6a8e:	4a e7       	ldi	r20, 0x7A	; 122
    6a90:	55 e4       	ldi	r21, 0x45	; 69
    6a92:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6a96:	dc 01       	movw	r26, r24
    6a98:	cb 01       	movw	r24, r22
    6a9a:	88 af       	std	Y+56, r24	; 0x38
    6a9c:	99 af       	std	Y+57, r25	; 0x39
    6a9e:	aa af       	std	Y+58, r26	; 0x3a
    6aa0:	bb af       	std	Y+59, r27	; 0x3b
	if (__tmp < 1.0)
    6aa2:	68 ad       	ldd	r22, Y+56	; 0x38
    6aa4:	79 ad       	ldd	r23, Y+57	; 0x39
    6aa6:	8a ad       	ldd	r24, Y+58	; 0x3a
    6aa8:	9b ad       	ldd	r25, Y+59	; 0x3b
    6aaa:	20 e0       	ldi	r18, 0x00	; 0
    6aac:	30 e0       	ldi	r19, 0x00	; 0
    6aae:	40 e8       	ldi	r20, 0x80	; 128
    6ab0:	5f e3       	ldi	r21, 0x3F	; 63
    6ab2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6ab6:	88 23       	and	r24, r24
    6ab8:	2c f4       	brge	.+10     	; 0x6ac4 <LCD_write_cmd_4bit+0x382>
		__ticks = 1;
    6aba:	81 e0       	ldi	r24, 0x01	; 1
    6abc:	90 e0       	ldi	r25, 0x00	; 0
    6abe:	9f ab       	std	Y+55, r25	; 0x37
    6ac0:	8e ab       	std	Y+54, r24	; 0x36
    6ac2:	3f c0       	rjmp	.+126    	; 0x6b42 <LCD_write_cmd_4bit+0x400>
	else if (__tmp > 65535)
    6ac4:	68 ad       	ldd	r22, Y+56	; 0x38
    6ac6:	79 ad       	ldd	r23, Y+57	; 0x39
    6ac8:	8a ad       	ldd	r24, Y+58	; 0x3a
    6aca:	9b ad       	ldd	r25, Y+59	; 0x3b
    6acc:	20 e0       	ldi	r18, 0x00	; 0
    6ace:	3f ef       	ldi	r19, 0xFF	; 255
    6ad0:	4f e7       	ldi	r20, 0x7F	; 127
    6ad2:	57 e4       	ldi	r21, 0x47	; 71
    6ad4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6ad8:	18 16       	cp	r1, r24
    6ada:	4c f5       	brge	.+82     	; 0x6b2e <LCD_write_cmd_4bit+0x3ec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6adc:	6c ad       	ldd	r22, Y+60	; 0x3c
    6ade:	7d ad       	ldd	r23, Y+61	; 0x3d
    6ae0:	8e ad       	ldd	r24, Y+62	; 0x3e
    6ae2:	9f ad       	ldd	r25, Y+63	; 0x3f
    6ae4:	20 e0       	ldi	r18, 0x00	; 0
    6ae6:	30 e0       	ldi	r19, 0x00	; 0
    6ae8:	40 e2       	ldi	r20, 0x20	; 32
    6aea:	51 e4       	ldi	r21, 0x41	; 65
    6aec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6af0:	dc 01       	movw	r26, r24
    6af2:	cb 01       	movw	r24, r22
    6af4:	bc 01       	movw	r22, r24
    6af6:	cd 01       	movw	r24, r26
    6af8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6afc:	dc 01       	movw	r26, r24
    6afe:	cb 01       	movw	r24, r22
    6b00:	9f ab       	std	Y+55, r25	; 0x37
    6b02:	8e ab       	std	Y+54, r24	; 0x36
    6b04:	0f c0       	rjmp	.+30     	; 0x6b24 <LCD_write_cmd_4bit+0x3e2>
    6b06:	80 e9       	ldi	r24, 0x90	; 144
    6b08:	91 e0       	ldi	r25, 0x01	; 1
    6b0a:	9d ab       	std	Y+53, r25	; 0x35
    6b0c:	8c ab       	std	Y+52, r24	; 0x34
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6b0e:	8c a9       	ldd	r24, Y+52	; 0x34
    6b10:	9d a9       	ldd	r25, Y+53	; 0x35
    6b12:	01 97       	sbiw	r24, 0x01	; 1
    6b14:	f1 f7       	brne	.-4      	; 0x6b12 <LCD_write_cmd_4bit+0x3d0>
    6b16:	9d ab       	std	Y+53, r25	; 0x35
    6b18:	8c ab       	std	Y+52, r24	; 0x34
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6b1a:	8e a9       	ldd	r24, Y+54	; 0x36
    6b1c:	9f a9       	ldd	r25, Y+55	; 0x37
    6b1e:	01 97       	sbiw	r24, 0x01	; 1
    6b20:	9f ab       	std	Y+55, r25	; 0x37
    6b22:	8e ab       	std	Y+54, r24	; 0x36
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6b24:	8e a9       	ldd	r24, Y+54	; 0x36
    6b26:	9f a9       	ldd	r25, Y+55	; 0x37
    6b28:	00 97       	sbiw	r24, 0x00	; 0
    6b2a:	69 f7       	brne	.-38     	; 0x6b06 <LCD_write_cmd_4bit+0x3c4>
    6b2c:	2d c0       	rjmp	.+90     	; 0x6b88 <LCD_write_cmd_4bit+0x446>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6b2e:	68 ad       	ldd	r22, Y+56	; 0x38
    6b30:	79 ad       	ldd	r23, Y+57	; 0x39
    6b32:	8a ad       	ldd	r24, Y+58	; 0x3a
    6b34:	9b ad       	ldd	r25, Y+59	; 0x3b
    6b36:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6b3a:	dc 01       	movw	r26, r24
    6b3c:	cb 01       	movw	r24, r22
    6b3e:	9f ab       	std	Y+55, r25	; 0x37
    6b40:	8e ab       	std	Y+54, r24	; 0x36
    6b42:	8e a9       	ldd	r24, Y+54	; 0x36
    6b44:	9f a9       	ldd	r25, Y+55	; 0x37
    6b46:	9b ab       	std	Y+51, r25	; 0x33
    6b48:	8a ab       	std	Y+50, r24	; 0x32
    6b4a:	8a a9       	ldd	r24, Y+50	; 0x32
    6b4c:	9b a9       	ldd	r25, Y+51	; 0x33
    6b4e:	01 97       	sbiw	r24, 0x01	; 1
    6b50:	f1 f7       	brne	.-4      	; 0x6b4e <LCD_write_cmd_4bit+0x40c>
    6b52:	9b ab       	std	Y+51, r25	; 0x33
    6b54:	8a ab       	std	Y+50, r24	; 0x32
    6b56:	18 c0       	rjmp	.+48     	; 0x6b88 <LCD_write_cmd_4bit+0x446>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6b58:	fe 01       	movw	r30, r28
    6b5a:	ef 5b       	subi	r30, 0xBF	; 191
    6b5c:	ff 4f       	sbci	r31, 0xFF	; 255
    6b5e:	60 81       	ld	r22, Z
    6b60:	71 81       	ldd	r23, Z+1	; 0x01
    6b62:	82 81       	ldd	r24, Z+2	; 0x02
    6b64:	93 81       	ldd	r25, Z+3	; 0x03
    6b66:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6b6a:	dc 01       	movw	r26, r24
    6b6c:	cb 01       	movw	r24, r22
    6b6e:	fe 01       	movw	r30, r28
    6b70:	e0 5c       	subi	r30, 0xC0	; 192
    6b72:	ff 4f       	sbci	r31, 0xFF	; 255
    6b74:	80 83       	st	Z, r24
    6b76:	fe 01       	movw	r30, r28
    6b78:	e0 5c       	subi	r30, 0xC0	; 192
    6b7a:	ff 4f       	sbci	r31, 0xFF	; 255
    6b7c:	80 81       	ld	r24, Z
    6b7e:	89 ab       	std	Y+49, r24	; 0x31
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6b80:	89 a9       	ldd	r24, Y+49	; 0x31
    6b82:	8a 95       	dec	r24
    6b84:	f1 f7       	brne	.-4      	; 0x6b82 <LCD_write_cmd_4bit+0x440>
    6b86:	89 ab       	std	Y+49, r24	; 0x31
	_delay_us(1);
	// Sent the higher nipple
	for(u8 i= 4; i< 8; i++)
    6b88:	fe 01       	movw	r30, r28
    6b8a:	ee 59       	subi	r30, 0x9E	; 158
    6b8c:	ff 4f       	sbci	r31, 0xFF	; 255
    6b8e:	84 e0       	ldi	r24, 0x04	; 4
    6b90:	80 83       	st	Z, r24
    6b92:	26 c0       	rjmp	.+76     	; 0x6be0 <LCD_write_cmd_4bit+0x49e>
		DIO_void_assign_pin(lcd_data_port, i, get_bit(lcd_copy_cmd_4bit, i));
    6b94:	fe 01       	movw	r30, r28
    6b96:	ed 59       	subi	r30, 0x9D	; 157
    6b98:	ff 4f       	sbci	r31, 0xFF	; 255
    6b9a:	80 81       	ld	r24, Z
    6b9c:	28 2f       	mov	r18, r24
    6b9e:	30 e0       	ldi	r19, 0x00	; 0
    6ba0:	fe 01       	movw	r30, r28
    6ba2:	ee 59       	subi	r30, 0x9E	; 158
    6ba4:	ff 4f       	sbci	r31, 0xFF	; 255
    6ba6:	80 81       	ld	r24, Z
    6ba8:	88 2f       	mov	r24, r24
    6baa:	90 e0       	ldi	r25, 0x00	; 0
    6bac:	a9 01       	movw	r20, r18
    6bae:	02 c0       	rjmp	.+4      	; 0x6bb4 <LCD_write_cmd_4bit+0x472>
    6bb0:	55 95       	asr	r21
    6bb2:	47 95       	ror	r20
    6bb4:	8a 95       	dec	r24
    6bb6:	e2 f7       	brpl	.-8      	; 0x6bb0 <LCD_write_cmd_4bit+0x46e>
    6bb8:	ca 01       	movw	r24, r20
    6bba:	98 2f       	mov	r25, r24
    6bbc:	91 70       	andi	r25, 0x01	; 1
    6bbe:	fe 01       	movw	r30, r28
    6bc0:	ee 59       	subi	r30, 0x9E	; 158
    6bc2:	ff 4f       	sbci	r31, 0xFF	; 255
    6bc4:	82 e0       	ldi	r24, 0x02	; 2
    6bc6:	60 81       	ld	r22, Z
    6bc8:	49 2f       	mov	r20, r25
    6bca:	0e 94 6a 27 	call	0x4ed4	; 0x4ed4 <DIO_void_assign_pin>
	_delay_us(1);
	// Enable pin is high to send the higher nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
	_delay_us(1);
	// Sent the higher nipple
	for(u8 i= 4; i< 8; i++)
    6bce:	de 01       	movw	r26, r28
    6bd0:	ae 59       	subi	r26, 0x9E	; 158
    6bd2:	bf 4f       	sbci	r27, 0xFF	; 255
    6bd4:	fe 01       	movw	r30, r28
    6bd6:	ee 59       	subi	r30, 0x9E	; 158
    6bd8:	ff 4f       	sbci	r31, 0xFF	; 255
    6bda:	80 81       	ld	r24, Z
    6bdc:	8f 5f       	subi	r24, 0xFF	; 255
    6bde:	8c 93       	st	X, r24
    6be0:	fe 01       	movw	r30, r28
    6be2:	ee 59       	subi	r30, 0x9E	; 158
    6be4:	ff 4f       	sbci	r31, 0xFF	; 255
    6be6:	80 81       	ld	r24, Z
    6be8:	88 30       	cpi	r24, 0x08	; 8
    6bea:	a0 f2       	brcs	.-88     	; 0x6b94 <LCD_write_cmd_4bit+0x452>
		DIO_void_assign_pin(lcd_data_port, i, get_bit(lcd_copy_cmd_4bit, i));
	// Enable pin low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    6bec:	82 e0       	ldi	r24, 0x02	; 2
    6bee:	60 e0       	ldi	r22, 0x00	; 0
    6bf0:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    6bf4:	80 e0       	ldi	r24, 0x00	; 0
    6bf6:	90 e0       	ldi	r25, 0x00	; 0
    6bf8:	a0 e2       	ldi	r26, 0x20	; 32
    6bfa:	b1 e4       	ldi	r27, 0x41	; 65
    6bfc:	8d a7       	std	Y+45, r24	; 0x2d
    6bfe:	9e a7       	std	Y+46, r25	; 0x2e
    6c00:	af a7       	std	Y+47, r26	; 0x2f
    6c02:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    6c04:	6d a5       	ldd	r22, Y+45	; 0x2d
    6c06:	7e a5       	ldd	r23, Y+46	; 0x2e
    6c08:	8f a5       	ldd	r24, Y+47	; 0x2f
    6c0a:	98 a9       	ldd	r25, Y+48	; 0x30
    6c0c:	2b ea       	ldi	r18, 0xAB	; 171
    6c0e:	3a ea       	ldi	r19, 0xAA	; 170
    6c10:	4a ea       	ldi	r20, 0xAA	; 170
    6c12:	50 e4       	ldi	r21, 0x40	; 64
    6c14:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6c18:	dc 01       	movw	r26, r24
    6c1a:	cb 01       	movw	r24, r22
    6c1c:	89 a7       	std	Y+41, r24	; 0x29
    6c1e:	9a a7       	std	Y+42, r25	; 0x2a
    6c20:	ab a7       	std	Y+43, r26	; 0x2b
    6c22:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    6c24:	69 a5       	ldd	r22, Y+41	; 0x29
    6c26:	7a a5       	ldd	r23, Y+42	; 0x2a
    6c28:	8b a5       	ldd	r24, Y+43	; 0x2b
    6c2a:	9c a5       	ldd	r25, Y+44	; 0x2c
    6c2c:	20 e0       	ldi	r18, 0x00	; 0
    6c2e:	30 e0       	ldi	r19, 0x00	; 0
    6c30:	40 e8       	ldi	r20, 0x80	; 128
    6c32:	5f e3       	ldi	r21, 0x3F	; 63
    6c34:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6c38:	88 23       	and	r24, r24
    6c3a:	1c f4       	brge	.+6      	; 0x6c42 <LCD_write_cmd_4bit+0x500>
		__ticks = 1;
    6c3c:	81 e0       	ldi	r24, 0x01	; 1
    6c3e:	88 a7       	std	Y+40, r24	; 0x28
    6c40:	91 c0       	rjmp	.+290    	; 0x6d64 <LCD_write_cmd_4bit+0x622>
	else if (__tmp > 255)
    6c42:	69 a5       	ldd	r22, Y+41	; 0x29
    6c44:	7a a5       	ldd	r23, Y+42	; 0x2a
    6c46:	8b a5       	ldd	r24, Y+43	; 0x2b
    6c48:	9c a5       	ldd	r25, Y+44	; 0x2c
    6c4a:	20 e0       	ldi	r18, 0x00	; 0
    6c4c:	30 e0       	ldi	r19, 0x00	; 0
    6c4e:	4f e7       	ldi	r20, 0x7F	; 127
    6c50:	53 e4       	ldi	r21, 0x43	; 67
    6c52:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6c56:	18 16       	cp	r1, r24
    6c58:	0c f0       	brlt	.+2      	; 0x6c5c <LCD_write_cmd_4bit+0x51a>
    6c5a:	7b c0       	rjmp	.+246    	; 0x6d52 <LCD_write_cmd_4bit+0x610>
	{
		_delay_ms(__us / 1000.0);
    6c5c:	6d a5       	ldd	r22, Y+45	; 0x2d
    6c5e:	7e a5       	ldd	r23, Y+46	; 0x2e
    6c60:	8f a5       	ldd	r24, Y+47	; 0x2f
    6c62:	98 a9       	ldd	r25, Y+48	; 0x30
    6c64:	20 e0       	ldi	r18, 0x00	; 0
    6c66:	30 e0       	ldi	r19, 0x00	; 0
    6c68:	4a e7       	ldi	r20, 0x7A	; 122
    6c6a:	54 e4       	ldi	r21, 0x44	; 68
    6c6c:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6c70:	dc 01       	movw	r26, r24
    6c72:	cb 01       	movw	r24, r22
    6c74:	8c a3       	std	Y+36, r24	; 0x24
    6c76:	9d a3       	std	Y+37, r25	; 0x25
    6c78:	ae a3       	std	Y+38, r26	; 0x26
    6c7a:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6c7c:	6c a1       	ldd	r22, Y+36	; 0x24
    6c7e:	7d a1       	ldd	r23, Y+37	; 0x25
    6c80:	8e a1       	ldd	r24, Y+38	; 0x26
    6c82:	9f a1       	ldd	r25, Y+39	; 0x27
    6c84:	20 e0       	ldi	r18, 0x00	; 0
    6c86:	30 e0       	ldi	r19, 0x00	; 0
    6c88:	4a e7       	ldi	r20, 0x7A	; 122
    6c8a:	55 e4       	ldi	r21, 0x45	; 69
    6c8c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6c90:	dc 01       	movw	r26, r24
    6c92:	cb 01       	movw	r24, r22
    6c94:	88 a3       	std	Y+32, r24	; 0x20
    6c96:	99 a3       	std	Y+33, r25	; 0x21
    6c98:	aa a3       	std	Y+34, r26	; 0x22
    6c9a:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    6c9c:	68 a1       	ldd	r22, Y+32	; 0x20
    6c9e:	79 a1       	ldd	r23, Y+33	; 0x21
    6ca0:	8a a1       	ldd	r24, Y+34	; 0x22
    6ca2:	9b a1       	ldd	r25, Y+35	; 0x23
    6ca4:	20 e0       	ldi	r18, 0x00	; 0
    6ca6:	30 e0       	ldi	r19, 0x00	; 0
    6ca8:	40 e8       	ldi	r20, 0x80	; 128
    6caa:	5f e3       	ldi	r21, 0x3F	; 63
    6cac:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6cb0:	88 23       	and	r24, r24
    6cb2:	2c f4       	brge	.+10     	; 0x6cbe <LCD_write_cmd_4bit+0x57c>
		__ticks = 1;
    6cb4:	81 e0       	ldi	r24, 0x01	; 1
    6cb6:	90 e0       	ldi	r25, 0x00	; 0
    6cb8:	9f 8f       	std	Y+31, r25	; 0x1f
    6cba:	8e 8f       	std	Y+30, r24	; 0x1e
    6cbc:	3f c0       	rjmp	.+126    	; 0x6d3c <LCD_write_cmd_4bit+0x5fa>
	else if (__tmp > 65535)
    6cbe:	68 a1       	ldd	r22, Y+32	; 0x20
    6cc0:	79 a1       	ldd	r23, Y+33	; 0x21
    6cc2:	8a a1       	ldd	r24, Y+34	; 0x22
    6cc4:	9b a1       	ldd	r25, Y+35	; 0x23
    6cc6:	20 e0       	ldi	r18, 0x00	; 0
    6cc8:	3f ef       	ldi	r19, 0xFF	; 255
    6cca:	4f e7       	ldi	r20, 0x7F	; 127
    6ccc:	57 e4       	ldi	r21, 0x47	; 71
    6cce:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6cd2:	18 16       	cp	r1, r24
    6cd4:	4c f5       	brge	.+82     	; 0x6d28 <LCD_write_cmd_4bit+0x5e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6cd6:	6c a1       	ldd	r22, Y+36	; 0x24
    6cd8:	7d a1       	ldd	r23, Y+37	; 0x25
    6cda:	8e a1       	ldd	r24, Y+38	; 0x26
    6cdc:	9f a1       	ldd	r25, Y+39	; 0x27
    6cde:	20 e0       	ldi	r18, 0x00	; 0
    6ce0:	30 e0       	ldi	r19, 0x00	; 0
    6ce2:	40 e2       	ldi	r20, 0x20	; 32
    6ce4:	51 e4       	ldi	r21, 0x41	; 65
    6ce6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6cea:	dc 01       	movw	r26, r24
    6cec:	cb 01       	movw	r24, r22
    6cee:	bc 01       	movw	r22, r24
    6cf0:	cd 01       	movw	r24, r26
    6cf2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6cf6:	dc 01       	movw	r26, r24
    6cf8:	cb 01       	movw	r24, r22
    6cfa:	9f 8f       	std	Y+31, r25	; 0x1f
    6cfc:	8e 8f       	std	Y+30, r24	; 0x1e
    6cfe:	0f c0       	rjmp	.+30     	; 0x6d1e <LCD_write_cmd_4bit+0x5dc>
    6d00:	80 e9       	ldi	r24, 0x90	; 144
    6d02:	91 e0       	ldi	r25, 0x01	; 1
    6d04:	9d 8f       	std	Y+29, r25	; 0x1d
    6d06:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6d08:	8c 8d       	ldd	r24, Y+28	; 0x1c
    6d0a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    6d0c:	01 97       	sbiw	r24, 0x01	; 1
    6d0e:	f1 f7       	brne	.-4      	; 0x6d0c <LCD_write_cmd_4bit+0x5ca>
    6d10:	9d 8f       	std	Y+29, r25	; 0x1d
    6d12:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6d14:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d16:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d18:	01 97       	sbiw	r24, 0x01	; 1
    6d1a:	9f 8f       	std	Y+31, r25	; 0x1f
    6d1c:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6d1e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d20:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d22:	00 97       	sbiw	r24, 0x00	; 0
    6d24:	69 f7       	brne	.-38     	; 0x6d00 <LCD_write_cmd_4bit+0x5be>
    6d26:	24 c0       	rjmp	.+72     	; 0x6d70 <LCD_write_cmd_4bit+0x62e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6d28:	68 a1       	ldd	r22, Y+32	; 0x20
    6d2a:	79 a1       	ldd	r23, Y+33	; 0x21
    6d2c:	8a a1       	ldd	r24, Y+34	; 0x22
    6d2e:	9b a1       	ldd	r25, Y+35	; 0x23
    6d30:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6d34:	dc 01       	movw	r26, r24
    6d36:	cb 01       	movw	r24, r22
    6d38:	9f 8f       	std	Y+31, r25	; 0x1f
    6d3a:	8e 8f       	std	Y+30, r24	; 0x1e
    6d3c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d3e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d40:	9b 8f       	std	Y+27, r25	; 0x1b
    6d42:	8a 8f       	std	Y+26, r24	; 0x1a
    6d44:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d46:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d48:	01 97       	sbiw	r24, 0x01	; 1
    6d4a:	f1 f7       	brne	.-4      	; 0x6d48 <LCD_write_cmd_4bit+0x606>
    6d4c:	9b 8f       	std	Y+27, r25	; 0x1b
    6d4e:	8a 8f       	std	Y+26, r24	; 0x1a
    6d50:	0f c0       	rjmp	.+30     	; 0x6d70 <LCD_write_cmd_4bit+0x62e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6d52:	69 a5       	ldd	r22, Y+41	; 0x29
    6d54:	7a a5       	ldd	r23, Y+42	; 0x2a
    6d56:	8b a5       	ldd	r24, Y+43	; 0x2b
    6d58:	9c a5       	ldd	r25, Y+44	; 0x2c
    6d5a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6d5e:	dc 01       	movw	r26, r24
    6d60:	cb 01       	movw	r24, r22
    6d62:	88 a7       	std	Y+40, r24	; 0x28
    6d64:	88 a5       	ldd	r24, Y+40	; 0x28
    6d66:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6d68:	89 8d       	ldd	r24, Y+25	; 0x19
    6d6a:	8a 95       	dec	r24
    6d6c:	f1 f7       	brne	.-4      	; 0x6d6a <LCD_write_cmd_4bit+0x628>
    6d6e:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(10);
	// Enable pin is high to send the Lower nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    6d70:	82 e0       	ldi	r24, 0x02	; 2
    6d72:	60 e0       	ldi	r22, 0x00	; 0
    6d74:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    6d78:	80 e0       	ldi	r24, 0x00	; 0
    6d7a:	90 e0       	ldi	r25, 0x00	; 0
    6d7c:	a0 e8       	ldi	r26, 0x80	; 128
    6d7e:	bf e3       	ldi	r27, 0x3F	; 63
    6d80:	8d 8b       	std	Y+21, r24	; 0x15
    6d82:	9e 8b       	std	Y+22, r25	; 0x16
    6d84:	af 8b       	std	Y+23, r26	; 0x17
    6d86:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    6d88:	6d 89       	ldd	r22, Y+21	; 0x15
    6d8a:	7e 89       	ldd	r23, Y+22	; 0x16
    6d8c:	8f 89       	ldd	r24, Y+23	; 0x17
    6d8e:	98 8d       	ldd	r25, Y+24	; 0x18
    6d90:	2b ea       	ldi	r18, 0xAB	; 171
    6d92:	3a ea       	ldi	r19, 0xAA	; 170
    6d94:	4a ea       	ldi	r20, 0xAA	; 170
    6d96:	50 e4       	ldi	r21, 0x40	; 64
    6d98:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6d9c:	dc 01       	movw	r26, r24
    6d9e:	cb 01       	movw	r24, r22
    6da0:	89 8b       	std	Y+17, r24	; 0x11
    6da2:	9a 8b       	std	Y+18, r25	; 0x12
    6da4:	ab 8b       	std	Y+19, r26	; 0x13
    6da6:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    6da8:	69 89       	ldd	r22, Y+17	; 0x11
    6daa:	7a 89       	ldd	r23, Y+18	; 0x12
    6dac:	8b 89       	ldd	r24, Y+19	; 0x13
    6dae:	9c 89       	ldd	r25, Y+20	; 0x14
    6db0:	20 e0       	ldi	r18, 0x00	; 0
    6db2:	30 e0       	ldi	r19, 0x00	; 0
    6db4:	40 e8       	ldi	r20, 0x80	; 128
    6db6:	5f e3       	ldi	r21, 0x3F	; 63
    6db8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6dbc:	88 23       	and	r24, r24
    6dbe:	1c f4       	brge	.+6      	; 0x6dc6 <LCD_write_cmd_4bit+0x684>
		__ticks = 1;
    6dc0:	81 e0       	ldi	r24, 0x01	; 1
    6dc2:	88 8b       	std	Y+16, r24	; 0x10
    6dc4:	91 c0       	rjmp	.+290    	; 0x6ee8 <LCD_write_cmd_4bit+0x7a6>
	else if (__tmp > 255)
    6dc6:	69 89       	ldd	r22, Y+17	; 0x11
    6dc8:	7a 89       	ldd	r23, Y+18	; 0x12
    6dca:	8b 89       	ldd	r24, Y+19	; 0x13
    6dcc:	9c 89       	ldd	r25, Y+20	; 0x14
    6dce:	20 e0       	ldi	r18, 0x00	; 0
    6dd0:	30 e0       	ldi	r19, 0x00	; 0
    6dd2:	4f e7       	ldi	r20, 0x7F	; 127
    6dd4:	53 e4       	ldi	r21, 0x43	; 67
    6dd6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6dda:	18 16       	cp	r1, r24
    6ddc:	0c f0       	brlt	.+2      	; 0x6de0 <LCD_write_cmd_4bit+0x69e>
    6dde:	7b c0       	rjmp	.+246    	; 0x6ed6 <LCD_write_cmd_4bit+0x794>
	{
		_delay_ms(__us / 1000.0);
    6de0:	6d 89       	ldd	r22, Y+21	; 0x15
    6de2:	7e 89       	ldd	r23, Y+22	; 0x16
    6de4:	8f 89       	ldd	r24, Y+23	; 0x17
    6de6:	98 8d       	ldd	r25, Y+24	; 0x18
    6de8:	20 e0       	ldi	r18, 0x00	; 0
    6dea:	30 e0       	ldi	r19, 0x00	; 0
    6dec:	4a e7       	ldi	r20, 0x7A	; 122
    6dee:	54 e4       	ldi	r21, 0x44	; 68
    6df0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6df4:	dc 01       	movw	r26, r24
    6df6:	cb 01       	movw	r24, r22
    6df8:	8c 87       	std	Y+12, r24	; 0x0c
    6dfa:	9d 87       	std	Y+13, r25	; 0x0d
    6dfc:	ae 87       	std	Y+14, r26	; 0x0e
    6dfe:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6e00:	6c 85       	ldd	r22, Y+12	; 0x0c
    6e02:	7d 85       	ldd	r23, Y+13	; 0x0d
    6e04:	8e 85       	ldd	r24, Y+14	; 0x0e
    6e06:	9f 85       	ldd	r25, Y+15	; 0x0f
    6e08:	20 e0       	ldi	r18, 0x00	; 0
    6e0a:	30 e0       	ldi	r19, 0x00	; 0
    6e0c:	4a e7       	ldi	r20, 0x7A	; 122
    6e0e:	55 e4       	ldi	r21, 0x45	; 69
    6e10:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6e14:	dc 01       	movw	r26, r24
    6e16:	cb 01       	movw	r24, r22
    6e18:	88 87       	std	Y+8, r24	; 0x08
    6e1a:	99 87       	std	Y+9, r25	; 0x09
    6e1c:	aa 87       	std	Y+10, r26	; 0x0a
    6e1e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    6e20:	68 85       	ldd	r22, Y+8	; 0x08
    6e22:	79 85       	ldd	r23, Y+9	; 0x09
    6e24:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e26:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e28:	20 e0       	ldi	r18, 0x00	; 0
    6e2a:	30 e0       	ldi	r19, 0x00	; 0
    6e2c:	40 e8       	ldi	r20, 0x80	; 128
    6e2e:	5f e3       	ldi	r21, 0x3F	; 63
    6e30:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6e34:	88 23       	and	r24, r24
    6e36:	2c f4       	brge	.+10     	; 0x6e42 <LCD_write_cmd_4bit+0x700>
		__ticks = 1;
    6e38:	81 e0       	ldi	r24, 0x01	; 1
    6e3a:	90 e0       	ldi	r25, 0x00	; 0
    6e3c:	9f 83       	std	Y+7, r25	; 0x07
    6e3e:	8e 83       	std	Y+6, r24	; 0x06
    6e40:	3f c0       	rjmp	.+126    	; 0x6ec0 <LCD_write_cmd_4bit+0x77e>
	else if (__tmp > 65535)
    6e42:	68 85       	ldd	r22, Y+8	; 0x08
    6e44:	79 85       	ldd	r23, Y+9	; 0x09
    6e46:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e48:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e4a:	20 e0       	ldi	r18, 0x00	; 0
    6e4c:	3f ef       	ldi	r19, 0xFF	; 255
    6e4e:	4f e7       	ldi	r20, 0x7F	; 127
    6e50:	57 e4       	ldi	r21, 0x47	; 71
    6e52:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6e56:	18 16       	cp	r1, r24
    6e58:	4c f5       	brge	.+82     	; 0x6eac <LCD_write_cmd_4bit+0x76a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e5a:	6c 85       	ldd	r22, Y+12	; 0x0c
    6e5c:	7d 85       	ldd	r23, Y+13	; 0x0d
    6e5e:	8e 85       	ldd	r24, Y+14	; 0x0e
    6e60:	9f 85       	ldd	r25, Y+15	; 0x0f
    6e62:	20 e0       	ldi	r18, 0x00	; 0
    6e64:	30 e0       	ldi	r19, 0x00	; 0
    6e66:	40 e2       	ldi	r20, 0x20	; 32
    6e68:	51 e4       	ldi	r21, 0x41	; 65
    6e6a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6e6e:	dc 01       	movw	r26, r24
    6e70:	cb 01       	movw	r24, r22
    6e72:	bc 01       	movw	r22, r24
    6e74:	cd 01       	movw	r24, r26
    6e76:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6e7a:	dc 01       	movw	r26, r24
    6e7c:	cb 01       	movw	r24, r22
    6e7e:	9f 83       	std	Y+7, r25	; 0x07
    6e80:	8e 83       	std	Y+6, r24	; 0x06
    6e82:	0f c0       	rjmp	.+30     	; 0x6ea2 <LCD_write_cmd_4bit+0x760>
    6e84:	80 e9       	ldi	r24, 0x90	; 144
    6e86:	91 e0       	ldi	r25, 0x01	; 1
    6e88:	9d 83       	std	Y+5, r25	; 0x05
    6e8a:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6e8c:	8c 81       	ldd	r24, Y+4	; 0x04
    6e8e:	9d 81       	ldd	r25, Y+5	; 0x05
    6e90:	01 97       	sbiw	r24, 0x01	; 1
    6e92:	f1 f7       	brne	.-4      	; 0x6e90 <LCD_write_cmd_4bit+0x74e>
    6e94:	9d 83       	std	Y+5, r25	; 0x05
    6e96:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e98:	8e 81       	ldd	r24, Y+6	; 0x06
    6e9a:	9f 81       	ldd	r25, Y+7	; 0x07
    6e9c:	01 97       	sbiw	r24, 0x01	; 1
    6e9e:	9f 83       	std	Y+7, r25	; 0x07
    6ea0:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6ea2:	8e 81       	ldd	r24, Y+6	; 0x06
    6ea4:	9f 81       	ldd	r25, Y+7	; 0x07
    6ea6:	00 97       	sbiw	r24, 0x00	; 0
    6ea8:	69 f7       	brne	.-38     	; 0x6e84 <LCD_write_cmd_4bit+0x742>
    6eaa:	24 c0       	rjmp	.+72     	; 0x6ef4 <LCD_write_cmd_4bit+0x7b2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6eac:	68 85       	ldd	r22, Y+8	; 0x08
    6eae:	79 85       	ldd	r23, Y+9	; 0x09
    6eb0:	8a 85       	ldd	r24, Y+10	; 0x0a
    6eb2:	9b 85       	ldd	r25, Y+11	; 0x0b
    6eb4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6eb8:	dc 01       	movw	r26, r24
    6eba:	cb 01       	movw	r24, r22
    6ebc:	9f 83       	std	Y+7, r25	; 0x07
    6ebe:	8e 83       	std	Y+6, r24	; 0x06
    6ec0:	8e 81       	ldd	r24, Y+6	; 0x06
    6ec2:	9f 81       	ldd	r25, Y+7	; 0x07
    6ec4:	9b 83       	std	Y+3, r25	; 0x03
    6ec6:	8a 83       	std	Y+2, r24	; 0x02
    6ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    6eca:	9b 81       	ldd	r25, Y+3	; 0x03
    6ecc:	01 97       	sbiw	r24, 0x01	; 1
    6ece:	f1 f7       	brne	.-4      	; 0x6ecc <LCD_write_cmd_4bit+0x78a>
    6ed0:	9b 83       	std	Y+3, r25	; 0x03
    6ed2:	8a 83       	std	Y+2, r24	; 0x02
    6ed4:	0f c0       	rjmp	.+30     	; 0x6ef4 <LCD_write_cmd_4bit+0x7b2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6ed6:	69 89       	ldd	r22, Y+17	; 0x11
    6ed8:	7a 89       	ldd	r23, Y+18	; 0x12
    6eda:	8b 89       	ldd	r24, Y+19	; 0x13
    6edc:	9c 89       	ldd	r25, Y+20	; 0x14
    6ede:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6ee2:	dc 01       	movw	r26, r24
    6ee4:	cb 01       	movw	r24, r22
    6ee6:	88 8b       	std	Y+16, r24	; 0x10
    6ee8:	88 89       	ldd	r24, Y+16	; 0x10
    6eea:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6eec:	89 81       	ldd	r24, Y+1	; 0x01
    6eee:	8a 95       	dec	r24
    6ef0:	f1 f7       	brne	.-4      	; 0x6eee <LCD_write_cmd_4bit+0x7ac>
    6ef2:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	// Sent the Lower nipple
	for(u8 i= 4; i< 8; i++)
    6ef4:	fe 01       	movw	r30, r28
    6ef6:	ef 59       	subi	r30, 0x9F	; 159
    6ef8:	ff 4f       	sbci	r31, 0xFF	; 255
    6efa:	84 e0       	ldi	r24, 0x04	; 4
    6efc:	80 83       	st	Z, r24
    6efe:	27 c0       	rjmp	.+78     	; 0x6f4e <LCD_write_cmd_4bit+0x80c>
		DIO_void_assign_pin(lcd_data_port, i, get_bit(lcd_copy_cmd_4bit, i-4));
    6f00:	fe 01       	movw	r30, r28
    6f02:	ed 59       	subi	r30, 0x9D	; 157
    6f04:	ff 4f       	sbci	r31, 0xFF	; 255
    6f06:	80 81       	ld	r24, Z
    6f08:	28 2f       	mov	r18, r24
    6f0a:	30 e0       	ldi	r19, 0x00	; 0
    6f0c:	fe 01       	movw	r30, r28
    6f0e:	ef 59       	subi	r30, 0x9F	; 159
    6f10:	ff 4f       	sbci	r31, 0xFF	; 255
    6f12:	80 81       	ld	r24, Z
    6f14:	88 2f       	mov	r24, r24
    6f16:	90 e0       	ldi	r25, 0x00	; 0
    6f18:	04 97       	sbiw	r24, 0x04	; 4
    6f1a:	f9 01       	movw	r30, r18
    6f1c:	02 c0       	rjmp	.+4      	; 0x6f22 <LCD_write_cmd_4bit+0x7e0>
    6f1e:	f5 95       	asr	r31
    6f20:	e7 95       	ror	r30
    6f22:	8a 95       	dec	r24
    6f24:	e2 f7       	brpl	.-8      	; 0x6f1e <LCD_write_cmd_4bit+0x7dc>
    6f26:	cf 01       	movw	r24, r30
    6f28:	98 2f       	mov	r25, r24
    6f2a:	91 70       	andi	r25, 0x01	; 1
    6f2c:	fe 01       	movw	r30, r28
    6f2e:	ef 59       	subi	r30, 0x9F	; 159
    6f30:	ff 4f       	sbci	r31, 0xFF	; 255
    6f32:	82 e0       	ldi	r24, 0x02	; 2
    6f34:	60 81       	ld	r22, Z
    6f36:	49 2f       	mov	r20, r25
    6f38:	0e 94 6a 27 	call	0x4ed4	; 0x4ed4 <DIO_void_assign_pin>
	_delay_us(10);
	// Enable pin is high to send the Lower nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
	_delay_us(1);
	// Sent the Lower nipple
	for(u8 i= 4; i< 8; i++)
    6f3c:	de 01       	movw	r26, r28
    6f3e:	af 59       	subi	r26, 0x9F	; 159
    6f40:	bf 4f       	sbci	r27, 0xFF	; 255
    6f42:	fe 01       	movw	r30, r28
    6f44:	ef 59       	subi	r30, 0x9F	; 159
    6f46:	ff 4f       	sbci	r31, 0xFF	; 255
    6f48:	80 81       	ld	r24, Z
    6f4a:	8f 5f       	subi	r24, 0xFF	; 255
    6f4c:	8c 93       	st	X, r24
    6f4e:	fe 01       	movw	r30, r28
    6f50:	ef 59       	subi	r30, 0x9F	; 159
    6f52:	ff 4f       	sbci	r31, 0xFF	; 255
    6f54:	80 81       	ld	r24, Z
    6f56:	88 30       	cpi	r24, 0x08	; 8
    6f58:	98 f2       	brcs	.-90     	; 0x6f00 <LCD_write_cmd_4bit+0x7be>
		DIO_void_assign_pin(lcd_data_port, i, get_bit(lcd_copy_cmd_4bit, i-4));
	// Enable pin low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    6f5a:	82 e0       	ldi	r24, 0x02	; 2
    6f5c:	60 e0       	ldi	r22, 0x00	; 0
    6f5e:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
}
    6f62:	cd 59       	subi	r28, 0x9D	; 157
    6f64:	df 4f       	sbci	r29, 0xFF	; 255
    6f66:	0f b6       	in	r0, 0x3f	; 63
    6f68:	f8 94       	cli
    6f6a:	de bf       	out	0x3e, r29	; 62
    6f6c:	0f be       	out	0x3f, r0	; 63
    6f6e:	cd bf       	out	0x3d, r28	; 61
    6f70:	cf 91       	pop	r28
    6f72:	df 91       	pop	r29
    6f74:	1f 91       	pop	r17
    6f76:	0f 91       	pop	r16
    6f78:	08 95       	ret

00006f7a <LCD_function_set_4bit>:

void LCD_function_set_4bit(void ){
    6f7a:	0f 93       	push	r16
    6f7c:	1f 93       	push	r17
    6f7e:	df 93       	push	r29
    6f80:	cf 93       	push	r28
    6f82:	cd b7       	in	r28, 0x3d	; 61
    6f84:	de b7       	in	r29, 0x3e	; 62
    6f86:	cb 5a       	subi	r28, 0xAB	; 171
    6f88:	d0 40       	sbci	r29, 0x00	; 0
    6f8a:	0f b6       	in	r0, 0x3f	; 63
    6f8c:	f8 94       	cli
    6f8e:	de bf       	out	0x3e, r29	; 62
    6f90:	0f be       	out	0x3f, r0	; 63
    6f92:	cd bf       	out	0x3d, r28	; 61
	 *	No inputs for the function.
	 *
	 *	No return from the function.
	 */
	// Configure RS/RW pins to recive command
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RS);
    6f94:	82 e0       	ldi	r24, 0x02	; 2
    6f96:	62 e0       	ldi	r22, 0x02	; 2
    6f98:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RW);
    6f9c:	82 e0       	ldi	r24, 0x02	; 2
    6f9e:	61 e0       	ldi	r22, 0x01	; 1
    6fa0:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    6fa4:	fe 01       	movw	r30, r28
    6fa6:	eb 55       	subi	r30, 0x5B	; 91
    6fa8:	ff 4f       	sbci	r31, 0xFF	; 255
    6faa:	80 e0       	ldi	r24, 0x00	; 0
    6fac:	90 e0       	ldi	r25, 0x00	; 0
    6fae:	a0 e8       	ldi	r26, 0x80	; 128
    6fb0:	bf e3       	ldi	r27, 0x3F	; 63
    6fb2:	80 83       	st	Z, r24
    6fb4:	91 83       	std	Z+1, r25	; 0x01
    6fb6:	a2 83       	std	Z+2, r26	; 0x02
    6fb8:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    6fba:	8e 01       	movw	r16, r28
    6fbc:	0f 55       	subi	r16, 0x5F	; 95
    6fbe:	1f 4f       	sbci	r17, 0xFF	; 255
    6fc0:	fe 01       	movw	r30, r28
    6fc2:	eb 55       	subi	r30, 0x5B	; 91
    6fc4:	ff 4f       	sbci	r31, 0xFF	; 255
    6fc6:	60 81       	ld	r22, Z
    6fc8:	71 81       	ldd	r23, Z+1	; 0x01
    6fca:	82 81       	ldd	r24, Z+2	; 0x02
    6fcc:	93 81       	ldd	r25, Z+3	; 0x03
    6fce:	2b ea       	ldi	r18, 0xAB	; 171
    6fd0:	3a ea       	ldi	r19, 0xAA	; 170
    6fd2:	4a ea       	ldi	r20, 0xAA	; 170
    6fd4:	50 e4       	ldi	r21, 0x40	; 64
    6fd6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6fda:	dc 01       	movw	r26, r24
    6fdc:	cb 01       	movw	r24, r22
    6fde:	f8 01       	movw	r30, r16
    6fe0:	80 83       	st	Z, r24
    6fe2:	91 83       	std	Z+1, r25	; 0x01
    6fe4:	a2 83       	std	Z+2, r26	; 0x02
    6fe6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    6fe8:	fe 01       	movw	r30, r28
    6fea:	ef 55       	subi	r30, 0x5F	; 95
    6fec:	ff 4f       	sbci	r31, 0xFF	; 255
    6fee:	60 81       	ld	r22, Z
    6ff0:	71 81       	ldd	r23, Z+1	; 0x01
    6ff2:	82 81       	ldd	r24, Z+2	; 0x02
    6ff4:	93 81       	ldd	r25, Z+3	; 0x03
    6ff6:	20 e0       	ldi	r18, 0x00	; 0
    6ff8:	30 e0       	ldi	r19, 0x00	; 0
    6ffa:	40 e8       	ldi	r20, 0x80	; 128
    6ffc:	5f e3       	ldi	r21, 0x3F	; 63
    6ffe:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7002:	88 23       	and	r24, r24
    7004:	34 f4       	brge	.+12     	; 0x7012 <LCD_function_set_4bit+0x98>
		__ticks = 1;
    7006:	fe 01       	movw	r30, r28
    7008:	e0 56       	subi	r30, 0x60	; 96
    700a:	ff 4f       	sbci	r31, 0xFF	; 255
    700c:	81 e0       	ldi	r24, 0x01	; 1
    700e:	80 83       	st	Z, r24
    7010:	e0 c0       	rjmp	.+448    	; 0x71d2 <LCD_function_set_4bit+0x258>
	else if (__tmp > 255)
    7012:	fe 01       	movw	r30, r28
    7014:	ef 55       	subi	r30, 0x5F	; 95
    7016:	ff 4f       	sbci	r31, 0xFF	; 255
    7018:	60 81       	ld	r22, Z
    701a:	71 81       	ldd	r23, Z+1	; 0x01
    701c:	82 81       	ldd	r24, Z+2	; 0x02
    701e:	93 81       	ldd	r25, Z+3	; 0x03
    7020:	20 e0       	ldi	r18, 0x00	; 0
    7022:	30 e0       	ldi	r19, 0x00	; 0
    7024:	4f e7       	ldi	r20, 0x7F	; 127
    7026:	53 e4       	ldi	r21, 0x43	; 67
    7028:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    702c:	18 16       	cp	r1, r24
    702e:	0c f0       	brlt	.+2      	; 0x7032 <LCD_function_set_4bit+0xb8>
    7030:	c0 c0       	rjmp	.+384    	; 0x71b2 <LCD_function_set_4bit+0x238>
	{
		_delay_ms(__us / 1000.0);
    7032:	fe 01       	movw	r30, r28
    7034:	eb 55       	subi	r30, 0x5B	; 91
    7036:	ff 4f       	sbci	r31, 0xFF	; 255
    7038:	60 81       	ld	r22, Z
    703a:	71 81       	ldd	r23, Z+1	; 0x01
    703c:	82 81       	ldd	r24, Z+2	; 0x02
    703e:	93 81       	ldd	r25, Z+3	; 0x03
    7040:	20 e0       	ldi	r18, 0x00	; 0
    7042:	30 e0       	ldi	r19, 0x00	; 0
    7044:	4a e7       	ldi	r20, 0x7A	; 122
    7046:	54 e4       	ldi	r21, 0x44	; 68
    7048:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    704c:	dc 01       	movw	r26, r24
    704e:	cb 01       	movw	r24, r22
    7050:	fe 01       	movw	r30, r28
    7052:	e4 56       	subi	r30, 0x64	; 100
    7054:	ff 4f       	sbci	r31, 0xFF	; 255
    7056:	80 83       	st	Z, r24
    7058:	91 83       	std	Z+1, r25	; 0x01
    705a:	a2 83       	std	Z+2, r26	; 0x02
    705c:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    705e:	8e 01       	movw	r16, r28
    7060:	08 56       	subi	r16, 0x68	; 104
    7062:	1f 4f       	sbci	r17, 0xFF	; 255
    7064:	fe 01       	movw	r30, r28
    7066:	e4 56       	subi	r30, 0x64	; 100
    7068:	ff 4f       	sbci	r31, 0xFF	; 255
    706a:	60 81       	ld	r22, Z
    706c:	71 81       	ldd	r23, Z+1	; 0x01
    706e:	82 81       	ldd	r24, Z+2	; 0x02
    7070:	93 81       	ldd	r25, Z+3	; 0x03
    7072:	20 e0       	ldi	r18, 0x00	; 0
    7074:	30 e0       	ldi	r19, 0x00	; 0
    7076:	4a e7       	ldi	r20, 0x7A	; 122
    7078:	55 e4       	ldi	r21, 0x45	; 69
    707a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    707e:	dc 01       	movw	r26, r24
    7080:	cb 01       	movw	r24, r22
    7082:	f8 01       	movw	r30, r16
    7084:	80 83       	st	Z, r24
    7086:	91 83       	std	Z+1, r25	; 0x01
    7088:	a2 83       	std	Z+2, r26	; 0x02
    708a:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    708c:	fe 01       	movw	r30, r28
    708e:	e8 56       	subi	r30, 0x68	; 104
    7090:	ff 4f       	sbci	r31, 0xFF	; 255
    7092:	60 81       	ld	r22, Z
    7094:	71 81       	ldd	r23, Z+1	; 0x01
    7096:	82 81       	ldd	r24, Z+2	; 0x02
    7098:	93 81       	ldd	r25, Z+3	; 0x03
    709a:	20 e0       	ldi	r18, 0x00	; 0
    709c:	30 e0       	ldi	r19, 0x00	; 0
    709e:	40 e8       	ldi	r20, 0x80	; 128
    70a0:	5f e3       	ldi	r21, 0x3F	; 63
    70a2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    70a6:	88 23       	and	r24, r24
    70a8:	44 f4       	brge	.+16     	; 0x70ba <LCD_function_set_4bit+0x140>
		__ticks = 1;
    70aa:	fe 01       	movw	r30, r28
    70ac:	ea 56       	subi	r30, 0x6A	; 106
    70ae:	ff 4f       	sbci	r31, 0xFF	; 255
    70b0:	81 e0       	ldi	r24, 0x01	; 1
    70b2:	90 e0       	ldi	r25, 0x00	; 0
    70b4:	91 83       	std	Z+1, r25	; 0x01
    70b6:	80 83       	st	Z, r24
    70b8:	64 c0       	rjmp	.+200    	; 0x7182 <LCD_function_set_4bit+0x208>
	else if (__tmp > 65535)
    70ba:	fe 01       	movw	r30, r28
    70bc:	e8 56       	subi	r30, 0x68	; 104
    70be:	ff 4f       	sbci	r31, 0xFF	; 255
    70c0:	60 81       	ld	r22, Z
    70c2:	71 81       	ldd	r23, Z+1	; 0x01
    70c4:	82 81       	ldd	r24, Z+2	; 0x02
    70c6:	93 81       	ldd	r25, Z+3	; 0x03
    70c8:	20 e0       	ldi	r18, 0x00	; 0
    70ca:	3f ef       	ldi	r19, 0xFF	; 255
    70cc:	4f e7       	ldi	r20, 0x7F	; 127
    70ce:	57 e4       	ldi	r21, 0x47	; 71
    70d0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    70d4:	18 16       	cp	r1, r24
    70d6:	0c f0       	brlt	.+2      	; 0x70da <LCD_function_set_4bit+0x160>
    70d8:	43 c0       	rjmp	.+134    	; 0x7160 <LCD_function_set_4bit+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    70da:	fe 01       	movw	r30, r28
    70dc:	e4 56       	subi	r30, 0x64	; 100
    70de:	ff 4f       	sbci	r31, 0xFF	; 255
    70e0:	60 81       	ld	r22, Z
    70e2:	71 81       	ldd	r23, Z+1	; 0x01
    70e4:	82 81       	ldd	r24, Z+2	; 0x02
    70e6:	93 81       	ldd	r25, Z+3	; 0x03
    70e8:	20 e0       	ldi	r18, 0x00	; 0
    70ea:	30 e0       	ldi	r19, 0x00	; 0
    70ec:	40 e2       	ldi	r20, 0x20	; 32
    70ee:	51 e4       	ldi	r21, 0x41	; 65
    70f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    70f4:	dc 01       	movw	r26, r24
    70f6:	cb 01       	movw	r24, r22
    70f8:	8e 01       	movw	r16, r28
    70fa:	0a 56       	subi	r16, 0x6A	; 106
    70fc:	1f 4f       	sbci	r17, 0xFF	; 255
    70fe:	bc 01       	movw	r22, r24
    7100:	cd 01       	movw	r24, r26
    7102:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7106:	dc 01       	movw	r26, r24
    7108:	cb 01       	movw	r24, r22
    710a:	f8 01       	movw	r30, r16
    710c:	91 83       	std	Z+1, r25	; 0x01
    710e:	80 83       	st	Z, r24
    7110:	1f c0       	rjmp	.+62     	; 0x7150 <LCD_function_set_4bit+0x1d6>
    7112:	fe 01       	movw	r30, r28
    7114:	ec 56       	subi	r30, 0x6C	; 108
    7116:	ff 4f       	sbci	r31, 0xFF	; 255
    7118:	80 e9       	ldi	r24, 0x90	; 144
    711a:	91 e0       	ldi	r25, 0x01	; 1
    711c:	91 83       	std	Z+1, r25	; 0x01
    711e:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7120:	fe 01       	movw	r30, r28
    7122:	ec 56       	subi	r30, 0x6C	; 108
    7124:	ff 4f       	sbci	r31, 0xFF	; 255
    7126:	80 81       	ld	r24, Z
    7128:	91 81       	ldd	r25, Z+1	; 0x01
    712a:	01 97       	sbiw	r24, 0x01	; 1
    712c:	f1 f7       	brne	.-4      	; 0x712a <LCD_function_set_4bit+0x1b0>
    712e:	fe 01       	movw	r30, r28
    7130:	ec 56       	subi	r30, 0x6C	; 108
    7132:	ff 4f       	sbci	r31, 0xFF	; 255
    7134:	91 83       	std	Z+1, r25	; 0x01
    7136:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7138:	de 01       	movw	r26, r28
    713a:	aa 56       	subi	r26, 0x6A	; 106
    713c:	bf 4f       	sbci	r27, 0xFF	; 255
    713e:	fe 01       	movw	r30, r28
    7140:	ea 56       	subi	r30, 0x6A	; 106
    7142:	ff 4f       	sbci	r31, 0xFF	; 255
    7144:	80 81       	ld	r24, Z
    7146:	91 81       	ldd	r25, Z+1	; 0x01
    7148:	01 97       	sbiw	r24, 0x01	; 1
    714a:	11 96       	adiw	r26, 0x01	; 1
    714c:	9c 93       	st	X, r25
    714e:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7150:	fe 01       	movw	r30, r28
    7152:	ea 56       	subi	r30, 0x6A	; 106
    7154:	ff 4f       	sbci	r31, 0xFF	; 255
    7156:	80 81       	ld	r24, Z
    7158:	91 81       	ldd	r25, Z+1	; 0x01
    715a:	00 97       	sbiw	r24, 0x00	; 0
    715c:	d1 f6       	brne	.-76     	; 0x7112 <LCD_function_set_4bit+0x198>
    715e:	4b c0       	rjmp	.+150    	; 0x71f6 <LCD_function_set_4bit+0x27c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7160:	8e 01       	movw	r16, r28
    7162:	0a 56       	subi	r16, 0x6A	; 106
    7164:	1f 4f       	sbci	r17, 0xFF	; 255
    7166:	fe 01       	movw	r30, r28
    7168:	e8 56       	subi	r30, 0x68	; 104
    716a:	ff 4f       	sbci	r31, 0xFF	; 255
    716c:	60 81       	ld	r22, Z
    716e:	71 81       	ldd	r23, Z+1	; 0x01
    7170:	82 81       	ldd	r24, Z+2	; 0x02
    7172:	93 81       	ldd	r25, Z+3	; 0x03
    7174:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7178:	dc 01       	movw	r26, r24
    717a:	cb 01       	movw	r24, r22
    717c:	f8 01       	movw	r30, r16
    717e:	91 83       	std	Z+1, r25	; 0x01
    7180:	80 83       	st	Z, r24
    7182:	de 01       	movw	r26, r28
    7184:	ae 56       	subi	r26, 0x6E	; 110
    7186:	bf 4f       	sbci	r27, 0xFF	; 255
    7188:	fe 01       	movw	r30, r28
    718a:	ea 56       	subi	r30, 0x6A	; 106
    718c:	ff 4f       	sbci	r31, 0xFF	; 255
    718e:	80 81       	ld	r24, Z
    7190:	91 81       	ldd	r25, Z+1	; 0x01
    7192:	11 96       	adiw	r26, 0x01	; 1
    7194:	9c 93       	st	X, r25
    7196:	8e 93       	st	-X, r24
    7198:	fe 01       	movw	r30, r28
    719a:	ee 56       	subi	r30, 0x6E	; 110
    719c:	ff 4f       	sbci	r31, 0xFF	; 255
    719e:	80 81       	ld	r24, Z
    71a0:	91 81       	ldd	r25, Z+1	; 0x01
    71a2:	01 97       	sbiw	r24, 0x01	; 1
    71a4:	f1 f7       	brne	.-4      	; 0x71a2 <LCD_function_set_4bit+0x228>
    71a6:	fe 01       	movw	r30, r28
    71a8:	ee 56       	subi	r30, 0x6E	; 110
    71aa:	ff 4f       	sbci	r31, 0xFF	; 255
    71ac:	91 83       	std	Z+1, r25	; 0x01
    71ae:	80 83       	st	Z, r24
    71b0:	22 c0       	rjmp	.+68     	; 0x71f6 <LCD_function_set_4bit+0x27c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    71b2:	8e 01       	movw	r16, r28
    71b4:	00 56       	subi	r16, 0x60	; 96
    71b6:	1f 4f       	sbci	r17, 0xFF	; 255
    71b8:	fe 01       	movw	r30, r28
    71ba:	ef 55       	subi	r30, 0x5F	; 95
    71bc:	ff 4f       	sbci	r31, 0xFF	; 255
    71be:	60 81       	ld	r22, Z
    71c0:	71 81       	ldd	r23, Z+1	; 0x01
    71c2:	82 81       	ldd	r24, Z+2	; 0x02
    71c4:	93 81       	ldd	r25, Z+3	; 0x03
    71c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    71ca:	dc 01       	movw	r26, r24
    71cc:	cb 01       	movw	r24, r22
    71ce:	f8 01       	movw	r30, r16
    71d0:	80 83       	st	Z, r24
    71d2:	de 01       	movw	r26, r28
    71d4:	af 56       	subi	r26, 0x6F	; 111
    71d6:	bf 4f       	sbci	r27, 0xFF	; 255
    71d8:	fe 01       	movw	r30, r28
    71da:	e0 56       	subi	r30, 0x60	; 96
    71dc:	ff 4f       	sbci	r31, 0xFF	; 255
    71de:	80 81       	ld	r24, Z
    71e0:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    71e2:	fe 01       	movw	r30, r28
    71e4:	ef 56       	subi	r30, 0x6F	; 111
    71e6:	ff 4f       	sbci	r31, 0xFF	; 255
    71e8:	80 81       	ld	r24, Z
    71ea:	8a 95       	dec	r24
    71ec:	f1 f7       	brne	.-4      	; 0x71ea <LCD_function_set_4bit+0x270>
    71ee:	fe 01       	movw	r30, r28
    71f0:	ef 56       	subi	r30, 0x6F	; 111
    71f2:	ff 4f       	sbci	r31, 0xFF	; 255
    71f4:	80 83       	st	Z, r24
	_delay_us(1);
	// Enable pin is high to send the packet
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    71f6:	82 e0       	ldi	r24, 0x02	; 2
    71f8:	60 e0       	ldi	r22, 0x00	; 0
    71fa:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    71fe:	fe 01       	movw	r30, r28
    7200:	e3 57       	subi	r30, 0x73	; 115
    7202:	ff 4f       	sbci	r31, 0xFF	; 255
    7204:	80 e0       	ldi	r24, 0x00	; 0
    7206:	90 e0       	ldi	r25, 0x00	; 0
    7208:	a0 e8       	ldi	r26, 0x80	; 128
    720a:	bf e3       	ldi	r27, 0x3F	; 63
    720c:	80 83       	st	Z, r24
    720e:	91 83       	std	Z+1, r25	; 0x01
    7210:	a2 83       	std	Z+2, r26	; 0x02
    7212:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    7214:	8e 01       	movw	r16, r28
    7216:	07 57       	subi	r16, 0x77	; 119
    7218:	1f 4f       	sbci	r17, 0xFF	; 255
    721a:	fe 01       	movw	r30, r28
    721c:	e3 57       	subi	r30, 0x73	; 115
    721e:	ff 4f       	sbci	r31, 0xFF	; 255
    7220:	60 81       	ld	r22, Z
    7222:	71 81       	ldd	r23, Z+1	; 0x01
    7224:	82 81       	ldd	r24, Z+2	; 0x02
    7226:	93 81       	ldd	r25, Z+3	; 0x03
    7228:	2b ea       	ldi	r18, 0xAB	; 171
    722a:	3a ea       	ldi	r19, 0xAA	; 170
    722c:	4a ea       	ldi	r20, 0xAA	; 170
    722e:	50 e4       	ldi	r21, 0x40	; 64
    7230:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7234:	dc 01       	movw	r26, r24
    7236:	cb 01       	movw	r24, r22
    7238:	f8 01       	movw	r30, r16
    723a:	80 83       	st	Z, r24
    723c:	91 83       	std	Z+1, r25	; 0x01
    723e:	a2 83       	std	Z+2, r26	; 0x02
    7240:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7242:	fe 01       	movw	r30, r28
    7244:	e7 57       	subi	r30, 0x77	; 119
    7246:	ff 4f       	sbci	r31, 0xFF	; 255
    7248:	60 81       	ld	r22, Z
    724a:	71 81       	ldd	r23, Z+1	; 0x01
    724c:	82 81       	ldd	r24, Z+2	; 0x02
    724e:	93 81       	ldd	r25, Z+3	; 0x03
    7250:	20 e0       	ldi	r18, 0x00	; 0
    7252:	30 e0       	ldi	r19, 0x00	; 0
    7254:	40 e8       	ldi	r20, 0x80	; 128
    7256:	5f e3       	ldi	r21, 0x3F	; 63
    7258:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    725c:	88 23       	and	r24, r24
    725e:	34 f4       	brge	.+12     	; 0x726c <LCD_function_set_4bit+0x2f2>
		__ticks = 1;
    7260:	fe 01       	movw	r30, r28
    7262:	e8 57       	subi	r30, 0x78	; 120
    7264:	ff 4f       	sbci	r31, 0xFF	; 255
    7266:	81 e0       	ldi	r24, 0x01	; 1
    7268:	80 83       	st	Z, r24
    726a:	e0 c0       	rjmp	.+448    	; 0x742c <LCD_function_set_4bit+0x4b2>
	else if (__tmp > 255)
    726c:	fe 01       	movw	r30, r28
    726e:	e7 57       	subi	r30, 0x77	; 119
    7270:	ff 4f       	sbci	r31, 0xFF	; 255
    7272:	60 81       	ld	r22, Z
    7274:	71 81       	ldd	r23, Z+1	; 0x01
    7276:	82 81       	ldd	r24, Z+2	; 0x02
    7278:	93 81       	ldd	r25, Z+3	; 0x03
    727a:	20 e0       	ldi	r18, 0x00	; 0
    727c:	30 e0       	ldi	r19, 0x00	; 0
    727e:	4f e7       	ldi	r20, 0x7F	; 127
    7280:	53 e4       	ldi	r21, 0x43	; 67
    7282:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7286:	18 16       	cp	r1, r24
    7288:	0c f0       	brlt	.+2      	; 0x728c <LCD_function_set_4bit+0x312>
    728a:	c0 c0       	rjmp	.+384    	; 0x740c <LCD_function_set_4bit+0x492>
	{
		_delay_ms(__us / 1000.0);
    728c:	fe 01       	movw	r30, r28
    728e:	e3 57       	subi	r30, 0x73	; 115
    7290:	ff 4f       	sbci	r31, 0xFF	; 255
    7292:	60 81       	ld	r22, Z
    7294:	71 81       	ldd	r23, Z+1	; 0x01
    7296:	82 81       	ldd	r24, Z+2	; 0x02
    7298:	93 81       	ldd	r25, Z+3	; 0x03
    729a:	20 e0       	ldi	r18, 0x00	; 0
    729c:	30 e0       	ldi	r19, 0x00	; 0
    729e:	4a e7       	ldi	r20, 0x7A	; 122
    72a0:	54 e4       	ldi	r21, 0x44	; 68
    72a2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    72a6:	dc 01       	movw	r26, r24
    72a8:	cb 01       	movw	r24, r22
    72aa:	fe 01       	movw	r30, r28
    72ac:	ec 57       	subi	r30, 0x7C	; 124
    72ae:	ff 4f       	sbci	r31, 0xFF	; 255
    72b0:	80 83       	st	Z, r24
    72b2:	91 83       	std	Z+1, r25	; 0x01
    72b4:	a2 83       	std	Z+2, r26	; 0x02
    72b6:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    72b8:	8e 01       	movw	r16, r28
    72ba:	00 58       	subi	r16, 0x80	; 128
    72bc:	1f 4f       	sbci	r17, 0xFF	; 255
    72be:	fe 01       	movw	r30, r28
    72c0:	ec 57       	subi	r30, 0x7C	; 124
    72c2:	ff 4f       	sbci	r31, 0xFF	; 255
    72c4:	60 81       	ld	r22, Z
    72c6:	71 81       	ldd	r23, Z+1	; 0x01
    72c8:	82 81       	ldd	r24, Z+2	; 0x02
    72ca:	93 81       	ldd	r25, Z+3	; 0x03
    72cc:	20 e0       	ldi	r18, 0x00	; 0
    72ce:	30 e0       	ldi	r19, 0x00	; 0
    72d0:	4a e7       	ldi	r20, 0x7A	; 122
    72d2:	55 e4       	ldi	r21, 0x45	; 69
    72d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    72d8:	dc 01       	movw	r26, r24
    72da:	cb 01       	movw	r24, r22
    72dc:	f8 01       	movw	r30, r16
    72de:	80 83       	st	Z, r24
    72e0:	91 83       	std	Z+1, r25	; 0x01
    72e2:	a2 83       	std	Z+2, r26	; 0x02
    72e4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    72e6:	fe 01       	movw	r30, r28
    72e8:	e0 58       	subi	r30, 0x80	; 128
    72ea:	ff 4f       	sbci	r31, 0xFF	; 255
    72ec:	60 81       	ld	r22, Z
    72ee:	71 81       	ldd	r23, Z+1	; 0x01
    72f0:	82 81       	ldd	r24, Z+2	; 0x02
    72f2:	93 81       	ldd	r25, Z+3	; 0x03
    72f4:	20 e0       	ldi	r18, 0x00	; 0
    72f6:	30 e0       	ldi	r19, 0x00	; 0
    72f8:	40 e8       	ldi	r20, 0x80	; 128
    72fa:	5f e3       	ldi	r21, 0x3F	; 63
    72fc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7300:	88 23       	and	r24, r24
    7302:	44 f4       	brge	.+16     	; 0x7314 <LCD_function_set_4bit+0x39a>
		__ticks = 1;
    7304:	fe 01       	movw	r30, r28
    7306:	e2 58       	subi	r30, 0x82	; 130
    7308:	ff 4f       	sbci	r31, 0xFF	; 255
    730a:	81 e0       	ldi	r24, 0x01	; 1
    730c:	90 e0       	ldi	r25, 0x00	; 0
    730e:	91 83       	std	Z+1, r25	; 0x01
    7310:	80 83       	st	Z, r24
    7312:	64 c0       	rjmp	.+200    	; 0x73dc <LCD_function_set_4bit+0x462>
	else if (__tmp > 65535)
    7314:	fe 01       	movw	r30, r28
    7316:	e0 58       	subi	r30, 0x80	; 128
    7318:	ff 4f       	sbci	r31, 0xFF	; 255
    731a:	60 81       	ld	r22, Z
    731c:	71 81       	ldd	r23, Z+1	; 0x01
    731e:	82 81       	ldd	r24, Z+2	; 0x02
    7320:	93 81       	ldd	r25, Z+3	; 0x03
    7322:	20 e0       	ldi	r18, 0x00	; 0
    7324:	3f ef       	ldi	r19, 0xFF	; 255
    7326:	4f e7       	ldi	r20, 0x7F	; 127
    7328:	57 e4       	ldi	r21, 0x47	; 71
    732a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    732e:	18 16       	cp	r1, r24
    7330:	0c f0       	brlt	.+2      	; 0x7334 <LCD_function_set_4bit+0x3ba>
    7332:	43 c0       	rjmp	.+134    	; 0x73ba <LCD_function_set_4bit+0x440>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7334:	fe 01       	movw	r30, r28
    7336:	ec 57       	subi	r30, 0x7C	; 124
    7338:	ff 4f       	sbci	r31, 0xFF	; 255
    733a:	60 81       	ld	r22, Z
    733c:	71 81       	ldd	r23, Z+1	; 0x01
    733e:	82 81       	ldd	r24, Z+2	; 0x02
    7340:	93 81       	ldd	r25, Z+3	; 0x03
    7342:	20 e0       	ldi	r18, 0x00	; 0
    7344:	30 e0       	ldi	r19, 0x00	; 0
    7346:	40 e2       	ldi	r20, 0x20	; 32
    7348:	51 e4       	ldi	r21, 0x41	; 65
    734a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    734e:	dc 01       	movw	r26, r24
    7350:	cb 01       	movw	r24, r22
    7352:	8e 01       	movw	r16, r28
    7354:	02 58       	subi	r16, 0x82	; 130
    7356:	1f 4f       	sbci	r17, 0xFF	; 255
    7358:	bc 01       	movw	r22, r24
    735a:	cd 01       	movw	r24, r26
    735c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7360:	dc 01       	movw	r26, r24
    7362:	cb 01       	movw	r24, r22
    7364:	f8 01       	movw	r30, r16
    7366:	91 83       	std	Z+1, r25	; 0x01
    7368:	80 83       	st	Z, r24
    736a:	1f c0       	rjmp	.+62     	; 0x73aa <LCD_function_set_4bit+0x430>
    736c:	fe 01       	movw	r30, r28
    736e:	e4 58       	subi	r30, 0x84	; 132
    7370:	ff 4f       	sbci	r31, 0xFF	; 255
    7372:	80 e9       	ldi	r24, 0x90	; 144
    7374:	91 e0       	ldi	r25, 0x01	; 1
    7376:	91 83       	std	Z+1, r25	; 0x01
    7378:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    737a:	fe 01       	movw	r30, r28
    737c:	e4 58       	subi	r30, 0x84	; 132
    737e:	ff 4f       	sbci	r31, 0xFF	; 255
    7380:	80 81       	ld	r24, Z
    7382:	91 81       	ldd	r25, Z+1	; 0x01
    7384:	01 97       	sbiw	r24, 0x01	; 1
    7386:	f1 f7       	brne	.-4      	; 0x7384 <LCD_function_set_4bit+0x40a>
    7388:	fe 01       	movw	r30, r28
    738a:	e4 58       	subi	r30, 0x84	; 132
    738c:	ff 4f       	sbci	r31, 0xFF	; 255
    738e:	91 83       	std	Z+1, r25	; 0x01
    7390:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7392:	de 01       	movw	r26, r28
    7394:	a2 58       	subi	r26, 0x82	; 130
    7396:	bf 4f       	sbci	r27, 0xFF	; 255
    7398:	fe 01       	movw	r30, r28
    739a:	e2 58       	subi	r30, 0x82	; 130
    739c:	ff 4f       	sbci	r31, 0xFF	; 255
    739e:	80 81       	ld	r24, Z
    73a0:	91 81       	ldd	r25, Z+1	; 0x01
    73a2:	01 97       	sbiw	r24, 0x01	; 1
    73a4:	11 96       	adiw	r26, 0x01	; 1
    73a6:	9c 93       	st	X, r25
    73a8:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    73aa:	fe 01       	movw	r30, r28
    73ac:	e2 58       	subi	r30, 0x82	; 130
    73ae:	ff 4f       	sbci	r31, 0xFF	; 255
    73b0:	80 81       	ld	r24, Z
    73b2:	91 81       	ldd	r25, Z+1	; 0x01
    73b4:	00 97       	sbiw	r24, 0x00	; 0
    73b6:	d1 f6       	brne	.-76     	; 0x736c <LCD_function_set_4bit+0x3f2>
    73b8:	4b c0       	rjmp	.+150    	; 0x7450 <LCD_function_set_4bit+0x4d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    73ba:	8e 01       	movw	r16, r28
    73bc:	02 58       	subi	r16, 0x82	; 130
    73be:	1f 4f       	sbci	r17, 0xFF	; 255
    73c0:	fe 01       	movw	r30, r28
    73c2:	e0 58       	subi	r30, 0x80	; 128
    73c4:	ff 4f       	sbci	r31, 0xFF	; 255
    73c6:	60 81       	ld	r22, Z
    73c8:	71 81       	ldd	r23, Z+1	; 0x01
    73ca:	82 81       	ldd	r24, Z+2	; 0x02
    73cc:	93 81       	ldd	r25, Z+3	; 0x03
    73ce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    73d2:	dc 01       	movw	r26, r24
    73d4:	cb 01       	movw	r24, r22
    73d6:	f8 01       	movw	r30, r16
    73d8:	91 83       	std	Z+1, r25	; 0x01
    73da:	80 83       	st	Z, r24
    73dc:	de 01       	movw	r26, r28
    73de:	a6 58       	subi	r26, 0x86	; 134
    73e0:	bf 4f       	sbci	r27, 0xFF	; 255
    73e2:	fe 01       	movw	r30, r28
    73e4:	e2 58       	subi	r30, 0x82	; 130
    73e6:	ff 4f       	sbci	r31, 0xFF	; 255
    73e8:	80 81       	ld	r24, Z
    73ea:	91 81       	ldd	r25, Z+1	; 0x01
    73ec:	11 96       	adiw	r26, 0x01	; 1
    73ee:	9c 93       	st	X, r25
    73f0:	8e 93       	st	-X, r24
    73f2:	fe 01       	movw	r30, r28
    73f4:	e6 58       	subi	r30, 0x86	; 134
    73f6:	ff 4f       	sbci	r31, 0xFF	; 255
    73f8:	80 81       	ld	r24, Z
    73fa:	91 81       	ldd	r25, Z+1	; 0x01
    73fc:	01 97       	sbiw	r24, 0x01	; 1
    73fe:	f1 f7       	brne	.-4      	; 0x73fc <LCD_function_set_4bit+0x482>
    7400:	fe 01       	movw	r30, r28
    7402:	e6 58       	subi	r30, 0x86	; 134
    7404:	ff 4f       	sbci	r31, 0xFF	; 255
    7406:	91 83       	std	Z+1, r25	; 0x01
    7408:	80 83       	st	Z, r24
    740a:	22 c0       	rjmp	.+68     	; 0x7450 <LCD_function_set_4bit+0x4d6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    740c:	8e 01       	movw	r16, r28
    740e:	08 57       	subi	r16, 0x78	; 120
    7410:	1f 4f       	sbci	r17, 0xFF	; 255
    7412:	fe 01       	movw	r30, r28
    7414:	e7 57       	subi	r30, 0x77	; 119
    7416:	ff 4f       	sbci	r31, 0xFF	; 255
    7418:	60 81       	ld	r22, Z
    741a:	71 81       	ldd	r23, Z+1	; 0x01
    741c:	82 81       	ldd	r24, Z+2	; 0x02
    741e:	93 81       	ldd	r25, Z+3	; 0x03
    7420:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7424:	dc 01       	movw	r26, r24
    7426:	cb 01       	movw	r24, r22
    7428:	f8 01       	movw	r30, r16
    742a:	80 83       	st	Z, r24
    742c:	de 01       	movw	r26, r28
    742e:	a7 58       	subi	r26, 0x87	; 135
    7430:	bf 4f       	sbci	r27, 0xFF	; 255
    7432:	fe 01       	movw	r30, r28
    7434:	e8 57       	subi	r30, 0x78	; 120
    7436:	ff 4f       	sbci	r31, 0xFF	; 255
    7438:	80 81       	ld	r24, Z
    743a:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    743c:	fe 01       	movw	r30, r28
    743e:	e7 58       	subi	r30, 0x87	; 135
    7440:	ff 4f       	sbci	r31, 0xFF	; 255
    7442:	80 81       	ld	r24, Z
    7444:	8a 95       	dec	r24
    7446:	f1 f7       	brne	.-4      	; 0x7444 <LCD_function_set_4bit+0x4ca>
    7448:	fe 01       	movw	r30, r28
    744a:	e7 58       	subi	r30, 0x87	; 135
    744c:	ff 4f       	sbci	r31, 0xFF	; 255
    744e:	80 83       	st	Z, r24
	_delay_us(1);
	// Sent the higher nipple
	for(u8 i= 0; i< 4; i++)
    7450:	fe 01       	movw	r30, r28
    7452:	e5 55       	subi	r30, 0x55	; 85
    7454:	ff 4f       	sbci	r31, 0xFF	; 255
    7456:	10 82       	st	Z, r1
    7458:	23 c0       	rjmp	.+70     	; 0x74a0 <LCD_function_set_4bit+0x526>
		DIO_void_assign_pin(lcd_data_port, i+4, get_bit(0b0010, i));
    745a:	fe 01       	movw	r30, r28
    745c:	e5 55       	subi	r30, 0x55	; 85
    745e:	ff 4f       	sbci	r31, 0xFF	; 255
    7460:	80 81       	ld	r24, Z
    7462:	48 2f       	mov	r20, r24
    7464:	4c 5f       	subi	r20, 0xFC	; 252
    7466:	fe 01       	movw	r30, r28
    7468:	e5 55       	subi	r30, 0x55	; 85
    746a:	ff 4f       	sbci	r31, 0xFF	; 255
    746c:	80 81       	ld	r24, Z
    746e:	28 2f       	mov	r18, r24
    7470:	30 e0       	ldi	r19, 0x00	; 0
    7472:	82 e0       	ldi	r24, 0x02	; 2
    7474:	90 e0       	ldi	r25, 0x00	; 0
    7476:	02 c0       	rjmp	.+4      	; 0x747c <LCD_function_set_4bit+0x502>
    7478:	95 95       	asr	r25
    747a:	87 95       	ror	r24
    747c:	2a 95       	dec	r18
    747e:	e2 f7       	brpl	.-8      	; 0x7478 <LCD_function_set_4bit+0x4fe>
    7480:	98 2f       	mov	r25, r24
    7482:	91 70       	andi	r25, 0x01	; 1
    7484:	82 e0       	ldi	r24, 0x02	; 2
    7486:	64 2f       	mov	r22, r20
    7488:	49 2f       	mov	r20, r25
    748a:	0e 94 6a 27 	call	0x4ed4	; 0x4ed4 <DIO_void_assign_pin>
	_delay_us(1);
	// Enable pin is high to send the packet
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
	_delay_us(1);
	// Sent the higher nipple
	for(u8 i= 0; i< 4; i++)
    748e:	de 01       	movw	r26, r28
    7490:	a5 55       	subi	r26, 0x55	; 85
    7492:	bf 4f       	sbci	r27, 0xFF	; 255
    7494:	fe 01       	movw	r30, r28
    7496:	e5 55       	subi	r30, 0x55	; 85
    7498:	ff 4f       	sbci	r31, 0xFF	; 255
    749a:	80 81       	ld	r24, Z
    749c:	8f 5f       	subi	r24, 0xFF	; 255
    749e:	8c 93       	st	X, r24
    74a0:	fe 01       	movw	r30, r28
    74a2:	e5 55       	subi	r30, 0x55	; 85
    74a4:	ff 4f       	sbci	r31, 0xFF	; 255
    74a6:	80 81       	ld	r24, Z
    74a8:	84 30       	cpi	r24, 0x04	; 4
    74aa:	b8 f2       	brcs	.-82     	; 0x745a <LCD_function_set_4bit+0x4e0>
		DIO_void_assign_pin(lcd_data_port, i+4, get_bit(0b0010, i));
	// Enable pin Low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    74ac:	82 e0       	ldi	r24, 0x02	; 2
    74ae:	60 e0       	ldi	r22, 0x00	; 0
    74b0:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    74b4:	fe 01       	movw	r30, r28
    74b6:	eb 58       	subi	r30, 0x8B	; 139
    74b8:	ff 4f       	sbci	r31, 0xFF	; 255
    74ba:	80 e0       	ldi	r24, 0x00	; 0
    74bc:	90 e0       	ldi	r25, 0x00	; 0
    74be:	a0 e2       	ldi	r26, 0x20	; 32
    74c0:	b1 e4       	ldi	r27, 0x41	; 65
    74c2:	80 83       	st	Z, r24
    74c4:	91 83       	std	Z+1, r25	; 0x01
    74c6:	a2 83       	std	Z+2, r26	; 0x02
    74c8:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    74ca:	8e 01       	movw	r16, r28
    74cc:	0f 58       	subi	r16, 0x8F	; 143
    74ce:	1f 4f       	sbci	r17, 0xFF	; 255
    74d0:	fe 01       	movw	r30, r28
    74d2:	eb 58       	subi	r30, 0x8B	; 139
    74d4:	ff 4f       	sbci	r31, 0xFF	; 255
    74d6:	60 81       	ld	r22, Z
    74d8:	71 81       	ldd	r23, Z+1	; 0x01
    74da:	82 81       	ldd	r24, Z+2	; 0x02
    74dc:	93 81       	ldd	r25, Z+3	; 0x03
    74de:	2b ea       	ldi	r18, 0xAB	; 171
    74e0:	3a ea       	ldi	r19, 0xAA	; 170
    74e2:	4a ea       	ldi	r20, 0xAA	; 170
    74e4:	50 e4       	ldi	r21, 0x40	; 64
    74e6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    74ea:	dc 01       	movw	r26, r24
    74ec:	cb 01       	movw	r24, r22
    74ee:	f8 01       	movw	r30, r16
    74f0:	80 83       	st	Z, r24
    74f2:	91 83       	std	Z+1, r25	; 0x01
    74f4:	a2 83       	std	Z+2, r26	; 0x02
    74f6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    74f8:	fe 01       	movw	r30, r28
    74fa:	ef 58       	subi	r30, 0x8F	; 143
    74fc:	ff 4f       	sbci	r31, 0xFF	; 255
    74fe:	60 81       	ld	r22, Z
    7500:	71 81       	ldd	r23, Z+1	; 0x01
    7502:	82 81       	ldd	r24, Z+2	; 0x02
    7504:	93 81       	ldd	r25, Z+3	; 0x03
    7506:	20 e0       	ldi	r18, 0x00	; 0
    7508:	30 e0       	ldi	r19, 0x00	; 0
    750a:	40 e8       	ldi	r20, 0x80	; 128
    750c:	5f e3       	ldi	r21, 0x3F	; 63
    750e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7512:	88 23       	and	r24, r24
    7514:	34 f4       	brge	.+12     	; 0x7522 <LCD_function_set_4bit+0x5a8>
		__ticks = 1;
    7516:	fe 01       	movw	r30, r28
    7518:	e0 59       	subi	r30, 0x90	; 144
    751a:	ff 4f       	sbci	r31, 0xFF	; 255
    751c:	81 e0       	ldi	r24, 0x01	; 1
    751e:	80 83       	st	Z, r24
    7520:	e0 c0       	rjmp	.+448    	; 0x76e2 <LCD_function_set_4bit+0x768>
	else if (__tmp > 255)
    7522:	fe 01       	movw	r30, r28
    7524:	ef 58       	subi	r30, 0x8F	; 143
    7526:	ff 4f       	sbci	r31, 0xFF	; 255
    7528:	60 81       	ld	r22, Z
    752a:	71 81       	ldd	r23, Z+1	; 0x01
    752c:	82 81       	ldd	r24, Z+2	; 0x02
    752e:	93 81       	ldd	r25, Z+3	; 0x03
    7530:	20 e0       	ldi	r18, 0x00	; 0
    7532:	30 e0       	ldi	r19, 0x00	; 0
    7534:	4f e7       	ldi	r20, 0x7F	; 127
    7536:	53 e4       	ldi	r21, 0x43	; 67
    7538:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    753c:	18 16       	cp	r1, r24
    753e:	0c f0       	brlt	.+2      	; 0x7542 <LCD_function_set_4bit+0x5c8>
    7540:	c0 c0       	rjmp	.+384    	; 0x76c2 <LCD_function_set_4bit+0x748>
	{
		_delay_ms(__us / 1000.0);
    7542:	fe 01       	movw	r30, r28
    7544:	eb 58       	subi	r30, 0x8B	; 139
    7546:	ff 4f       	sbci	r31, 0xFF	; 255
    7548:	60 81       	ld	r22, Z
    754a:	71 81       	ldd	r23, Z+1	; 0x01
    754c:	82 81       	ldd	r24, Z+2	; 0x02
    754e:	93 81       	ldd	r25, Z+3	; 0x03
    7550:	20 e0       	ldi	r18, 0x00	; 0
    7552:	30 e0       	ldi	r19, 0x00	; 0
    7554:	4a e7       	ldi	r20, 0x7A	; 122
    7556:	54 e4       	ldi	r21, 0x44	; 68
    7558:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    755c:	dc 01       	movw	r26, r24
    755e:	cb 01       	movw	r24, r22
    7560:	fe 01       	movw	r30, r28
    7562:	e4 59       	subi	r30, 0x94	; 148
    7564:	ff 4f       	sbci	r31, 0xFF	; 255
    7566:	80 83       	st	Z, r24
    7568:	91 83       	std	Z+1, r25	; 0x01
    756a:	a2 83       	std	Z+2, r26	; 0x02
    756c:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    756e:	8e 01       	movw	r16, r28
    7570:	08 59       	subi	r16, 0x98	; 152
    7572:	1f 4f       	sbci	r17, 0xFF	; 255
    7574:	fe 01       	movw	r30, r28
    7576:	e4 59       	subi	r30, 0x94	; 148
    7578:	ff 4f       	sbci	r31, 0xFF	; 255
    757a:	60 81       	ld	r22, Z
    757c:	71 81       	ldd	r23, Z+1	; 0x01
    757e:	82 81       	ldd	r24, Z+2	; 0x02
    7580:	93 81       	ldd	r25, Z+3	; 0x03
    7582:	20 e0       	ldi	r18, 0x00	; 0
    7584:	30 e0       	ldi	r19, 0x00	; 0
    7586:	4a e7       	ldi	r20, 0x7A	; 122
    7588:	55 e4       	ldi	r21, 0x45	; 69
    758a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    758e:	dc 01       	movw	r26, r24
    7590:	cb 01       	movw	r24, r22
    7592:	f8 01       	movw	r30, r16
    7594:	80 83       	st	Z, r24
    7596:	91 83       	std	Z+1, r25	; 0x01
    7598:	a2 83       	std	Z+2, r26	; 0x02
    759a:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    759c:	fe 01       	movw	r30, r28
    759e:	e8 59       	subi	r30, 0x98	; 152
    75a0:	ff 4f       	sbci	r31, 0xFF	; 255
    75a2:	60 81       	ld	r22, Z
    75a4:	71 81       	ldd	r23, Z+1	; 0x01
    75a6:	82 81       	ldd	r24, Z+2	; 0x02
    75a8:	93 81       	ldd	r25, Z+3	; 0x03
    75aa:	20 e0       	ldi	r18, 0x00	; 0
    75ac:	30 e0       	ldi	r19, 0x00	; 0
    75ae:	40 e8       	ldi	r20, 0x80	; 128
    75b0:	5f e3       	ldi	r21, 0x3F	; 63
    75b2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    75b6:	88 23       	and	r24, r24
    75b8:	44 f4       	brge	.+16     	; 0x75ca <LCD_function_set_4bit+0x650>
		__ticks = 1;
    75ba:	fe 01       	movw	r30, r28
    75bc:	ea 59       	subi	r30, 0x9A	; 154
    75be:	ff 4f       	sbci	r31, 0xFF	; 255
    75c0:	81 e0       	ldi	r24, 0x01	; 1
    75c2:	90 e0       	ldi	r25, 0x00	; 0
    75c4:	91 83       	std	Z+1, r25	; 0x01
    75c6:	80 83       	st	Z, r24
    75c8:	64 c0       	rjmp	.+200    	; 0x7692 <LCD_function_set_4bit+0x718>
	else if (__tmp > 65535)
    75ca:	fe 01       	movw	r30, r28
    75cc:	e8 59       	subi	r30, 0x98	; 152
    75ce:	ff 4f       	sbci	r31, 0xFF	; 255
    75d0:	60 81       	ld	r22, Z
    75d2:	71 81       	ldd	r23, Z+1	; 0x01
    75d4:	82 81       	ldd	r24, Z+2	; 0x02
    75d6:	93 81       	ldd	r25, Z+3	; 0x03
    75d8:	20 e0       	ldi	r18, 0x00	; 0
    75da:	3f ef       	ldi	r19, 0xFF	; 255
    75dc:	4f e7       	ldi	r20, 0x7F	; 127
    75de:	57 e4       	ldi	r21, 0x47	; 71
    75e0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    75e4:	18 16       	cp	r1, r24
    75e6:	0c f0       	brlt	.+2      	; 0x75ea <LCD_function_set_4bit+0x670>
    75e8:	43 c0       	rjmp	.+134    	; 0x7670 <LCD_function_set_4bit+0x6f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    75ea:	fe 01       	movw	r30, r28
    75ec:	e4 59       	subi	r30, 0x94	; 148
    75ee:	ff 4f       	sbci	r31, 0xFF	; 255
    75f0:	60 81       	ld	r22, Z
    75f2:	71 81       	ldd	r23, Z+1	; 0x01
    75f4:	82 81       	ldd	r24, Z+2	; 0x02
    75f6:	93 81       	ldd	r25, Z+3	; 0x03
    75f8:	20 e0       	ldi	r18, 0x00	; 0
    75fa:	30 e0       	ldi	r19, 0x00	; 0
    75fc:	40 e2       	ldi	r20, 0x20	; 32
    75fe:	51 e4       	ldi	r21, 0x41	; 65
    7600:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7604:	dc 01       	movw	r26, r24
    7606:	cb 01       	movw	r24, r22
    7608:	8e 01       	movw	r16, r28
    760a:	0a 59       	subi	r16, 0x9A	; 154
    760c:	1f 4f       	sbci	r17, 0xFF	; 255
    760e:	bc 01       	movw	r22, r24
    7610:	cd 01       	movw	r24, r26
    7612:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7616:	dc 01       	movw	r26, r24
    7618:	cb 01       	movw	r24, r22
    761a:	f8 01       	movw	r30, r16
    761c:	91 83       	std	Z+1, r25	; 0x01
    761e:	80 83       	st	Z, r24
    7620:	1f c0       	rjmp	.+62     	; 0x7660 <LCD_function_set_4bit+0x6e6>
    7622:	fe 01       	movw	r30, r28
    7624:	ec 59       	subi	r30, 0x9C	; 156
    7626:	ff 4f       	sbci	r31, 0xFF	; 255
    7628:	80 e9       	ldi	r24, 0x90	; 144
    762a:	91 e0       	ldi	r25, 0x01	; 1
    762c:	91 83       	std	Z+1, r25	; 0x01
    762e:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7630:	fe 01       	movw	r30, r28
    7632:	ec 59       	subi	r30, 0x9C	; 156
    7634:	ff 4f       	sbci	r31, 0xFF	; 255
    7636:	80 81       	ld	r24, Z
    7638:	91 81       	ldd	r25, Z+1	; 0x01
    763a:	01 97       	sbiw	r24, 0x01	; 1
    763c:	f1 f7       	brne	.-4      	; 0x763a <LCD_function_set_4bit+0x6c0>
    763e:	fe 01       	movw	r30, r28
    7640:	ec 59       	subi	r30, 0x9C	; 156
    7642:	ff 4f       	sbci	r31, 0xFF	; 255
    7644:	91 83       	std	Z+1, r25	; 0x01
    7646:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7648:	de 01       	movw	r26, r28
    764a:	aa 59       	subi	r26, 0x9A	; 154
    764c:	bf 4f       	sbci	r27, 0xFF	; 255
    764e:	fe 01       	movw	r30, r28
    7650:	ea 59       	subi	r30, 0x9A	; 154
    7652:	ff 4f       	sbci	r31, 0xFF	; 255
    7654:	80 81       	ld	r24, Z
    7656:	91 81       	ldd	r25, Z+1	; 0x01
    7658:	01 97       	sbiw	r24, 0x01	; 1
    765a:	11 96       	adiw	r26, 0x01	; 1
    765c:	9c 93       	st	X, r25
    765e:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7660:	fe 01       	movw	r30, r28
    7662:	ea 59       	subi	r30, 0x9A	; 154
    7664:	ff 4f       	sbci	r31, 0xFF	; 255
    7666:	80 81       	ld	r24, Z
    7668:	91 81       	ldd	r25, Z+1	; 0x01
    766a:	00 97       	sbiw	r24, 0x00	; 0
    766c:	d1 f6       	brne	.-76     	; 0x7622 <LCD_function_set_4bit+0x6a8>
    766e:	4b c0       	rjmp	.+150    	; 0x7706 <LCD_function_set_4bit+0x78c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7670:	8e 01       	movw	r16, r28
    7672:	0a 59       	subi	r16, 0x9A	; 154
    7674:	1f 4f       	sbci	r17, 0xFF	; 255
    7676:	fe 01       	movw	r30, r28
    7678:	e8 59       	subi	r30, 0x98	; 152
    767a:	ff 4f       	sbci	r31, 0xFF	; 255
    767c:	60 81       	ld	r22, Z
    767e:	71 81       	ldd	r23, Z+1	; 0x01
    7680:	82 81       	ldd	r24, Z+2	; 0x02
    7682:	93 81       	ldd	r25, Z+3	; 0x03
    7684:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7688:	dc 01       	movw	r26, r24
    768a:	cb 01       	movw	r24, r22
    768c:	f8 01       	movw	r30, r16
    768e:	91 83       	std	Z+1, r25	; 0x01
    7690:	80 83       	st	Z, r24
    7692:	de 01       	movw	r26, r28
    7694:	ae 59       	subi	r26, 0x9E	; 158
    7696:	bf 4f       	sbci	r27, 0xFF	; 255
    7698:	fe 01       	movw	r30, r28
    769a:	ea 59       	subi	r30, 0x9A	; 154
    769c:	ff 4f       	sbci	r31, 0xFF	; 255
    769e:	80 81       	ld	r24, Z
    76a0:	91 81       	ldd	r25, Z+1	; 0x01
    76a2:	11 96       	adiw	r26, 0x01	; 1
    76a4:	9c 93       	st	X, r25
    76a6:	8e 93       	st	-X, r24
    76a8:	fe 01       	movw	r30, r28
    76aa:	ee 59       	subi	r30, 0x9E	; 158
    76ac:	ff 4f       	sbci	r31, 0xFF	; 255
    76ae:	80 81       	ld	r24, Z
    76b0:	91 81       	ldd	r25, Z+1	; 0x01
    76b2:	01 97       	sbiw	r24, 0x01	; 1
    76b4:	f1 f7       	brne	.-4      	; 0x76b2 <LCD_function_set_4bit+0x738>
    76b6:	fe 01       	movw	r30, r28
    76b8:	ee 59       	subi	r30, 0x9E	; 158
    76ba:	ff 4f       	sbci	r31, 0xFF	; 255
    76bc:	91 83       	std	Z+1, r25	; 0x01
    76be:	80 83       	st	Z, r24
    76c0:	22 c0       	rjmp	.+68     	; 0x7706 <LCD_function_set_4bit+0x78c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    76c2:	8e 01       	movw	r16, r28
    76c4:	00 59       	subi	r16, 0x90	; 144
    76c6:	1f 4f       	sbci	r17, 0xFF	; 255
    76c8:	fe 01       	movw	r30, r28
    76ca:	ef 58       	subi	r30, 0x8F	; 143
    76cc:	ff 4f       	sbci	r31, 0xFF	; 255
    76ce:	60 81       	ld	r22, Z
    76d0:	71 81       	ldd	r23, Z+1	; 0x01
    76d2:	82 81       	ldd	r24, Z+2	; 0x02
    76d4:	93 81       	ldd	r25, Z+3	; 0x03
    76d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    76da:	dc 01       	movw	r26, r24
    76dc:	cb 01       	movw	r24, r22
    76de:	f8 01       	movw	r30, r16
    76e0:	80 83       	st	Z, r24
    76e2:	de 01       	movw	r26, r28
    76e4:	af 59       	subi	r26, 0x9F	; 159
    76e6:	bf 4f       	sbci	r27, 0xFF	; 255
    76e8:	fe 01       	movw	r30, r28
    76ea:	e0 59       	subi	r30, 0x90	; 144
    76ec:	ff 4f       	sbci	r31, 0xFF	; 255
    76ee:	80 81       	ld	r24, Z
    76f0:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    76f2:	fe 01       	movw	r30, r28
    76f4:	ef 59       	subi	r30, 0x9F	; 159
    76f6:	ff 4f       	sbci	r31, 0xFF	; 255
    76f8:	80 81       	ld	r24, Z
    76fa:	8a 95       	dec	r24
    76fc:	f1 f7       	brne	.-4      	; 0x76fa <LCD_function_set_4bit+0x780>
    76fe:	fe 01       	movw	r30, r28
    7700:	ef 59       	subi	r30, 0x9F	; 159
    7702:	ff 4f       	sbci	r31, 0xFF	; 255
    7704:	80 83       	st	Z, r24
	_delay_us(10);
	// Enable pin is high to send the packet
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    7706:	82 e0       	ldi	r24, 0x02	; 2
    7708:	60 e0       	ldi	r22, 0x00	; 0
    770a:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    770e:	fe 01       	movw	r30, r28
    7710:	e3 5a       	subi	r30, 0xA3	; 163
    7712:	ff 4f       	sbci	r31, 0xFF	; 255
    7714:	80 e0       	ldi	r24, 0x00	; 0
    7716:	90 e0       	ldi	r25, 0x00	; 0
    7718:	a0 e8       	ldi	r26, 0x80	; 128
    771a:	bf e3       	ldi	r27, 0x3F	; 63
    771c:	80 83       	st	Z, r24
    771e:	91 83       	std	Z+1, r25	; 0x01
    7720:	a2 83       	std	Z+2, r26	; 0x02
    7722:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    7724:	8e 01       	movw	r16, r28
    7726:	07 5a       	subi	r16, 0xA7	; 167
    7728:	1f 4f       	sbci	r17, 0xFF	; 255
    772a:	fe 01       	movw	r30, r28
    772c:	e3 5a       	subi	r30, 0xA3	; 163
    772e:	ff 4f       	sbci	r31, 0xFF	; 255
    7730:	60 81       	ld	r22, Z
    7732:	71 81       	ldd	r23, Z+1	; 0x01
    7734:	82 81       	ldd	r24, Z+2	; 0x02
    7736:	93 81       	ldd	r25, Z+3	; 0x03
    7738:	2b ea       	ldi	r18, 0xAB	; 171
    773a:	3a ea       	ldi	r19, 0xAA	; 170
    773c:	4a ea       	ldi	r20, 0xAA	; 170
    773e:	50 e4       	ldi	r21, 0x40	; 64
    7740:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7744:	dc 01       	movw	r26, r24
    7746:	cb 01       	movw	r24, r22
    7748:	f8 01       	movw	r30, r16
    774a:	80 83       	st	Z, r24
    774c:	91 83       	std	Z+1, r25	; 0x01
    774e:	a2 83       	std	Z+2, r26	; 0x02
    7750:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7752:	fe 01       	movw	r30, r28
    7754:	e7 5a       	subi	r30, 0xA7	; 167
    7756:	ff 4f       	sbci	r31, 0xFF	; 255
    7758:	60 81       	ld	r22, Z
    775a:	71 81       	ldd	r23, Z+1	; 0x01
    775c:	82 81       	ldd	r24, Z+2	; 0x02
    775e:	93 81       	ldd	r25, Z+3	; 0x03
    7760:	20 e0       	ldi	r18, 0x00	; 0
    7762:	30 e0       	ldi	r19, 0x00	; 0
    7764:	40 e8       	ldi	r20, 0x80	; 128
    7766:	5f e3       	ldi	r21, 0x3F	; 63
    7768:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    776c:	88 23       	and	r24, r24
    776e:	34 f4       	brge	.+12     	; 0x777c <LCD_function_set_4bit+0x802>
		__ticks = 1;
    7770:	fe 01       	movw	r30, r28
    7772:	e8 5a       	subi	r30, 0xA8	; 168
    7774:	ff 4f       	sbci	r31, 0xFF	; 255
    7776:	81 e0       	ldi	r24, 0x01	; 1
    7778:	80 83       	st	Z, r24
    777a:	e0 c0       	rjmp	.+448    	; 0x793c <LCD_function_set_4bit+0x9c2>
	else if (__tmp > 255)
    777c:	fe 01       	movw	r30, r28
    777e:	e7 5a       	subi	r30, 0xA7	; 167
    7780:	ff 4f       	sbci	r31, 0xFF	; 255
    7782:	60 81       	ld	r22, Z
    7784:	71 81       	ldd	r23, Z+1	; 0x01
    7786:	82 81       	ldd	r24, Z+2	; 0x02
    7788:	93 81       	ldd	r25, Z+3	; 0x03
    778a:	20 e0       	ldi	r18, 0x00	; 0
    778c:	30 e0       	ldi	r19, 0x00	; 0
    778e:	4f e7       	ldi	r20, 0x7F	; 127
    7790:	53 e4       	ldi	r21, 0x43	; 67
    7792:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7796:	18 16       	cp	r1, r24
    7798:	0c f0       	brlt	.+2      	; 0x779c <LCD_function_set_4bit+0x822>
    779a:	c0 c0       	rjmp	.+384    	; 0x791c <LCD_function_set_4bit+0x9a2>
	{
		_delay_ms(__us / 1000.0);
    779c:	fe 01       	movw	r30, r28
    779e:	e3 5a       	subi	r30, 0xA3	; 163
    77a0:	ff 4f       	sbci	r31, 0xFF	; 255
    77a2:	60 81       	ld	r22, Z
    77a4:	71 81       	ldd	r23, Z+1	; 0x01
    77a6:	82 81       	ldd	r24, Z+2	; 0x02
    77a8:	93 81       	ldd	r25, Z+3	; 0x03
    77aa:	20 e0       	ldi	r18, 0x00	; 0
    77ac:	30 e0       	ldi	r19, 0x00	; 0
    77ae:	4a e7       	ldi	r20, 0x7A	; 122
    77b0:	54 e4       	ldi	r21, 0x44	; 68
    77b2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    77b6:	dc 01       	movw	r26, r24
    77b8:	cb 01       	movw	r24, r22
    77ba:	fe 01       	movw	r30, r28
    77bc:	ec 5a       	subi	r30, 0xAC	; 172
    77be:	ff 4f       	sbci	r31, 0xFF	; 255
    77c0:	80 83       	st	Z, r24
    77c2:	91 83       	std	Z+1, r25	; 0x01
    77c4:	a2 83       	std	Z+2, r26	; 0x02
    77c6:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    77c8:	8e 01       	movw	r16, r28
    77ca:	00 5b       	subi	r16, 0xB0	; 176
    77cc:	1f 4f       	sbci	r17, 0xFF	; 255
    77ce:	fe 01       	movw	r30, r28
    77d0:	ec 5a       	subi	r30, 0xAC	; 172
    77d2:	ff 4f       	sbci	r31, 0xFF	; 255
    77d4:	60 81       	ld	r22, Z
    77d6:	71 81       	ldd	r23, Z+1	; 0x01
    77d8:	82 81       	ldd	r24, Z+2	; 0x02
    77da:	93 81       	ldd	r25, Z+3	; 0x03
    77dc:	20 e0       	ldi	r18, 0x00	; 0
    77de:	30 e0       	ldi	r19, 0x00	; 0
    77e0:	4a e7       	ldi	r20, 0x7A	; 122
    77e2:	55 e4       	ldi	r21, 0x45	; 69
    77e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    77e8:	dc 01       	movw	r26, r24
    77ea:	cb 01       	movw	r24, r22
    77ec:	f8 01       	movw	r30, r16
    77ee:	80 83       	st	Z, r24
    77f0:	91 83       	std	Z+1, r25	; 0x01
    77f2:	a2 83       	std	Z+2, r26	; 0x02
    77f4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    77f6:	fe 01       	movw	r30, r28
    77f8:	e0 5b       	subi	r30, 0xB0	; 176
    77fa:	ff 4f       	sbci	r31, 0xFF	; 255
    77fc:	60 81       	ld	r22, Z
    77fe:	71 81       	ldd	r23, Z+1	; 0x01
    7800:	82 81       	ldd	r24, Z+2	; 0x02
    7802:	93 81       	ldd	r25, Z+3	; 0x03
    7804:	20 e0       	ldi	r18, 0x00	; 0
    7806:	30 e0       	ldi	r19, 0x00	; 0
    7808:	40 e8       	ldi	r20, 0x80	; 128
    780a:	5f e3       	ldi	r21, 0x3F	; 63
    780c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7810:	88 23       	and	r24, r24
    7812:	44 f4       	brge	.+16     	; 0x7824 <LCD_function_set_4bit+0x8aa>
		__ticks = 1;
    7814:	fe 01       	movw	r30, r28
    7816:	e2 5b       	subi	r30, 0xB2	; 178
    7818:	ff 4f       	sbci	r31, 0xFF	; 255
    781a:	81 e0       	ldi	r24, 0x01	; 1
    781c:	90 e0       	ldi	r25, 0x00	; 0
    781e:	91 83       	std	Z+1, r25	; 0x01
    7820:	80 83       	st	Z, r24
    7822:	64 c0       	rjmp	.+200    	; 0x78ec <LCD_function_set_4bit+0x972>
	else if (__tmp > 65535)
    7824:	fe 01       	movw	r30, r28
    7826:	e0 5b       	subi	r30, 0xB0	; 176
    7828:	ff 4f       	sbci	r31, 0xFF	; 255
    782a:	60 81       	ld	r22, Z
    782c:	71 81       	ldd	r23, Z+1	; 0x01
    782e:	82 81       	ldd	r24, Z+2	; 0x02
    7830:	93 81       	ldd	r25, Z+3	; 0x03
    7832:	20 e0       	ldi	r18, 0x00	; 0
    7834:	3f ef       	ldi	r19, 0xFF	; 255
    7836:	4f e7       	ldi	r20, 0x7F	; 127
    7838:	57 e4       	ldi	r21, 0x47	; 71
    783a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    783e:	18 16       	cp	r1, r24
    7840:	0c f0       	brlt	.+2      	; 0x7844 <LCD_function_set_4bit+0x8ca>
    7842:	43 c0       	rjmp	.+134    	; 0x78ca <LCD_function_set_4bit+0x950>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7844:	fe 01       	movw	r30, r28
    7846:	ec 5a       	subi	r30, 0xAC	; 172
    7848:	ff 4f       	sbci	r31, 0xFF	; 255
    784a:	60 81       	ld	r22, Z
    784c:	71 81       	ldd	r23, Z+1	; 0x01
    784e:	82 81       	ldd	r24, Z+2	; 0x02
    7850:	93 81       	ldd	r25, Z+3	; 0x03
    7852:	20 e0       	ldi	r18, 0x00	; 0
    7854:	30 e0       	ldi	r19, 0x00	; 0
    7856:	40 e2       	ldi	r20, 0x20	; 32
    7858:	51 e4       	ldi	r21, 0x41	; 65
    785a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    785e:	dc 01       	movw	r26, r24
    7860:	cb 01       	movw	r24, r22
    7862:	8e 01       	movw	r16, r28
    7864:	02 5b       	subi	r16, 0xB2	; 178
    7866:	1f 4f       	sbci	r17, 0xFF	; 255
    7868:	bc 01       	movw	r22, r24
    786a:	cd 01       	movw	r24, r26
    786c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7870:	dc 01       	movw	r26, r24
    7872:	cb 01       	movw	r24, r22
    7874:	f8 01       	movw	r30, r16
    7876:	91 83       	std	Z+1, r25	; 0x01
    7878:	80 83       	st	Z, r24
    787a:	1f c0       	rjmp	.+62     	; 0x78ba <LCD_function_set_4bit+0x940>
    787c:	fe 01       	movw	r30, r28
    787e:	e4 5b       	subi	r30, 0xB4	; 180
    7880:	ff 4f       	sbci	r31, 0xFF	; 255
    7882:	80 e9       	ldi	r24, 0x90	; 144
    7884:	91 e0       	ldi	r25, 0x01	; 1
    7886:	91 83       	std	Z+1, r25	; 0x01
    7888:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    788a:	fe 01       	movw	r30, r28
    788c:	e4 5b       	subi	r30, 0xB4	; 180
    788e:	ff 4f       	sbci	r31, 0xFF	; 255
    7890:	80 81       	ld	r24, Z
    7892:	91 81       	ldd	r25, Z+1	; 0x01
    7894:	01 97       	sbiw	r24, 0x01	; 1
    7896:	f1 f7       	brne	.-4      	; 0x7894 <LCD_function_set_4bit+0x91a>
    7898:	fe 01       	movw	r30, r28
    789a:	e4 5b       	subi	r30, 0xB4	; 180
    789c:	ff 4f       	sbci	r31, 0xFF	; 255
    789e:	91 83       	std	Z+1, r25	; 0x01
    78a0:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    78a2:	de 01       	movw	r26, r28
    78a4:	a2 5b       	subi	r26, 0xB2	; 178
    78a6:	bf 4f       	sbci	r27, 0xFF	; 255
    78a8:	fe 01       	movw	r30, r28
    78aa:	e2 5b       	subi	r30, 0xB2	; 178
    78ac:	ff 4f       	sbci	r31, 0xFF	; 255
    78ae:	80 81       	ld	r24, Z
    78b0:	91 81       	ldd	r25, Z+1	; 0x01
    78b2:	01 97       	sbiw	r24, 0x01	; 1
    78b4:	11 96       	adiw	r26, 0x01	; 1
    78b6:	9c 93       	st	X, r25
    78b8:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    78ba:	fe 01       	movw	r30, r28
    78bc:	e2 5b       	subi	r30, 0xB2	; 178
    78be:	ff 4f       	sbci	r31, 0xFF	; 255
    78c0:	80 81       	ld	r24, Z
    78c2:	91 81       	ldd	r25, Z+1	; 0x01
    78c4:	00 97       	sbiw	r24, 0x00	; 0
    78c6:	d1 f6       	brne	.-76     	; 0x787c <LCD_function_set_4bit+0x902>
    78c8:	4b c0       	rjmp	.+150    	; 0x7960 <LCD_function_set_4bit+0x9e6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    78ca:	8e 01       	movw	r16, r28
    78cc:	02 5b       	subi	r16, 0xB2	; 178
    78ce:	1f 4f       	sbci	r17, 0xFF	; 255
    78d0:	fe 01       	movw	r30, r28
    78d2:	e0 5b       	subi	r30, 0xB0	; 176
    78d4:	ff 4f       	sbci	r31, 0xFF	; 255
    78d6:	60 81       	ld	r22, Z
    78d8:	71 81       	ldd	r23, Z+1	; 0x01
    78da:	82 81       	ldd	r24, Z+2	; 0x02
    78dc:	93 81       	ldd	r25, Z+3	; 0x03
    78de:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    78e2:	dc 01       	movw	r26, r24
    78e4:	cb 01       	movw	r24, r22
    78e6:	f8 01       	movw	r30, r16
    78e8:	91 83       	std	Z+1, r25	; 0x01
    78ea:	80 83       	st	Z, r24
    78ec:	de 01       	movw	r26, r28
    78ee:	a6 5b       	subi	r26, 0xB6	; 182
    78f0:	bf 4f       	sbci	r27, 0xFF	; 255
    78f2:	fe 01       	movw	r30, r28
    78f4:	e2 5b       	subi	r30, 0xB2	; 178
    78f6:	ff 4f       	sbci	r31, 0xFF	; 255
    78f8:	80 81       	ld	r24, Z
    78fa:	91 81       	ldd	r25, Z+1	; 0x01
    78fc:	11 96       	adiw	r26, 0x01	; 1
    78fe:	9c 93       	st	X, r25
    7900:	8e 93       	st	-X, r24
    7902:	fe 01       	movw	r30, r28
    7904:	e6 5b       	subi	r30, 0xB6	; 182
    7906:	ff 4f       	sbci	r31, 0xFF	; 255
    7908:	80 81       	ld	r24, Z
    790a:	91 81       	ldd	r25, Z+1	; 0x01
    790c:	01 97       	sbiw	r24, 0x01	; 1
    790e:	f1 f7       	brne	.-4      	; 0x790c <LCD_function_set_4bit+0x992>
    7910:	fe 01       	movw	r30, r28
    7912:	e6 5b       	subi	r30, 0xB6	; 182
    7914:	ff 4f       	sbci	r31, 0xFF	; 255
    7916:	91 83       	std	Z+1, r25	; 0x01
    7918:	80 83       	st	Z, r24
    791a:	22 c0       	rjmp	.+68     	; 0x7960 <LCD_function_set_4bit+0x9e6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    791c:	8e 01       	movw	r16, r28
    791e:	08 5a       	subi	r16, 0xA8	; 168
    7920:	1f 4f       	sbci	r17, 0xFF	; 255
    7922:	fe 01       	movw	r30, r28
    7924:	e7 5a       	subi	r30, 0xA7	; 167
    7926:	ff 4f       	sbci	r31, 0xFF	; 255
    7928:	60 81       	ld	r22, Z
    792a:	71 81       	ldd	r23, Z+1	; 0x01
    792c:	82 81       	ldd	r24, Z+2	; 0x02
    792e:	93 81       	ldd	r25, Z+3	; 0x03
    7930:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7934:	dc 01       	movw	r26, r24
    7936:	cb 01       	movw	r24, r22
    7938:	f8 01       	movw	r30, r16
    793a:	80 83       	st	Z, r24
    793c:	de 01       	movw	r26, r28
    793e:	a7 5b       	subi	r26, 0xB7	; 183
    7940:	bf 4f       	sbci	r27, 0xFF	; 255
    7942:	fe 01       	movw	r30, r28
    7944:	e8 5a       	subi	r30, 0xA8	; 168
    7946:	ff 4f       	sbci	r31, 0xFF	; 255
    7948:	80 81       	ld	r24, Z
    794a:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    794c:	fe 01       	movw	r30, r28
    794e:	e7 5b       	subi	r30, 0xB7	; 183
    7950:	ff 4f       	sbci	r31, 0xFF	; 255
    7952:	80 81       	ld	r24, Z
    7954:	8a 95       	dec	r24
    7956:	f1 f7       	brne	.-4      	; 0x7954 <LCD_function_set_4bit+0x9da>
    7958:	fe 01       	movw	r30, r28
    795a:	e7 5b       	subi	r30, 0xB7	; 183
    795c:	ff 4f       	sbci	r31, 0xFF	; 255
    795e:	80 83       	st	Z, r24
	_delay_us(1);
	// Sent the higher nipple again
	for(u8 i= 0; i< 4; i++)
    7960:	fe 01       	movw	r30, r28
    7962:	e6 55       	subi	r30, 0x56	; 86
    7964:	ff 4f       	sbci	r31, 0xFF	; 255
    7966:	10 82       	st	Z, r1
    7968:	23 c0       	rjmp	.+70     	; 0x79b0 <LCD_function_set_4bit+0xa36>
		DIO_void_assign_pin(lcd_data_port, i+4, get_bit(0b0010, i));
    796a:	fe 01       	movw	r30, r28
    796c:	e6 55       	subi	r30, 0x56	; 86
    796e:	ff 4f       	sbci	r31, 0xFF	; 255
    7970:	80 81       	ld	r24, Z
    7972:	48 2f       	mov	r20, r24
    7974:	4c 5f       	subi	r20, 0xFC	; 252
    7976:	fe 01       	movw	r30, r28
    7978:	e6 55       	subi	r30, 0x56	; 86
    797a:	ff 4f       	sbci	r31, 0xFF	; 255
    797c:	80 81       	ld	r24, Z
    797e:	28 2f       	mov	r18, r24
    7980:	30 e0       	ldi	r19, 0x00	; 0
    7982:	82 e0       	ldi	r24, 0x02	; 2
    7984:	90 e0       	ldi	r25, 0x00	; 0
    7986:	02 c0       	rjmp	.+4      	; 0x798c <LCD_function_set_4bit+0xa12>
    7988:	95 95       	asr	r25
    798a:	87 95       	ror	r24
    798c:	2a 95       	dec	r18
    798e:	e2 f7       	brpl	.-8      	; 0x7988 <LCD_function_set_4bit+0xa0e>
    7990:	98 2f       	mov	r25, r24
    7992:	91 70       	andi	r25, 0x01	; 1
    7994:	82 e0       	ldi	r24, 0x02	; 2
    7996:	64 2f       	mov	r22, r20
    7998:	49 2f       	mov	r20, r25
    799a:	0e 94 6a 27 	call	0x4ed4	; 0x4ed4 <DIO_void_assign_pin>
	_delay_us(10);
	// Enable pin is high to send the packet
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
	_delay_us(1);
	// Sent the higher nipple again
	for(u8 i= 0; i< 4; i++)
    799e:	de 01       	movw	r26, r28
    79a0:	a6 55       	subi	r26, 0x56	; 86
    79a2:	bf 4f       	sbci	r27, 0xFF	; 255
    79a4:	fe 01       	movw	r30, r28
    79a6:	e6 55       	subi	r30, 0x56	; 86
    79a8:	ff 4f       	sbci	r31, 0xFF	; 255
    79aa:	80 81       	ld	r24, Z
    79ac:	8f 5f       	subi	r24, 0xFF	; 255
    79ae:	8c 93       	st	X, r24
    79b0:	fe 01       	movw	r30, r28
    79b2:	e6 55       	subi	r30, 0x56	; 86
    79b4:	ff 4f       	sbci	r31, 0xFF	; 255
    79b6:	80 81       	ld	r24, Z
    79b8:	84 30       	cpi	r24, 0x04	; 4
    79ba:	b8 f2       	brcs	.-82     	; 0x796a <LCD_function_set_4bit+0x9f0>
		DIO_void_assign_pin(lcd_data_port, i+4, get_bit(0b0010, i));
	// Enable pin low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    79bc:	82 e0       	ldi	r24, 0x02	; 2
    79be:	60 e0       	ldi	r22, 0x00	; 0
    79c0:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    79c4:	fe 01       	movw	r30, r28
    79c6:	eb 5b       	subi	r30, 0xBB	; 187
    79c8:	ff 4f       	sbci	r31, 0xFF	; 255
    79ca:	80 e0       	ldi	r24, 0x00	; 0
    79cc:	90 e0       	ldi	r25, 0x00	; 0
    79ce:	a0 e2       	ldi	r26, 0x20	; 32
    79d0:	b1 e4       	ldi	r27, 0x41	; 65
    79d2:	80 83       	st	Z, r24
    79d4:	91 83       	std	Z+1, r25	; 0x01
    79d6:	a2 83       	std	Z+2, r26	; 0x02
    79d8:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    79da:	8e 01       	movw	r16, r28
    79dc:	0f 5b       	subi	r16, 0xBF	; 191
    79de:	1f 4f       	sbci	r17, 0xFF	; 255
    79e0:	fe 01       	movw	r30, r28
    79e2:	eb 5b       	subi	r30, 0xBB	; 187
    79e4:	ff 4f       	sbci	r31, 0xFF	; 255
    79e6:	60 81       	ld	r22, Z
    79e8:	71 81       	ldd	r23, Z+1	; 0x01
    79ea:	82 81       	ldd	r24, Z+2	; 0x02
    79ec:	93 81       	ldd	r25, Z+3	; 0x03
    79ee:	2b ea       	ldi	r18, 0xAB	; 171
    79f0:	3a ea       	ldi	r19, 0xAA	; 170
    79f2:	4a ea       	ldi	r20, 0xAA	; 170
    79f4:	50 e4       	ldi	r21, 0x40	; 64
    79f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    79fa:	dc 01       	movw	r26, r24
    79fc:	cb 01       	movw	r24, r22
    79fe:	f8 01       	movw	r30, r16
    7a00:	80 83       	st	Z, r24
    7a02:	91 83       	std	Z+1, r25	; 0x01
    7a04:	a2 83       	std	Z+2, r26	; 0x02
    7a06:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7a08:	fe 01       	movw	r30, r28
    7a0a:	ef 5b       	subi	r30, 0xBF	; 191
    7a0c:	ff 4f       	sbci	r31, 0xFF	; 255
    7a0e:	60 81       	ld	r22, Z
    7a10:	71 81       	ldd	r23, Z+1	; 0x01
    7a12:	82 81       	ldd	r24, Z+2	; 0x02
    7a14:	93 81       	ldd	r25, Z+3	; 0x03
    7a16:	20 e0       	ldi	r18, 0x00	; 0
    7a18:	30 e0       	ldi	r19, 0x00	; 0
    7a1a:	40 e8       	ldi	r20, 0x80	; 128
    7a1c:	5f e3       	ldi	r21, 0x3F	; 63
    7a1e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7a22:	88 23       	and	r24, r24
    7a24:	34 f4       	brge	.+12     	; 0x7a32 <LCD_function_set_4bit+0xab8>
		__ticks = 1;
    7a26:	81 e0       	ldi	r24, 0x01	; 1
    7a28:	fe 01       	movw	r30, r28
    7a2a:	e0 5c       	subi	r30, 0xC0	; 192
    7a2c:	ff 4f       	sbci	r31, 0xFF	; 255
    7a2e:	80 83       	st	Z, r24
    7a30:	9d c0       	rjmp	.+314    	; 0x7b6c <LCD_function_set_4bit+0xbf2>
	else if (__tmp > 255)
    7a32:	fe 01       	movw	r30, r28
    7a34:	ef 5b       	subi	r30, 0xBF	; 191
    7a36:	ff 4f       	sbci	r31, 0xFF	; 255
    7a38:	60 81       	ld	r22, Z
    7a3a:	71 81       	ldd	r23, Z+1	; 0x01
    7a3c:	82 81       	ldd	r24, Z+2	; 0x02
    7a3e:	93 81       	ldd	r25, Z+3	; 0x03
    7a40:	20 e0       	ldi	r18, 0x00	; 0
    7a42:	30 e0       	ldi	r19, 0x00	; 0
    7a44:	4f e7       	ldi	r20, 0x7F	; 127
    7a46:	53 e4       	ldi	r21, 0x43	; 67
    7a48:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7a4c:	18 16       	cp	r1, r24
    7a4e:	0c f0       	brlt	.+2      	; 0x7a52 <LCD_function_set_4bit+0xad8>
    7a50:	7e c0       	rjmp	.+252    	; 0x7b4e <LCD_function_set_4bit+0xbd4>
	{
		_delay_ms(__us / 1000.0);
    7a52:	fe 01       	movw	r30, r28
    7a54:	eb 5b       	subi	r30, 0xBB	; 187
    7a56:	ff 4f       	sbci	r31, 0xFF	; 255
    7a58:	60 81       	ld	r22, Z
    7a5a:	71 81       	ldd	r23, Z+1	; 0x01
    7a5c:	82 81       	ldd	r24, Z+2	; 0x02
    7a5e:	93 81       	ldd	r25, Z+3	; 0x03
    7a60:	20 e0       	ldi	r18, 0x00	; 0
    7a62:	30 e0       	ldi	r19, 0x00	; 0
    7a64:	4a e7       	ldi	r20, 0x7A	; 122
    7a66:	54 e4       	ldi	r21, 0x44	; 68
    7a68:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    7a6c:	dc 01       	movw	r26, r24
    7a6e:	cb 01       	movw	r24, r22
    7a70:	8c af       	std	Y+60, r24	; 0x3c
    7a72:	9d af       	std	Y+61, r25	; 0x3d
    7a74:	ae af       	std	Y+62, r26	; 0x3e
    7a76:	bf af       	std	Y+63, r27	; 0x3f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7a78:	6c ad       	ldd	r22, Y+60	; 0x3c
    7a7a:	7d ad       	ldd	r23, Y+61	; 0x3d
    7a7c:	8e ad       	ldd	r24, Y+62	; 0x3e
    7a7e:	9f ad       	ldd	r25, Y+63	; 0x3f
    7a80:	20 e0       	ldi	r18, 0x00	; 0
    7a82:	30 e0       	ldi	r19, 0x00	; 0
    7a84:	4a e7       	ldi	r20, 0x7A	; 122
    7a86:	55 e4       	ldi	r21, 0x45	; 69
    7a88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7a8c:	dc 01       	movw	r26, r24
    7a8e:	cb 01       	movw	r24, r22
    7a90:	88 af       	std	Y+56, r24	; 0x38
    7a92:	99 af       	std	Y+57, r25	; 0x39
    7a94:	aa af       	std	Y+58, r26	; 0x3a
    7a96:	bb af       	std	Y+59, r27	; 0x3b
	if (__tmp < 1.0)
    7a98:	68 ad       	ldd	r22, Y+56	; 0x38
    7a9a:	79 ad       	ldd	r23, Y+57	; 0x39
    7a9c:	8a ad       	ldd	r24, Y+58	; 0x3a
    7a9e:	9b ad       	ldd	r25, Y+59	; 0x3b
    7aa0:	20 e0       	ldi	r18, 0x00	; 0
    7aa2:	30 e0       	ldi	r19, 0x00	; 0
    7aa4:	40 e8       	ldi	r20, 0x80	; 128
    7aa6:	5f e3       	ldi	r21, 0x3F	; 63
    7aa8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7aac:	88 23       	and	r24, r24
    7aae:	2c f4       	brge	.+10     	; 0x7aba <LCD_function_set_4bit+0xb40>
		__ticks = 1;
    7ab0:	81 e0       	ldi	r24, 0x01	; 1
    7ab2:	90 e0       	ldi	r25, 0x00	; 0
    7ab4:	9f ab       	std	Y+55, r25	; 0x37
    7ab6:	8e ab       	std	Y+54, r24	; 0x36
    7ab8:	3f c0       	rjmp	.+126    	; 0x7b38 <LCD_function_set_4bit+0xbbe>
	else if (__tmp > 65535)
    7aba:	68 ad       	ldd	r22, Y+56	; 0x38
    7abc:	79 ad       	ldd	r23, Y+57	; 0x39
    7abe:	8a ad       	ldd	r24, Y+58	; 0x3a
    7ac0:	9b ad       	ldd	r25, Y+59	; 0x3b
    7ac2:	20 e0       	ldi	r18, 0x00	; 0
    7ac4:	3f ef       	ldi	r19, 0xFF	; 255
    7ac6:	4f e7       	ldi	r20, 0x7F	; 127
    7ac8:	57 e4       	ldi	r21, 0x47	; 71
    7aca:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7ace:	18 16       	cp	r1, r24
    7ad0:	4c f5       	brge	.+82     	; 0x7b24 <LCD_function_set_4bit+0xbaa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7ad2:	6c ad       	ldd	r22, Y+60	; 0x3c
    7ad4:	7d ad       	ldd	r23, Y+61	; 0x3d
    7ad6:	8e ad       	ldd	r24, Y+62	; 0x3e
    7ad8:	9f ad       	ldd	r25, Y+63	; 0x3f
    7ada:	20 e0       	ldi	r18, 0x00	; 0
    7adc:	30 e0       	ldi	r19, 0x00	; 0
    7ade:	40 e2       	ldi	r20, 0x20	; 32
    7ae0:	51 e4       	ldi	r21, 0x41	; 65
    7ae2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7ae6:	dc 01       	movw	r26, r24
    7ae8:	cb 01       	movw	r24, r22
    7aea:	bc 01       	movw	r22, r24
    7aec:	cd 01       	movw	r24, r26
    7aee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7af2:	dc 01       	movw	r26, r24
    7af4:	cb 01       	movw	r24, r22
    7af6:	9f ab       	std	Y+55, r25	; 0x37
    7af8:	8e ab       	std	Y+54, r24	; 0x36
    7afa:	0f c0       	rjmp	.+30     	; 0x7b1a <LCD_function_set_4bit+0xba0>
    7afc:	80 e9       	ldi	r24, 0x90	; 144
    7afe:	91 e0       	ldi	r25, 0x01	; 1
    7b00:	9d ab       	std	Y+53, r25	; 0x35
    7b02:	8c ab       	std	Y+52, r24	; 0x34
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b04:	8c a9       	ldd	r24, Y+52	; 0x34
    7b06:	9d a9       	ldd	r25, Y+53	; 0x35
    7b08:	01 97       	sbiw	r24, 0x01	; 1
    7b0a:	f1 f7       	brne	.-4      	; 0x7b08 <LCD_function_set_4bit+0xb8e>
    7b0c:	9d ab       	std	Y+53, r25	; 0x35
    7b0e:	8c ab       	std	Y+52, r24	; 0x34
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b10:	8e a9       	ldd	r24, Y+54	; 0x36
    7b12:	9f a9       	ldd	r25, Y+55	; 0x37
    7b14:	01 97       	sbiw	r24, 0x01	; 1
    7b16:	9f ab       	std	Y+55, r25	; 0x37
    7b18:	8e ab       	std	Y+54, r24	; 0x36
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b1a:	8e a9       	ldd	r24, Y+54	; 0x36
    7b1c:	9f a9       	ldd	r25, Y+55	; 0x37
    7b1e:	00 97       	sbiw	r24, 0x00	; 0
    7b20:	69 f7       	brne	.-38     	; 0x7afc <LCD_function_set_4bit+0xb82>
    7b22:	2d c0       	rjmp	.+90     	; 0x7b7e <LCD_function_set_4bit+0xc04>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7b24:	68 ad       	ldd	r22, Y+56	; 0x38
    7b26:	79 ad       	ldd	r23, Y+57	; 0x39
    7b28:	8a ad       	ldd	r24, Y+58	; 0x3a
    7b2a:	9b ad       	ldd	r25, Y+59	; 0x3b
    7b2c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7b30:	dc 01       	movw	r26, r24
    7b32:	cb 01       	movw	r24, r22
    7b34:	9f ab       	std	Y+55, r25	; 0x37
    7b36:	8e ab       	std	Y+54, r24	; 0x36
    7b38:	8e a9       	ldd	r24, Y+54	; 0x36
    7b3a:	9f a9       	ldd	r25, Y+55	; 0x37
    7b3c:	9b ab       	std	Y+51, r25	; 0x33
    7b3e:	8a ab       	std	Y+50, r24	; 0x32
    7b40:	8a a9       	ldd	r24, Y+50	; 0x32
    7b42:	9b a9       	ldd	r25, Y+51	; 0x33
    7b44:	01 97       	sbiw	r24, 0x01	; 1
    7b46:	f1 f7       	brne	.-4      	; 0x7b44 <LCD_function_set_4bit+0xbca>
    7b48:	9b ab       	std	Y+51, r25	; 0x33
    7b4a:	8a ab       	std	Y+50, r24	; 0x32
    7b4c:	18 c0       	rjmp	.+48     	; 0x7b7e <LCD_function_set_4bit+0xc04>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7b4e:	fe 01       	movw	r30, r28
    7b50:	ef 5b       	subi	r30, 0xBF	; 191
    7b52:	ff 4f       	sbci	r31, 0xFF	; 255
    7b54:	60 81       	ld	r22, Z
    7b56:	71 81       	ldd	r23, Z+1	; 0x01
    7b58:	82 81       	ldd	r24, Z+2	; 0x02
    7b5a:	93 81       	ldd	r25, Z+3	; 0x03
    7b5c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7b60:	dc 01       	movw	r26, r24
    7b62:	cb 01       	movw	r24, r22
    7b64:	fe 01       	movw	r30, r28
    7b66:	e0 5c       	subi	r30, 0xC0	; 192
    7b68:	ff 4f       	sbci	r31, 0xFF	; 255
    7b6a:	80 83       	st	Z, r24
    7b6c:	fe 01       	movw	r30, r28
    7b6e:	e0 5c       	subi	r30, 0xC0	; 192
    7b70:	ff 4f       	sbci	r31, 0xFF	; 255
    7b72:	80 81       	ld	r24, Z
    7b74:	89 ab       	std	Y+49, r24	; 0x31
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7b76:	89 a9       	ldd	r24, Y+49	; 0x31
    7b78:	8a 95       	dec	r24
    7b7a:	f1 f7       	brne	.-4      	; 0x7b78 <LCD_function_set_4bit+0xbfe>
    7b7c:	89 ab       	std	Y+49, r24	; 0x31
	_delay_us(10);
	// Enable pin is high to send the packet
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    7b7e:	82 e0       	ldi	r24, 0x02	; 2
    7b80:	60 e0       	ldi	r22, 0x00	; 0
    7b82:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    7b86:	80 e0       	ldi	r24, 0x00	; 0
    7b88:	90 e0       	ldi	r25, 0x00	; 0
    7b8a:	a0 e8       	ldi	r26, 0x80	; 128
    7b8c:	bf e3       	ldi	r27, 0x3F	; 63
    7b8e:	8d a7       	std	Y+45, r24	; 0x2d
    7b90:	9e a7       	std	Y+46, r25	; 0x2e
    7b92:	af a7       	std	Y+47, r26	; 0x2f
    7b94:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    7b96:	6d a5       	ldd	r22, Y+45	; 0x2d
    7b98:	7e a5       	ldd	r23, Y+46	; 0x2e
    7b9a:	8f a5       	ldd	r24, Y+47	; 0x2f
    7b9c:	98 a9       	ldd	r25, Y+48	; 0x30
    7b9e:	2b ea       	ldi	r18, 0xAB	; 171
    7ba0:	3a ea       	ldi	r19, 0xAA	; 170
    7ba2:	4a ea       	ldi	r20, 0xAA	; 170
    7ba4:	50 e4       	ldi	r21, 0x40	; 64
    7ba6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7baa:	dc 01       	movw	r26, r24
    7bac:	cb 01       	movw	r24, r22
    7bae:	89 a7       	std	Y+41, r24	; 0x29
    7bb0:	9a a7       	std	Y+42, r25	; 0x2a
    7bb2:	ab a7       	std	Y+43, r26	; 0x2b
    7bb4:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    7bb6:	69 a5       	ldd	r22, Y+41	; 0x29
    7bb8:	7a a5       	ldd	r23, Y+42	; 0x2a
    7bba:	8b a5       	ldd	r24, Y+43	; 0x2b
    7bbc:	9c a5       	ldd	r25, Y+44	; 0x2c
    7bbe:	20 e0       	ldi	r18, 0x00	; 0
    7bc0:	30 e0       	ldi	r19, 0x00	; 0
    7bc2:	40 e8       	ldi	r20, 0x80	; 128
    7bc4:	5f e3       	ldi	r21, 0x3F	; 63
    7bc6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7bca:	88 23       	and	r24, r24
    7bcc:	1c f4       	brge	.+6      	; 0x7bd4 <LCD_function_set_4bit+0xc5a>
		__ticks = 1;
    7bce:	81 e0       	ldi	r24, 0x01	; 1
    7bd0:	88 a7       	std	Y+40, r24	; 0x28
    7bd2:	91 c0       	rjmp	.+290    	; 0x7cf6 <LCD_function_set_4bit+0xd7c>
	else if (__tmp > 255)
    7bd4:	69 a5       	ldd	r22, Y+41	; 0x29
    7bd6:	7a a5       	ldd	r23, Y+42	; 0x2a
    7bd8:	8b a5       	ldd	r24, Y+43	; 0x2b
    7bda:	9c a5       	ldd	r25, Y+44	; 0x2c
    7bdc:	20 e0       	ldi	r18, 0x00	; 0
    7bde:	30 e0       	ldi	r19, 0x00	; 0
    7be0:	4f e7       	ldi	r20, 0x7F	; 127
    7be2:	53 e4       	ldi	r21, 0x43	; 67
    7be4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7be8:	18 16       	cp	r1, r24
    7bea:	0c f0       	brlt	.+2      	; 0x7bee <LCD_function_set_4bit+0xc74>
    7bec:	7b c0       	rjmp	.+246    	; 0x7ce4 <LCD_function_set_4bit+0xd6a>
	{
		_delay_ms(__us / 1000.0);
    7bee:	6d a5       	ldd	r22, Y+45	; 0x2d
    7bf0:	7e a5       	ldd	r23, Y+46	; 0x2e
    7bf2:	8f a5       	ldd	r24, Y+47	; 0x2f
    7bf4:	98 a9       	ldd	r25, Y+48	; 0x30
    7bf6:	20 e0       	ldi	r18, 0x00	; 0
    7bf8:	30 e0       	ldi	r19, 0x00	; 0
    7bfa:	4a e7       	ldi	r20, 0x7A	; 122
    7bfc:	54 e4       	ldi	r21, 0x44	; 68
    7bfe:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    7c02:	dc 01       	movw	r26, r24
    7c04:	cb 01       	movw	r24, r22
    7c06:	8c a3       	std	Y+36, r24	; 0x24
    7c08:	9d a3       	std	Y+37, r25	; 0x25
    7c0a:	ae a3       	std	Y+38, r26	; 0x26
    7c0c:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7c0e:	6c a1       	ldd	r22, Y+36	; 0x24
    7c10:	7d a1       	ldd	r23, Y+37	; 0x25
    7c12:	8e a1       	ldd	r24, Y+38	; 0x26
    7c14:	9f a1       	ldd	r25, Y+39	; 0x27
    7c16:	20 e0       	ldi	r18, 0x00	; 0
    7c18:	30 e0       	ldi	r19, 0x00	; 0
    7c1a:	4a e7       	ldi	r20, 0x7A	; 122
    7c1c:	55 e4       	ldi	r21, 0x45	; 69
    7c1e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7c22:	dc 01       	movw	r26, r24
    7c24:	cb 01       	movw	r24, r22
    7c26:	88 a3       	std	Y+32, r24	; 0x20
    7c28:	99 a3       	std	Y+33, r25	; 0x21
    7c2a:	aa a3       	std	Y+34, r26	; 0x22
    7c2c:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    7c2e:	68 a1       	ldd	r22, Y+32	; 0x20
    7c30:	79 a1       	ldd	r23, Y+33	; 0x21
    7c32:	8a a1       	ldd	r24, Y+34	; 0x22
    7c34:	9b a1       	ldd	r25, Y+35	; 0x23
    7c36:	20 e0       	ldi	r18, 0x00	; 0
    7c38:	30 e0       	ldi	r19, 0x00	; 0
    7c3a:	40 e8       	ldi	r20, 0x80	; 128
    7c3c:	5f e3       	ldi	r21, 0x3F	; 63
    7c3e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7c42:	88 23       	and	r24, r24
    7c44:	2c f4       	brge	.+10     	; 0x7c50 <LCD_function_set_4bit+0xcd6>
		__ticks = 1;
    7c46:	81 e0       	ldi	r24, 0x01	; 1
    7c48:	90 e0       	ldi	r25, 0x00	; 0
    7c4a:	9f 8f       	std	Y+31, r25	; 0x1f
    7c4c:	8e 8f       	std	Y+30, r24	; 0x1e
    7c4e:	3f c0       	rjmp	.+126    	; 0x7cce <LCD_function_set_4bit+0xd54>
	else if (__tmp > 65535)
    7c50:	68 a1       	ldd	r22, Y+32	; 0x20
    7c52:	79 a1       	ldd	r23, Y+33	; 0x21
    7c54:	8a a1       	ldd	r24, Y+34	; 0x22
    7c56:	9b a1       	ldd	r25, Y+35	; 0x23
    7c58:	20 e0       	ldi	r18, 0x00	; 0
    7c5a:	3f ef       	ldi	r19, 0xFF	; 255
    7c5c:	4f e7       	ldi	r20, 0x7F	; 127
    7c5e:	57 e4       	ldi	r21, 0x47	; 71
    7c60:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7c64:	18 16       	cp	r1, r24
    7c66:	4c f5       	brge	.+82     	; 0x7cba <LCD_function_set_4bit+0xd40>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7c68:	6c a1       	ldd	r22, Y+36	; 0x24
    7c6a:	7d a1       	ldd	r23, Y+37	; 0x25
    7c6c:	8e a1       	ldd	r24, Y+38	; 0x26
    7c6e:	9f a1       	ldd	r25, Y+39	; 0x27
    7c70:	20 e0       	ldi	r18, 0x00	; 0
    7c72:	30 e0       	ldi	r19, 0x00	; 0
    7c74:	40 e2       	ldi	r20, 0x20	; 32
    7c76:	51 e4       	ldi	r21, 0x41	; 65
    7c78:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7c7c:	dc 01       	movw	r26, r24
    7c7e:	cb 01       	movw	r24, r22
    7c80:	bc 01       	movw	r22, r24
    7c82:	cd 01       	movw	r24, r26
    7c84:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7c88:	dc 01       	movw	r26, r24
    7c8a:	cb 01       	movw	r24, r22
    7c8c:	9f 8f       	std	Y+31, r25	; 0x1f
    7c8e:	8e 8f       	std	Y+30, r24	; 0x1e
    7c90:	0f c0       	rjmp	.+30     	; 0x7cb0 <LCD_function_set_4bit+0xd36>
    7c92:	80 e9       	ldi	r24, 0x90	; 144
    7c94:	91 e0       	ldi	r25, 0x01	; 1
    7c96:	9d 8f       	std	Y+29, r25	; 0x1d
    7c98:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7c9a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    7c9c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    7c9e:	01 97       	sbiw	r24, 0x01	; 1
    7ca0:	f1 f7       	brne	.-4      	; 0x7c9e <LCD_function_set_4bit+0xd24>
    7ca2:	9d 8f       	std	Y+29, r25	; 0x1d
    7ca4:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7ca6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7ca8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7caa:	01 97       	sbiw	r24, 0x01	; 1
    7cac:	9f 8f       	std	Y+31, r25	; 0x1f
    7cae:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7cb0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7cb2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7cb4:	00 97       	sbiw	r24, 0x00	; 0
    7cb6:	69 f7       	brne	.-38     	; 0x7c92 <LCD_function_set_4bit+0xd18>
    7cb8:	24 c0       	rjmp	.+72     	; 0x7d02 <LCD_function_set_4bit+0xd88>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7cba:	68 a1       	ldd	r22, Y+32	; 0x20
    7cbc:	79 a1       	ldd	r23, Y+33	; 0x21
    7cbe:	8a a1       	ldd	r24, Y+34	; 0x22
    7cc0:	9b a1       	ldd	r25, Y+35	; 0x23
    7cc2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7cc6:	dc 01       	movw	r26, r24
    7cc8:	cb 01       	movw	r24, r22
    7cca:	9f 8f       	std	Y+31, r25	; 0x1f
    7ccc:	8e 8f       	std	Y+30, r24	; 0x1e
    7cce:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7cd0:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7cd2:	9b 8f       	std	Y+27, r25	; 0x1b
    7cd4:	8a 8f       	std	Y+26, r24	; 0x1a
    7cd6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    7cd8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    7cda:	01 97       	sbiw	r24, 0x01	; 1
    7cdc:	f1 f7       	brne	.-4      	; 0x7cda <LCD_function_set_4bit+0xd60>
    7cde:	9b 8f       	std	Y+27, r25	; 0x1b
    7ce0:	8a 8f       	std	Y+26, r24	; 0x1a
    7ce2:	0f c0       	rjmp	.+30     	; 0x7d02 <LCD_function_set_4bit+0xd88>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7ce4:	69 a5       	ldd	r22, Y+41	; 0x29
    7ce6:	7a a5       	ldd	r23, Y+42	; 0x2a
    7ce8:	8b a5       	ldd	r24, Y+43	; 0x2b
    7cea:	9c a5       	ldd	r25, Y+44	; 0x2c
    7cec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7cf0:	dc 01       	movw	r26, r24
    7cf2:	cb 01       	movw	r24, r22
    7cf4:	88 a7       	std	Y+40, r24	; 0x28
    7cf6:	88 a5       	ldd	r24, Y+40	; 0x28
    7cf8:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7cfa:	89 8d       	ldd	r24, Y+25	; 0x19
    7cfc:	8a 95       	dec	r24
    7cfe:	f1 f7       	brne	.-4      	; 0x7cfc <LCD_function_set_4bit+0xd82>
    7d00:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1);
	// Sent the lower nipple
	for(u8 i= 0; i< 4; i++)
    7d02:	fe 01       	movw	r30, r28
    7d04:	e7 55       	subi	r30, 0x57	; 87
    7d06:	ff 4f       	sbci	r31, 0xFF	; 255
    7d08:	10 82       	st	Z, r1
    7d0a:	23 c0       	rjmp	.+70     	; 0x7d52 <LCD_function_set_4bit+0xdd8>
		DIO_void_assign_pin(lcd_data_port, i+4, get_bit(0b1000, i));
    7d0c:	fe 01       	movw	r30, r28
    7d0e:	e7 55       	subi	r30, 0x57	; 87
    7d10:	ff 4f       	sbci	r31, 0xFF	; 255
    7d12:	80 81       	ld	r24, Z
    7d14:	48 2f       	mov	r20, r24
    7d16:	4c 5f       	subi	r20, 0xFC	; 252
    7d18:	fe 01       	movw	r30, r28
    7d1a:	e7 55       	subi	r30, 0x57	; 87
    7d1c:	ff 4f       	sbci	r31, 0xFF	; 255
    7d1e:	80 81       	ld	r24, Z
    7d20:	28 2f       	mov	r18, r24
    7d22:	30 e0       	ldi	r19, 0x00	; 0
    7d24:	88 e0       	ldi	r24, 0x08	; 8
    7d26:	90 e0       	ldi	r25, 0x00	; 0
    7d28:	02 c0       	rjmp	.+4      	; 0x7d2e <LCD_function_set_4bit+0xdb4>
    7d2a:	95 95       	asr	r25
    7d2c:	87 95       	ror	r24
    7d2e:	2a 95       	dec	r18
    7d30:	e2 f7       	brpl	.-8      	; 0x7d2a <LCD_function_set_4bit+0xdb0>
    7d32:	98 2f       	mov	r25, r24
    7d34:	91 70       	andi	r25, 0x01	; 1
    7d36:	82 e0       	ldi	r24, 0x02	; 2
    7d38:	64 2f       	mov	r22, r20
    7d3a:	49 2f       	mov	r20, r25
    7d3c:	0e 94 6a 27 	call	0x4ed4	; 0x4ed4 <DIO_void_assign_pin>
	_delay_us(10);
	// Enable pin is high to send the packet
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
	_delay_us(1);
	// Sent the lower nipple
	for(u8 i= 0; i< 4; i++)
    7d40:	de 01       	movw	r26, r28
    7d42:	a7 55       	subi	r26, 0x57	; 87
    7d44:	bf 4f       	sbci	r27, 0xFF	; 255
    7d46:	fe 01       	movw	r30, r28
    7d48:	e7 55       	subi	r30, 0x57	; 87
    7d4a:	ff 4f       	sbci	r31, 0xFF	; 255
    7d4c:	80 81       	ld	r24, Z
    7d4e:	8f 5f       	subi	r24, 0xFF	; 255
    7d50:	8c 93       	st	X, r24
    7d52:	fe 01       	movw	r30, r28
    7d54:	e7 55       	subi	r30, 0x57	; 87
    7d56:	ff 4f       	sbci	r31, 0xFF	; 255
    7d58:	80 81       	ld	r24, Z
    7d5a:	84 30       	cpi	r24, 0x04	; 4
    7d5c:	b8 f2       	brcs	.-82     	; 0x7d0c <LCD_function_set_4bit+0xd92>
		DIO_void_assign_pin(lcd_data_port, i+4, get_bit(0b1000, i));
	// Enable pin low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    7d5e:	82 e0       	ldi	r24, 0x02	; 2
    7d60:	60 e0       	ldi	r22, 0x00	; 0
    7d62:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    7d66:	80 e0       	ldi	r24, 0x00	; 0
    7d68:	90 e0       	ldi	r25, 0x00	; 0
    7d6a:	a0 e2       	ldi	r26, 0x20	; 32
    7d6c:	b1 e4       	ldi	r27, 0x41	; 65
    7d6e:	8d 8b       	std	Y+21, r24	; 0x15
    7d70:	9e 8b       	std	Y+22, r25	; 0x16
    7d72:	af 8b       	std	Y+23, r26	; 0x17
    7d74:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    7d76:	6d 89       	ldd	r22, Y+21	; 0x15
    7d78:	7e 89       	ldd	r23, Y+22	; 0x16
    7d7a:	8f 89       	ldd	r24, Y+23	; 0x17
    7d7c:	98 8d       	ldd	r25, Y+24	; 0x18
    7d7e:	2b ea       	ldi	r18, 0xAB	; 171
    7d80:	3a ea       	ldi	r19, 0xAA	; 170
    7d82:	4a ea       	ldi	r20, 0xAA	; 170
    7d84:	50 e4       	ldi	r21, 0x40	; 64
    7d86:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7d8a:	dc 01       	movw	r26, r24
    7d8c:	cb 01       	movw	r24, r22
    7d8e:	89 8b       	std	Y+17, r24	; 0x11
    7d90:	9a 8b       	std	Y+18, r25	; 0x12
    7d92:	ab 8b       	std	Y+19, r26	; 0x13
    7d94:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    7d96:	69 89       	ldd	r22, Y+17	; 0x11
    7d98:	7a 89       	ldd	r23, Y+18	; 0x12
    7d9a:	8b 89       	ldd	r24, Y+19	; 0x13
    7d9c:	9c 89       	ldd	r25, Y+20	; 0x14
    7d9e:	20 e0       	ldi	r18, 0x00	; 0
    7da0:	30 e0       	ldi	r19, 0x00	; 0
    7da2:	40 e8       	ldi	r20, 0x80	; 128
    7da4:	5f e3       	ldi	r21, 0x3F	; 63
    7da6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7daa:	88 23       	and	r24, r24
    7dac:	1c f4       	brge	.+6      	; 0x7db4 <LCD_function_set_4bit+0xe3a>
		__ticks = 1;
    7dae:	81 e0       	ldi	r24, 0x01	; 1
    7db0:	88 8b       	std	Y+16, r24	; 0x10
    7db2:	91 c0       	rjmp	.+290    	; 0x7ed6 <LCD_function_set_4bit+0xf5c>
	else if (__tmp > 255)
    7db4:	69 89       	ldd	r22, Y+17	; 0x11
    7db6:	7a 89       	ldd	r23, Y+18	; 0x12
    7db8:	8b 89       	ldd	r24, Y+19	; 0x13
    7dba:	9c 89       	ldd	r25, Y+20	; 0x14
    7dbc:	20 e0       	ldi	r18, 0x00	; 0
    7dbe:	30 e0       	ldi	r19, 0x00	; 0
    7dc0:	4f e7       	ldi	r20, 0x7F	; 127
    7dc2:	53 e4       	ldi	r21, 0x43	; 67
    7dc4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7dc8:	18 16       	cp	r1, r24
    7dca:	0c f0       	brlt	.+2      	; 0x7dce <LCD_function_set_4bit+0xe54>
    7dcc:	7b c0       	rjmp	.+246    	; 0x7ec4 <LCD_function_set_4bit+0xf4a>
	{
		_delay_ms(__us / 1000.0);
    7dce:	6d 89       	ldd	r22, Y+21	; 0x15
    7dd0:	7e 89       	ldd	r23, Y+22	; 0x16
    7dd2:	8f 89       	ldd	r24, Y+23	; 0x17
    7dd4:	98 8d       	ldd	r25, Y+24	; 0x18
    7dd6:	20 e0       	ldi	r18, 0x00	; 0
    7dd8:	30 e0       	ldi	r19, 0x00	; 0
    7dda:	4a e7       	ldi	r20, 0x7A	; 122
    7ddc:	54 e4       	ldi	r21, 0x44	; 68
    7dde:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    7de2:	dc 01       	movw	r26, r24
    7de4:	cb 01       	movw	r24, r22
    7de6:	8c 87       	std	Y+12, r24	; 0x0c
    7de8:	9d 87       	std	Y+13, r25	; 0x0d
    7dea:	ae 87       	std	Y+14, r26	; 0x0e
    7dec:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7dee:	6c 85       	ldd	r22, Y+12	; 0x0c
    7df0:	7d 85       	ldd	r23, Y+13	; 0x0d
    7df2:	8e 85       	ldd	r24, Y+14	; 0x0e
    7df4:	9f 85       	ldd	r25, Y+15	; 0x0f
    7df6:	20 e0       	ldi	r18, 0x00	; 0
    7df8:	30 e0       	ldi	r19, 0x00	; 0
    7dfa:	4a e7       	ldi	r20, 0x7A	; 122
    7dfc:	55 e4       	ldi	r21, 0x45	; 69
    7dfe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7e02:	dc 01       	movw	r26, r24
    7e04:	cb 01       	movw	r24, r22
    7e06:	88 87       	std	Y+8, r24	; 0x08
    7e08:	99 87       	std	Y+9, r25	; 0x09
    7e0a:	aa 87       	std	Y+10, r26	; 0x0a
    7e0c:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    7e0e:	68 85       	ldd	r22, Y+8	; 0x08
    7e10:	79 85       	ldd	r23, Y+9	; 0x09
    7e12:	8a 85       	ldd	r24, Y+10	; 0x0a
    7e14:	9b 85       	ldd	r25, Y+11	; 0x0b
    7e16:	20 e0       	ldi	r18, 0x00	; 0
    7e18:	30 e0       	ldi	r19, 0x00	; 0
    7e1a:	40 e8       	ldi	r20, 0x80	; 128
    7e1c:	5f e3       	ldi	r21, 0x3F	; 63
    7e1e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7e22:	88 23       	and	r24, r24
    7e24:	2c f4       	brge	.+10     	; 0x7e30 <LCD_function_set_4bit+0xeb6>
		__ticks = 1;
    7e26:	81 e0       	ldi	r24, 0x01	; 1
    7e28:	90 e0       	ldi	r25, 0x00	; 0
    7e2a:	9f 83       	std	Y+7, r25	; 0x07
    7e2c:	8e 83       	std	Y+6, r24	; 0x06
    7e2e:	3f c0       	rjmp	.+126    	; 0x7eae <LCD_function_set_4bit+0xf34>
	else if (__tmp > 65535)
    7e30:	68 85       	ldd	r22, Y+8	; 0x08
    7e32:	79 85       	ldd	r23, Y+9	; 0x09
    7e34:	8a 85       	ldd	r24, Y+10	; 0x0a
    7e36:	9b 85       	ldd	r25, Y+11	; 0x0b
    7e38:	20 e0       	ldi	r18, 0x00	; 0
    7e3a:	3f ef       	ldi	r19, 0xFF	; 255
    7e3c:	4f e7       	ldi	r20, 0x7F	; 127
    7e3e:	57 e4       	ldi	r21, 0x47	; 71
    7e40:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7e44:	18 16       	cp	r1, r24
    7e46:	4c f5       	brge	.+82     	; 0x7e9a <LCD_function_set_4bit+0xf20>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7e48:	6c 85       	ldd	r22, Y+12	; 0x0c
    7e4a:	7d 85       	ldd	r23, Y+13	; 0x0d
    7e4c:	8e 85       	ldd	r24, Y+14	; 0x0e
    7e4e:	9f 85       	ldd	r25, Y+15	; 0x0f
    7e50:	20 e0       	ldi	r18, 0x00	; 0
    7e52:	30 e0       	ldi	r19, 0x00	; 0
    7e54:	40 e2       	ldi	r20, 0x20	; 32
    7e56:	51 e4       	ldi	r21, 0x41	; 65
    7e58:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7e5c:	dc 01       	movw	r26, r24
    7e5e:	cb 01       	movw	r24, r22
    7e60:	bc 01       	movw	r22, r24
    7e62:	cd 01       	movw	r24, r26
    7e64:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7e68:	dc 01       	movw	r26, r24
    7e6a:	cb 01       	movw	r24, r22
    7e6c:	9f 83       	std	Y+7, r25	; 0x07
    7e6e:	8e 83       	std	Y+6, r24	; 0x06
    7e70:	0f c0       	rjmp	.+30     	; 0x7e90 <LCD_function_set_4bit+0xf16>
    7e72:	80 e9       	ldi	r24, 0x90	; 144
    7e74:	91 e0       	ldi	r25, 0x01	; 1
    7e76:	9d 83       	std	Y+5, r25	; 0x05
    7e78:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7e7a:	8c 81       	ldd	r24, Y+4	; 0x04
    7e7c:	9d 81       	ldd	r25, Y+5	; 0x05
    7e7e:	01 97       	sbiw	r24, 0x01	; 1
    7e80:	f1 f7       	brne	.-4      	; 0x7e7e <LCD_function_set_4bit+0xf04>
    7e82:	9d 83       	std	Y+5, r25	; 0x05
    7e84:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7e86:	8e 81       	ldd	r24, Y+6	; 0x06
    7e88:	9f 81       	ldd	r25, Y+7	; 0x07
    7e8a:	01 97       	sbiw	r24, 0x01	; 1
    7e8c:	9f 83       	std	Y+7, r25	; 0x07
    7e8e:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7e90:	8e 81       	ldd	r24, Y+6	; 0x06
    7e92:	9f 81       	ldd	r25, Y+7	; 0x07
    7e94:	00 97       	sbiw	r24, 0x00	; 0
    7e96:	69 f7       	brne	.-38     	; 0x7e72 <LCD_function_set_4bit+0xef8>
    7e98:	24 c0       	rjmp	.+72     	; 0x7ee2 <LCD_function_set_4bit+0xf68>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7e9a:	68 85       	ldd	r22, Y+8	; 0x08
    7e9c:	79 85       	ldd	r23, Y+9	; 0x09
    7e9e:	8a 85       	ldd	r24, Y+10	; 0x0a
    7ea0:	9b 85       	ldd	r25, Y+11	; 0x0b
    7ea2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7ea6:	dc 01       	movw	r26, r24
    7ea8:	cb 01       	movw	r24, r22
    7eaa:	9f 83       	std	Y+7, r25	; 0x07
    7eac:	8e 83       	std	Y+6, r24	; 0x06
    7eae:	8e 81       	ldd	r24, Y+6	; 0x06
    7eb0:	9f 81       	ldd	r25, Y+7	; 0x07
    7eb2:	9b 83       	std	Y+3, r25	; 0x03
    7eb4:	8a 83       	std	Y+2, r24	; 0x02
    7eb6:	8a 81       	ldd	r24, Y+2	; 0x02
    7eb8:	9b 81       	ldd	r25, Y+3	; 0x03
    7eba:	01 97       	sbiw	r24, 0x01	; 1
    7ebc:	f1 f7       	brne	.-4      	; 0x7eba <LCD_function_set_4bit+0xf40>
    7ebe:	9b 83       	std	Y+3, r25	; 0x03
    7ec0:	8a 83       	std	Y+2, r24	; 0x02
    7ec2:	0f c0       	rjmp	.+30     	; 0x7ee2 <LCD_function_set_4bit+0xf68>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7ec4:	69 89       	ldd	r22, Y+17	; 0x11
    7ec6:	7a 89       	ldd	r23, Y+18	; 0x12
    7ec8:	8b 89       	ldd	r24, Y+19	; 0x13
    7eca:	9c 89       	ldd	r25, Y+20	; 0x14
    7ecc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7ed0:	dc 01       	movw	r26, r24
    7ed2:	cb 01       	movw	r24, r22
    7ed4:	88 8b       	std	Y+16, r24	; 0x10
    7ed6:	88 89       	ldd	r24, Y+16	; 0x10
    7ed8:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7eda:	89 81       	ldd	r24, Y+1	; 0x01
    7edc:	8a 95       	dec	r24
    7ede:	f1 f7       	brne	.-4      	; 0x7edc <LCD_function_set_4bit+0xf62>
    7ee0:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(10);
}
    7ee2:	c5 55       	subi	r28, 0x55	; 85
    7ee4:	df 4f       	sbci	r29, 0xFF	; 255
    7ee6:	0f b6       	in	r0, 0x3f	; 63
    7ee8:	f8 94       	cli
    7eea:	de bf       	out	0x3e, r29	; 62
    7eec:	0f be       	out	0x3f, r0	; 63
    7eee:	cd bf       	out	0x3d, r28	; 61
    7ef0:	cf 91       	pop	r28
    7ef2:	df 91       	pop	r29
    7ef4:	1f 91       	pop	r17
    7ef6:	0f 91       	pop	r16
    7ef8:	08 95       	ret

00007efa <LCD_read_data_4bit>:

u8 LCD_read_data_4bit(void){
    7efa:	0f 93       	push	r16
    7efc:	1f 93       	push	r17
    7efe:	df 93       	push	r29
    7f00:	cf 93       	push	r28
    7f02:	cd b7       	in	r28, 0x3d	; 61
    7f04:	de b7       	in	r29, 0x3e	; 62
    7f06:	c1 56       	subi	r28, 0x61	; 97
    7f08:	d0 40       	sbci	r29, 0x00	; 0
    7f0a:	0f b6       	in	r0, 0x3f	; 63
    7f0c:	f8 94       	cli
    7f0e:	de bf       	out	0x3e, r29	; 62
    7f10:	0f be       	out	0x3f, r0	; 63
    7f12:	cd bf       	out	0x3d, r28	; 61
	 *	No inputs to the function
	 *
	 *	Function return the current address.
	 */
	// Configure the data pins to input
	DIO_void_set_pin_dir(lcd_data_port, B7, INPUT);
    7f14:	82 e0       	ldi	r24, 0x02	; 2
    7f16:	67 e0       	ldi	r22, 0x07	; 7
    7f18:	40 e0       	ldi	r20, 0x00	; 0
    7f1a:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B6, INPUT);
    7f1e:	82 e0       	ldi	r24, 0x02	; 2
    7f20:	66 e0       	ldi	r22, 0x06	; 6
    7f22:	40 e0       	ldi	r20, 0x00	; 0
    7f24:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B5, INPUT);
    7f28:	82 e0       	ldi	r24, 0x02	; 2
    7f2a:	65 e0       	ldi	r22, 0x05	; 5
    7f2c:	40 e0       	ldi	r20, 0x00	; 0
    7f2e:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B4, INPUT);
    7f32:	82 e0       	ldi	r24, 0x02	; 2
    7f34:	64 e0       	ldi	r22, 0x04	; 4
    7f36:	40 e0       	ldi	r20, 0x00	; 0
    7f38:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	// Configure RS/RW pins to send address
	DIO_void_clear_pin(lcd_ctrl_port, lcd_RS);
    7f3c:	82 e0       	ldi	r24, 0x02	; 2
    7f3e:	62 e0       	ldi	r22, 0x02	; 2
    7f40:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
	DIO_void_set_pin(lcd_ctrl_port, lcd_RW);
    7f44:	82 e0       	ldi	r24, 0x02	; 2
    7f46:	61 e0       	ldi	r22, 0x01	; 1
    7f48:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    7f4c:	fe 01       	movw	r30, r28
    7f4e:	e3 5a       	subi	r30, 0xA3	; 163
    7f50:	ff 4f       	sbci	r31, 0xFF	; 255
    7f52:	80 e0       	ldi	r24, 0x00	; 0
    7f54:	90 e0       	ldi	r25, 0x00	; 0
    7f56:	a0 e8       	ldi	r26, 0x80	; 128
    7f58:	bf e3       	ldi	r27, 0x3F	; 63
    7f5a:	80 83       	st	Z, r24
    7f5c:	91 83       	std	Z+1, r25	; 0x01
    7f5e:	a2 83       	std	Z+2, r26	; 0x02
    7f60:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    7f62:	8e 01       	movw	r16, r28
    7f64:	07 5a       	subi	r16, 0xA7	; 167
    7f66:	1f 4f       	sbci	r17, 0xFF	; 255
    7f68:	fe 01       	movw	r30, r28
    7f6a:	e3 5a       	subi	r30, 0xA3	; 163
    7f6c:	ff 4f       	sbci	r31, 0xFF	; 255
    7f6e:	60 81       	ld	r22, Z
    7f70:	71 81       	ldd	r23, Z+1	; 0x01
    7f72:	82 81       	ldd	r24, Z+2	; 0x02
    7f74:	93 81       	ldd	r25, Z+3	; 0x03
    7f76:	2b ea       	ldi	r18, 0xAB	; 171
    7f78:	3a ea       	ldi	r19, 0xAA	; 170
    7f7a:	4a ea       	ldi	r20, 0xAA	; 170
    7f7c:	50 e4       	ldi	r21, 0x40	; 64
    7f7e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7f82:	dc 01       	movw	r26, r24
    7f84:	cb 01       	movw	r24, r22
    7f86:	f8 01       	movw	r30, r16
    7f88:	80 83       	st	Z, r24
    7f8a:	91 83       	std	Z+1, r25	; 0x01
    7f8c:	a2 83       	std	Z+2, r26	; 0x02
    7f8e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7f90:	fe 01       	movw	r30, r28
    7f92:	e7 5a       	subi	r30, 0xA7	; 167
    7f94:	ff 4f       	sbci	r31, 0xFF	; 255
    7f96:	60 81       	ld	r22, Z
    7f98:	71 81       	ldd	r23, Z+1	; 0x01
    7f9a:	82 81       	ldd	r24, Z+2	; 0x02
    7f9c:	93 81       	ldd	r25, Z+3	; 0x03
    7f9e:	20 e0       	ldi	r18, 0x00	; 0
    7fa0:	30 e0       	ldi	r19, 0x00	; 0
    7fa2:	40 e8       	ldi	r20, 0x80	; 128
    7fa4:	5f e3       	ldi	r21, 0x3F	; 63
    7fa6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7faa:	88 23       	and	r24, r24
    7fac:	34 f4       	brge	.+12     	; 0x7fba <LCD_read_data_4bit+0xc0>
		__ticks = 1;
    7fae:	fe 01       	movw	r30, r28
    7fb0:	e8 5a       	subi	r30, 0xA8	; 168
    7fb2:	ff 4f       	sbci	r31, 0xFF	; 255
    7fb4:	81 e0       	ldi	r24, 0x01	; 1
    7fb6:	80 83       	st	Z, r24
    7fb8:	e0 c0       	rjmp	.+448    	; 0x817a <LCD_read_data_4bit+0x280>
	else if (__tmp > 255)
    7fba:	fe 01       	movw	r30, r28
    7fbc:	e7 5a       	subi	r30, 0xA7	; 167
    7fbe:	ff 4f       	sbci	r31, 0xFF	; 255
    7fc0:	60 81       	ld	r22, Z
    7fc2:	71 81       	ldd	r23, Z+1	; 0x01
    7fc4:	82 81       	ldd	r24, Z+2	; 0x02
    7fc6:	93 81       	ldd	r25, Z+3	; 0x03
    7fc8:	20 e0       	ldi	r18, 0x00	; 0
    7fca:	30 e0       	ldi	r19, 0x00	; 0
    7fcc:	4f e7       	ldi	r20, 0x7F	; 127
    7fce:	53 e4       	ldi	r21, 0x43	; 67
    7fd0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7fd4:	18 16       	cp	r1, r24
    7fd6:	0c f0       	brlt	.+2      	; 0x7fda <LCD_read_data_4bit+0xe0>
    7fd8:	c0 c0       	rjmp	.+384    	; 0x815a <LCD_read_data_4bit+0x260>
	{
		_delay_ms(__us / 1000.0);
    7fda:	fe 01       	movw	r30, r28
    7fdc:	e3 5a       	subi	r30, 0xA3	; 163
    7fde:	ff 4f       	sbci	r31, 0xFF	; 255
    7fe0:	60 81       	ld	r22, Z
    7fe2:	71 81       	ldd	r23, Z+1	; 0x01
    7fe4:	82 81       	ldd	r24, Z+2	; 0x02
    7fe6:	93 81       	ldd	r25, Z+3	; 0x03
    7fe8:	20 e0       	ldi	r18, 0x00	; 0
    7fea:	30 e0       	ldi	r19, 0x00	; 0
    7fec:	4a e7       	ldi	r20, 0x7A	; 122
    7fee:	54 e4       	ldi	r21, 0x44	; 68
    7ff0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    7ff4:	dc 01       	movw	r26, r24
    7ff6:	cb 01       	movw	r24, r22
    7ff8:	fe 01       	movw	r30, r28
    7ffa:	ec 5a       	subi	r30, 0xAC	; 172
    7ffc:	ff 4f       	sbci	r31, 0xFF	; 255
    7ffe:	80 83       	st	Z, r24
    8000:	91 83       	std	Z+1, r25	; 0x01
    8002:	a2 83       	std	Z+2, r26	; 0x02
    8004:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8006:	8e 01       	movw	r16, r28
    8008:	00 5b       	subi	r16, 0xB0	; 176
    800a:	1f 4f       	sbci	r17, 0xFF	; 255
    800c:	fe 01       	movw	r30, r28
    800e:	ec 5a       	subi	r30, 0xAC	; 172
    8010:	ff 4f       	sbci	r31, 0xFF	; 255
    8012:	60 81       	ld	r22, Z
    8014:	71 81       	ldd	r23, Z+1	; 0x01
    8016:	82 81       	ldd	r24, Z+2	; 0x02
    8018:	93 81       	ldd	r25, Z+3	; 0x03
    801a:	20 e0       	ldi	r18, 0x00	; 0
    801c:	30 e0       	ldi	r19, 0x00	; 0
    801e:	4a e7       	ldi	r20, 0x7A	; 122
    8020:	55 e4       	ldi	r21, 0x45	; 69
    8022:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8026:	dc 01       	movw	r26, r24
    8028:	cb 01       	movw	r24, r22
    802a:	f8 01       	movw	r30, r16
    802c:	80 83       	st	Z, r24
    802e:	91 83       	std	Z+1, r25	; 0x01
    8030:	a2 83       	std	Z+2, r26	; 0x02
    8032:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8034:	fe 01       	movw	r30, r28
    8036:	e0 5b       	subi	r30, 0xB0	; 176
    8038:	ff 4f       	sbci	r31, 0xFF	; 255
    803a:	60 81       	ld	r22, Z
    803c:	71 81       	ldd	r23, Z+1	; 0x01
    803e:	82 81       	ldd	r24, Z+2	; 0x02
    8040:	93 81       	ldd	r25, Z+3	; 0x03
    8042:	20 e0       	ldi	r18, 0x00	; 0
    8044:	30 e0       	ldi	r19, 0x00	; 0
    8046:	40 e8       	ldi	r20, 0x80	; 128
    8048:	5f e3       	ldi	r21, 0x3F	; 63
    804a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    804e:	88 23       	and	r24, r24
    8050:	44 f4       	brge	.+16     	; 0x8062 <LCD_read_data_4bit+0x168>
		__ticks = 1;
    8052:	fe 01       	movw	r30, r28
    8054:	e2 5b       	subi	r30, 0xB2	; 178
    8056:	ff 4f       	sbci	r31, 0xFF	; 255
    8058:	81 e0       	ldi	r24, 0x01	; 1
    805a:	90 e0       	ldi	r25, 0x00	; 0
    805c:	91 83       	std	Z+1, r25	; 0x01
    805e:	80 83       	st	Z, r24
    8060:	64 c0       	rjmp	.+200    	; 0x812a <LCD_read_data_4bit+0x230>
	else if (__tmp > 65535)
    8062:	fe 01       	movw	r30, r28
    8064:	e0 5b       	subi	r30, 0xB0	; 176
    8066:	ff 4f       	sbci	r31, 0xFF	; 255
    8068:	60 81       	ld	r22, Z
    806a:	71 81       	ldd	r23, Z+1	; 0x01
    806c:	82 81       	ldd	r24, Z+2	; 0x02
    806e:	93 81       	ldd	r25, Z+3	; 0x03
    8070:	20 e0       	ldi	r18, 0x00	; 0
    8072:	3f ef       	ldi	r19, 0xFF	; 255
    8074:	4f e7       	ldi	r20, 0x7F	; 127
    8076:	57 e4       	ldi	r21, 0x47	; 71
    8078:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    807c:	18 16       	cp	r1, r24
    807e:	0c f0       	brlt	.+2      	; 0x8082 <LCD_read_data_4bit+0x188>
    8080:	43 c0       	rjmp	.+134    	; 0x8108 <LCD_read_data_4bit+0x20e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8082:	fe 01       	movw	r30, r28
    8084:	ec 5a       	subi	r30, 0xAC	; 172
    8086:	ff 4f       	sbci	r31, 0xFF	; 255
    8088:	60 81       	ld	r22, Z
    808a:	71 81       	ldd	r23, Z+1	; 0x01
    808c:	82 81       	ldd	r24, Z+2	; 0x02
    808e:	93 81       	ldd	r25, Z+3	; 0x03
    8090:	20 e0       	ldi	r18, 0x00	; 0
    8092:	30 e0       	ldi	r19, 0x00	; 0
    8094:	40 e2       	ldi	r20, 0x20	; 32
    8096:	51 e4       	ldi	r21, 0x41	; 65
    8098:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    809c:	dc 01       	movw	r26, r24
    809e:	cb 01       	movw	r24, r22
    80a0:	8e 01       	movw	r16, r28
    80a2:	02 5b       	subi	r16, 0xB2	; 178
    80a4:	1f 4f       	sbci	r17, 0xFF	; 255
    80a6:	bc 01       	movw	r22, r24
    80a8:	cd 01       	movw	r24, r26
    80aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    80ae:	dc 01       	movw	r26, r24
    80b0:	cb 01       	movw	r24, r22
    80b2:	f8 01       	movw	r30, r16
    80b4:	91 83       	std	Z+1, r25	; 0x01
    80b6:	80 83       	st	Z, r24
    80b8:	1f c0       	rjmp	.+62     	; 0x80f8 <LCD_read_data_4bit+0x1fe>
    80ba:	fe 01       	movw	r30, r28
    80bc:	e4 5b       	subi	r30, 0xB4	; 180
    80be:	ff 4f       	sbci	r31, 0xFF	; 255
    80c0:	80 e9       	ldi	r24, 0x90	; 144
    80c2:	91 e0       	ldi	r25, 0x01	; 1
    80c4:	91 83       	std	Z+1, r25	; 0x01
    80c6:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    80c8:	fe 01       	movw	r30, r28
    80ca:	e4 5b       	subi	r30, 0xB4	; 180
    80cc:	ff 4f       	sbci	r31, 0xFF	; 255
    80ce:	80 81       	ld	r24, Z
    80d0:	91 81       	ldd	r25, Z+1	; 0x01
    80d2:	01 97       	sbiw	r24, 0x01	; 1
    80d4:	f1 f7       	brne	.-4      	; 0x80d2 <LCD_read_data_4bit+0x1d8>
    80d6:	fe 01       	movw	r30, r28
    80d8:	e4 5b       	subi	r30, 0xB4	; 180
    80da:	ff 4f       	sbci	r31, 0xFF	; 255
    80dc:	91 83       	std	Z+1, r25	; 0x01
    80de:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    80e0:	de 01       	movw	r26, r28
    80e2:	a2 5b       	subi	r26, 0xB2	; 178
    80e4:	bf 4f       	sbci	r27, 0xFF	; 255
    80e6:	fe 01       	movw	r30, r28
    80e8:	e2 5b       	subi	r30, 0xB2	; 178
    80ea:	ff 4f       	sbci	r31, 0xFF	; 255
    80ec:	80 81       	ld	r24, Z
    80ee:	91 81       	ldd	r25, Z+1	; 0x01
    80f0:	01 97       	sbiw	r24, 0x01	; 1
    80f2:	11 96       	adiw	r26, 0x01	; 1
    80f4:	9c 93       	st	X, r25
    80f6:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    80f8:	fe 01       	movw	r30, r28
    80fa:	e2 5b       	subi	r30, 0xB2	; 178
    80fc:	ff 4f       	sbci	r31, 0xFF	; 255
    80fe:	80 81       	ld	r24, Z
    8100:	91 81       	ldd	r25, Z+1	; 0x01
    8102:	00 97       	sbiw	r24, 0x00	; 0
    8104:	d1 f6       	brne	.-76     	; 0x80ba <LCD_read_data_4bit+0x1c0>
    8106:	4b c0       	rjmp	.+150    	; 0x819e <LCD_read_data_4bit+0x2a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8108:	8e 01       	movw	r16, r28
    810a:	02 5b       	subi	r16, 0xB2	; 178
    810c:	1f 4f       	sbci	r17, 0xFF	; 255
    810e:	fe 01       	movw	r30, r28
    8110:	e0 5b       	subi	r30, 0xB0	; 176
    8112:	ff 4f       	sbci	r31, 0xFF	; 255
    8114:	60 81       	ld	r22, Z
    8116:	71 81       	ldd	r23, Z+1	; 0x01
    8118:	82 81       	ldd	r24, Z+2	; 0x02
    811a:	93 81       	ldd	r25, Z+3	; 0x03
    811c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8120:	dc 01       	movw	r26, r24
    8122:	cb 01       	movw	r24, r22
    8124:	f8 01       	movw	r30, r16
    8126:	91 83       	std	Z+1, r25	; 0x01
    8128:	80 83       	st	Z, r24
    812a:	de 01       	movw	r26, r28
    812c:	a6 5b       	subi	r26, 0xB6	; 182
    812e:	bf 4f       	sbci	r27, 0xFF	; 255
    8130:	fe 01       	movw	r30, r28
    8132:	e2 5b       	subi	r30, 0xB2	; 178
    8134:	ff 4f       	sbci	r31, 0xFF	; 255
    8136:	80 81       	ld	r24, Z
    8138:	91 81       	ldd	r25, Z+1	; 0x01
    813a:	11 96       	adiw	r26, 0x01	; 1
    813c:	9c 93       	st	X, r25
    813e:	8e 93       	st	-X, r24
    8140:	fe 01       	movw	r30, r28
    8142:	e6 5b       	subi	r30, 0xB6	; 182
    8144:	ff 4f       	sbci	r31, 0xFF	; 255
    8146:	80 81       	ld	r24, Z
    8148:	91 81       	ldd	r25, Z+1	; 0x01
    814a:	01 97       	sbiw	r24, 0x01	; 1
    814c:	f1 f7       	brne	.-4      	; 0x814a <LCD_read_data_4bit+0x250>
    814e:	fe 01       	movw	r30, r28
    8150:	e6 5b       	subi	r30, 0xB6	; 182
    8152:	ff 4f       	sbci	r31, 0xFF	; 255
    8154:	91 83       	std	Z+1, r25	; 0x01
    8156:	80 83       	st	Z, r24
    8158:	22 c0       	rjmp	.+68     	; 0x819e <LCD_read_data_4bit+0x2a4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    815a:	8e 01       	movw	r16, r28
    815c:	08 5a       	subi	r16, 0xA8	; 168
    815e:	1f 4f       	sbci	r17, 0xFF	; 255
    8160:	fe 01       	movw	r30, r28
    8162:	e7 5a       	subi	r30, 0xA7	; 167
    8164:	ff 4f       	sbci	r31, 0xFF	; 255
    8166:	60 81       	ld	r22, Z
    8168:	71 81       	ldd	r23, Z+1	; 0x01
    816a:	82 81       	ldd	r24, Z+2	; 0x02
    816c:	93 81       	ldd	r25, Z+3	; 0x03
    816e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8172:	dc 01       	movw	r26, r24
    8174:	cb 01       	movw	r24, r22
    8176:	f8 01       	movw	r30, r16
    8178:	80 83       	st	Z, r24
    817a:	de 01       	movw	r26, r28
    817c:	a7 5b       	subi	r26, 0xB7	; 183
    817e:	bf 4f       	sbci	r27, 0xFF	; 255
    8180:	fe 01       	movw	r30, r28
    8182:	e8 5a       	subi	r30, 0xA8	; 168
    8184:	ff 4f       	sbci	r31, 0xFF	; 255
    8186:	80 81       	ld	r24, Z
    8188:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    818a:	fe 01       	movw	r30, r28
    818c:	e7 5b       	subi	r30, 0xB7	; 183
    818e:	ff 4f       	sbci	r31, 0xFF	; 255
    8190:	80 81       	ld	r24, Z
    8192:	8a 95       	dec	r24
    8194:	f1 f7       	brne	.-4      	; 0x8192 <LCD_read_data_4bit+0x298>
    8196:	fe 01       	movw	r30, r28
    8198:	e7 5b       	subi	r30, 0xB7	; 183
    819a:	ff 4f       	sbci	r31, 0xFF	; 255
    819c:	80 83       	st	Z, r24
	_delay_us(1);
	// Enable pin is high to recive the higher nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    819e:	82 e0       	ldi	r24, 0x02	; 2
    81a0:	60 e0       	ldi	r22, 0x00	; 0
    81a2:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    81a6:	fe 01       	movw	r30, r28
    81a8:	eb 5b       	subi	r30, 0xBB	; 187
    81aa:	ff 4f       	sbci	r31, 0xFF	; 255
    81ac:	80 e0       	ldi	r24, 0x00	; 0
    81ae:	90 e0       	ldi	r25, 0x00	; 0
    81b0:	a0 e8       	ldi	r26, 0x80	; 128
    81b2:	bf e3       	ldi	r27, 0x3F	; 63
    81b4:	80 83       	st	Z, r24
    81b6:	91 83       	std	Z+1, r25	; 0x01
    81b8:	a2 83       	std	Z+2, r26	; 0x02
    81ba:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    81bc:	8e 01       	movw	r16, r28
    81be:	0f 5b       	subi	r16, 0xBF	; 191
    81c0:	1f 4f       	sbci	r17, 0xFF	; 255
    81c2:	fe 01       	movw	r30, r28
    81c4:	eb 5b       	subi	r30, 0xBB	; 187
    81c6:	ff 4f       	sbci	r31, 0xFF	; 255
    81c8:	60 81       	ld	r22, Z
    81ca:	71 81       	ldd	r23, Z+1	; 0x01
    81cc:	82 81       	ldd	r24, Z+2	; 0x02
    81ce:	93 81       	ldd	r25, Z+3	; 0x03
    81d0:	2b ea       	ldi	r18, 0xAB	; 171
    81d2:	3a ea       	ldi	r19, 0xAA	; 170
    81d4:	4a ea       	ldi	r20, 0xAA	; 170
    81d6:	50 e4       	ldi	r21, 0x40	; 64
    81d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    81dc:	dc 01       	movw	r26, r24
    81de:	cb 01       	movw	r24, r22
    81e0:	f8 01       	movw	r30, r16
    81e2:	80 83       	st	Z, r24
    81e4:	91 83       	std	Z+1, r25	; 0x01
    81e6:	a2 83       	std	Z+2, r26	; 0x02
    81e8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    81ea:	fe 01       	movw	r30, r28
    81ec:	ef 5b       	subi	r30, 0xBF	; 191
    81ee:	ff 4f       	sbci	r31, 0xFF	; 255
    81f0:	60 81       	ld	r22, Z
    81f2:	71 81       	ldd	r23, Z+1	; 0x01
    81f4:	82 81       	ldd	r24, Z+2	; 0x02
    81f6:	93 81       	ldd	r25, Z+3	; 0x03
    81f8:	20 e0       	ldi	r18, 0x00	; 0
    81fa:	30 e0       	ldi	r19, 0x00	; 0
    81fc:	40 e8       	ldi	r20, 0x80	; 128
    81fe:	5f e3       	ldi	r21, 0x3F	; 63
    8200:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8204:	88 23       	and	r24, r24
    8206:	34 f4       	brge	.+12     	; 0x8214 <LCD_read_data_4bit+0x31a>
		__ticks = 1;
    8208:	81 e0       	ldi	r24, 0x01	; 1
    820a:	fe 01       	movw	r30, r28
    820c:	e0 5c       	subi	r30, 0xC0	; 192
    820e:	ff 4f       	sbci	r31, 0xFF	; 255
    8210:	80 83       	st	Z, r24
    8212:	9d c0       	rjmp	.+314    	; 0x834e <LCD_read_data_4bit+0x454>
	else if (__tmp > 255)
    8214:	fe 01       	movw	r30, r28
    8216:	ef 5b       	subi	r30, 0xBF	; 191
    8218:	ff 4f       	sbci	r31, 0xFF	; 255
    821a:	60 81       	ld	r22, Z
    821c:	71 81       	ldd	r23, Z+1	; 0x01
    821e:	82 81       	ldd	r24, Z+2	; 0x02
    8220:	93 81       	ldd	r25, Z+3	; 0x03
    8222:	20 e0       	ldi	r18, 0x00	; 0
    8224:	30 e0       	ldi	r19, 0x00	; 0
    8226:	4f e7       	ldi	r20, 0x7F	; 127
    8228:	53 e4       	ldi	r21, 0x43	; 67
    822a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    822e:	18 16       	cp	r1, r24
    8230:	0c f0       	brlt	.+2      	; 0x8234 <LCD_read_data_4bit+0x33a>
    8232:	7e c0       	rjmp	.+252    	; 0x8330 <LCD_read_data_4bit+0x436>
	{
		_delay_ms(__us / 1000.0);
    8234:	fe 01       	movw	r30, r28
    8236:	eb 5b       	subi	r30, 0xBB	; 187
    8238:	ff 4f       	sbci	r31, 0xFF	; 255
    823a:	60 81       	ld	r22, Z
    823c:	71 81       	ldd	r23, Z+1	; 0x01
    823e:	82 81       	ldd	r24, Z+2	; 0x02
    8240:	93 81       	ldd	r25, Z+3	; 0x03
    8242:	20 e0       	ldi	r18, 0x00	; 0
    8244:	30 e0       	ldi	r19, 0x00	; 0
    8246:	4a e7       	ldi	r20, 0x7A	; 122
    8248:	54 e4       	ldi	r21, 0x44	; 68
    824a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    824e:	dc 01       	movw	r26, r24
    8250:	cb 01       	movw	r24, r22
    8252:	8c af       	std	Y+60, r24	; 0x3c
    8254:	9d af       	std	Y+61, r25	; 0x3d
    8256:	ae af       	std	Y+62, r26	; 0x3e
    8258:	bf af       	std	Y+63, r27	; 0x3f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    825a:	6c ad       	ldd	r22, Y+60	; 0x3c
    825c:	7d ad       	ldd	r23, Y+61	; 0x3d
    825e:	8e ad       	ldd	r24, Y+62	; 0x3e
    8260:	9f ad       	ldd	r25, Y+63	; 0x3f
    8262:	20 e0       	ldi	r18, 0x00	; 0
    8264:	30 e0       	ldi	r19, 0x00	; 0
    8266:	4a e7       	ldi	r20, 0x7A	; 122
    8268:	55 e4       	ldi	r21, 0x45	; 69
    826a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    826e:	dc 01       	movw	r26, r24
    8270:	cb 01       	movw	r24, r22
    8272:	88 af       	std	Y+56, r24	; 0x38
    8274:	99 af       	std	Y+57, r25	; 0x39
    8276:	aa af       	std	Y+58, r26	; 0x3a
    8278:	bb af       	std	Y+59, r27	; 0x3b
	if (__tmp < 1.0)
    827a:	68 ad       	ldd	r22, Y+56	; 0x38
    827c:	79 ad       	ldd	r23, Y+57	; 0x39
    827e:	8a ad       	ldd	r24, Y+58	; 0x3a
    8280:	9b ad       	ldd	r25, Y+59	; 0x3b
    8282:	20 e0       	ldi	r18, 0x00	; 0
    8284:	30 e0       	ldi	r19, 0x00	; 0
    8286:	40 e8       	ldi	r20, 0x80	; 128
    8288:	5f e3       	ldi	r21, 0x3F	; 63
    828a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    828e:	88 23       	and	r24, r24
    8290:	2c f4       	brge	.+10     	; 0x829c <LCD_read_data_4bit+0x3a2>
		__ticks = 1;
    8292:	81 e0       	ldi	r24, 0x01	; 1
    8294:	90 e0       	ldi	r25, 0x00	; 0
    8296:	9f ab       	std	Y+55, r25	; 0x37
    8298:	8e ab       	std	Y+54, r24	; 0x36
    829a:	3f c0       	rjmp	.+126    	; 0x831a <LCD_read_data_4bit+0x420>
	else if (__tmp > 65535)
    829c:	68 ad       	ldd	r22, Y+56	; 0x38
    829e:	79 ad       	ldd	r23, Y+57	; 0x39
    82a0:	8a ad       	ldd	r24, Y+58	; 0x3a
    82a2:	9b ad       	ldd	r25, Y+59	; 0x3b
    82a4:	20 e0       	ldi	r18, 0x00	; 0
    82a6:	3f ef       	ldi	r19, 0xFF	; 255
    82a8:	4f e7       	ldi	r20, 0x7F	; 127
    82aa:	57 e4       	ldi	r21, 0x47	; 71
    82ac:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    82b0:	18 16       	cp	r1, r24
    82b2:	4c f5       	brge	.+82     	; 0x8306 <LCD_read_data_4bit+0x40c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    82b4:	6c ad       	ldd	r22, Y+60	; 0x3c
    82b6:	7d ad       	ldd	r23, Y+61	; 0x3d
    82b8:	8e ad       	ldd	r24, Y+62	; 0x3e
    82ba:	9f ad       	ldd	r25, Y+63	; 0x3f
    82bc:	20 e0       	ldi	r18, 0x00	; 0
    82be:	30 e0       	ldi	r19, 0x00	; 0
    82c0:	40 e2       	ldi	r20, 0x20	; 32
    82c2:	51 e4       	ldi	r21, 0x41	; 65
    82c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    82c8:	dc 01       	movw	r26, r24
    82ca:	cb 01       	movw	r24, r22
    82cc:	bc 01       	movw	r22, r24
    82ce:	cd 01       	movw	r24, r26
    82d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    82d4:	dc 01       	movw	r26, r24
    82d6:	cb 01       	movw	r24, r22
    82d8:	9f ab       	std	Y+55, r25	; 0x37
    82da:	8e ab       	std	Y+54, r24	; 0x36
    82dc:	0f c0       	rjmp	.+30     	; 0x82fc <LCD_read_data_4bit+0x402>
    82de:	80 e9       	ldi	r24, 0x90	; 144
    82e0:	91 e0       	ldi	r25, 0x01	; 1
    82e2:	9d ab       	std	Y+53, r25	; 0x35
    82e4:	8c ab       	std	Y+52, r24	; 0x34
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    82e6:	8c a9       	ldd	r24, Y+52	; 0x34
    82e8:	9d a9       	ldd	r25, Y+53	; 0x35
    82ea:	01 97       	sbiw	r24, 0x01	; 1
    82ec:	f1 f7       	brne	.-4      	; 0x82ea <LCD_read_data_4bit+0x3f0>
    82ee:	9d ab       	std	Y+53, r25	; 0x35
    82f0:	8c ab       	std	Y+52, r24	; 0x34
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    82f2:	8e a9       	ldd	r24, Y+54	; 0x36
    82f4:	9f a9       	ldd	r25, Y+55	; 0x37
    82f6:	01 97       	sbiw	r24, 0x01	; 1
    82f8:	9f ab       	std	Y+55, r25	; 0x37
    82fa:	8e ab       	std	Y+54, r24	; 0x36
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    82fc:	8e a9       	ldd	r24, Y+54	; 0x36
    82fe:	9f a9       	ldd	r25, Y+55	; 0x37
    8300:	00 97       	sbiw	r24, 0x00	; 0
    8302:	69 f7       	brne	.-38     	; 0x82de <LCD_read_data_4bit+0x3e4>
    8304:	2d c0       	rjmp	.+90     	; 0x8360 <LCD_read_data_4bit+0x466>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8306:	68 ad       	ldd	r22, Y+56	; 0x38
    8308:	79 ad       	ldd	r23, Y+57	; 0x39
    830a:	8a ad       	ldd	r24, Y+58	; 0x3a
    830c:	9b ad       	ldd	r25, Y+59	; 0x3b
    830e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8312:	dc 01       	movw	r26, r24
    8314:	cb 01       	movw	r24, r22
    8316:	9f ab       	std	Y+55, r25	; 0x37
    8318:	8e ab       	std	Y+54, r24	; 0x36
    831a:	8e a9       	ldd	r24, Y+54	; 0x36
    831c:	9f a9       	ldd	r25, Y+55	; 0x37
    831e:	9b ab       	std	Y+51, r25	; 0x33
    8320:	8a ab       	std	Y+50, r24	; 0x32
    8322:	8a a9       	ldd	r24, Y+50	; 0x32
    8324:	9b a9       	ldd	r25, Y+51	; 0x33
    8326:	01 97       	sbiw	r24, 0x01	; 1
    8328:	f1 f7       	brne	.-4      	; 0x8326 <LCD_read_data_4bit+0x42c>
    832a:	9b ab       	std	Y+51, r25	; 0x33
    832c:	8a ab       	std	Y+50, r24	; 0x32
    832e:	18 c0       	rjmp	.+48     	; 0x8360 <LCD_read_data_4bit+0x466>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    8330:	fe 01       	movw	r30, r28
    8332:	ef 5b       	subi	r30, 0xBF	; 191
    8334:	ff 4f       	sbci	r31, 0xFF	; 255
    8336:	60 81       	ld	r22, Z
    8338:	71 81       	ldd	r23, Z+1	; 0x01
    833a:	82 81       	ldd	r24, Z+2	; 0x02
    833c:	93 81       	ldd	r25, Z+3	; 0x03
    833e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8342:	dc 01       	movw	r26, r24
    8344:	cb 01       	movw	r24, r22
    8346:	fe 01       	movw	r30, r28
    8348:	e0 5c       	subi	r30, 0xC0	; 192
    834a:	ff 4f       	sbci	r31, 0xFF	; 255
    834c:	80 83       	st	Z, r24
    834e:	fe 01       	movw	r30, r28
    8350:	e0 5c       	subi	r30, 0xC0	; 192
    8352:	ff 4f       	sbci	r31, 0xFF	; 255
    8354:	80 81       	ld	r24, Z
    8356:	89 ab       	std	Y+49, r24	; 0x31
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    8358:	89 a9       	ldd	r24, Y+49	; 0x31
    835a:	8a 95       	dec	r24
    835c:	f1 f7       	brne	.-4      	; 0x835a <LCD_read_data_4bit+0x460>
    835e:	89 ab       	std	Y+49, r24	; 0x31
	_delay_us(1);
	// Recive the higher nipple
	u8 address= (DIO_u8_get_port(lcd_data_port) << 4);
    8360:	82 e0       	ldi	r24, 0x02	; 2
    8362:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <DIO_u8_get_port>
    8366:	fe 01       	movw	r30, r28
    8368:	ef 59       	subi	r30, 0x9F	; 159
    836a:	ff 4f       	sbci	r31, 0xFF	; 255
    836c:	82 95       	swap	r24
    836e:	80 7f       	andi	r24, 0xF0	; 240
    8370:	80 83       	st	Z, r24
	// Enable pin is low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    8372:	82 e0       	ldi	r24, 0x02	; 2
    8374:	60 e0       	ldi	r22, 0x00	; 0
    8376:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
    837a:	80 e0       	ldi	r24, 0x00	; 0
    837c:	90 e0       	ldi	r25, 0x00	; 0
    837e:	a0 e2       	ldi	r26, 0x20	; 32
    8380:	b1 e4       	ldi	r27, 0x41	; 65
    8382:	8d a7       	std	Y+45, r24	; 0x2d
    8384:	9e a7       	std	Y+46, r25	; 0x2e
    8386:	af a7       	std	Y+47, r26	; 0x2f
    8388:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    838a:	6d a5       	ldd	r22, Y+45	; 0x2d
    838c:	7e a5       	ldd	r23, Y+46	; 0x2e
    838e:	8f a5       	ldd	r24, Y+47	; 0x2f
    8390:	98 a9       	ldd	r25, Y+48	; 0x30
    8392:	2b ea       	ldi	r18, 0xAB	; 171
    8394:	3a ea       	ldi	r19, 0xAA	; 170
    8396:	4a ea       	ldi	r20, 0xAA	; 170
    8398:	50 e4       	ldi	r21, 0x40	; 64
    839a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    839e:	dc 01       	movw	r26, r24
    83a0:	cb 01       	movw	r24, r22
    83a2:	89 a7       	std	Y+41, r24	; 0x29
    83a4:	9a a7       	std	Y+42, r25	; 0x2a
    83a6:	ab a7       	std	Y+43, r26	; 0x2b
    83a8:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    83aa:	69 a5       	ldd	r22, Y+41	; 0x29
    83ac:	7a a5       	ldd	r23, Y+42	; 0x2a
    83ae:	8b a5       	ldd	r24, Y+43	; 0x2b
    83b0:	9c a5       	ldd	r25, Y+44	; 0x2c
    83b2:	20 e0       	ldi	r18, 0x00	; 0
    83b4:	30 e0       	ldi	r19, 0x00	; 0
    83b6:	40 e8       	ldi	r20, 0x80	; 128
    83b8:	5f e3       	ldi	r21, 0x3F	; 63
    83ba:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    83be:	88 23       	and	r24, r24
    83c0:	1c f4       	brge	.+6      	; 0x83c8 <LCD_read_data_4bit+0x4ce>
		__ticks = 1;
    83c2:	81 e0       	ldi	r24, 0x01	; 1
    83c4:	88 a7       	std	Y+40, r24	; 0x28
    83c6:	91 c0       	rjmp	.+290    	; 0x84ea <LCD_read_data_4bit+0x5f0>
	else if (__tmp > 255)
    83c8:	69 a5       	ldd	r22, Y+41	; 0x29
    83ca:	7a a5       	ldd	r23, Y+42	; 0x2a
    83cc:	8b a5       	ldd	r24, Y+43	; 0x2b
    83ce:	9c a5       	ldd	r25, Y+44	; 0x2c
    83d0:	20 e0       	ldi	r18, 0x00	; 0
    83d2:	30 e0       	ldi	r19, 0x00	; 0
    83d4:	4f e7       	ldi	r20, 0x7F	; 127
    83d6:	53 e4       	ldi	r21, 0x43	; 67
    83d8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    83dc:	18 16       	cp	r1, r24
    83de:	0c f0       	brlt	.+2      	; 0x83e2 <LCD_read_data_4bit+0x4e8>
    83e0:	7b c0       	rjmp	.+246    	; 0x84d8 <LCD_read_data_4bit+0x5de>
	{
		_delay_ms(__us / 1000.0);
    83e2:	6d a5       	ldd	r22, Y+45	; 0x2d
    83e4:	7e a5       	ldd	r23, Y+46	; 0x2e
    83e6:	8f a5       	ldd	r24, Y+47	; 0x2f
    83e8:	98 a9       	ldd	r25, Y+48	; 0x30
    83ea:	20 e0       	ldi	r18, 0x00	; 0
    83ec:	30 e0       	ldi	r19, 0x00	; 0
    83ee:	4a e7       	ldi	r20, 0x7A	; 122
    83f0:	54 e4       	ldi	r21, 0x44	; 68
    83f2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    83f6:	dc 01       	movw	r26, r24
    83f8:	cb 01       	movw	r24, r22
    83fa:	8c a3       	std	Y+36, r24	; 0x24
    83fc:	9d a3       	std	Y+37, r25	; 0x25
    83fe:	ae a3       	std	Y+38, r26	; 0x26
    8400:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8402:	6c a1       	ldd	r22, Y+36	; 0x24
    8404:	7d a1       	ldd	r23, Y+37	; 0x25
    8406:	8e a1       	ldd	r24, Y+38	; 0x26
    8408:	9f a1       	ldd	r25, Y+39	; 0x27
    840a:	20 e0       	ldi	r18, 0x00	; 0
    840c:	30 e0       	ldi	r19, 0x00	; 0
    840e:	4a e7       	ldi	r20, 0x7A	; 122
    8410:	55 e4       	ldi	r21, 0x45	; 69
    8412:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8416:	dc 01       	movw	r26, r24
    8418:	cb 01       	movw	r24, r22
    841a:	88 a3       	std	Y+32, r24	; 0x20
    841c:	99 a3       	std	Y+33, r25	; 0x21
    841e:	aa a3       	std	Y+34, r26	; 0x22
    8420:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    8422:	68 a1       	ldd	r22, Y+32	; 0x20
    8424:	79 a1       	ldd	r23, Y+33	; 0x21
    8426:	8a a1       	ldd	r24, Y+34	; 0x22
    8428:	9b a1       	ldd	r25, Y+35	; 0x23
    842a:	20 e0       	ldi	r18, 0x00	; 0
    842c:	30 e0       	ldi	r19, 0x00	; 0
    842e:	40 e8       	ldi	r20, 0x80	; 128
    8430:	5f e3       	ldi	r21, 0x3F	; 63
    8432:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8436:	88 23       	and	r24, r24
    8438:	2c f4       	brge	.+10     	; 0x8444 <LCD_read_data_4bit+0x54a>
		__ticks = 1;
    843a:	81 e0       	ldi	r24, 0x01	; 1
    843c:	90 e0       	ldi	r25, 0x00	; 0
    843e:	9f 8f       	std	Y+31, r25	; 0x1f
    8440:	8e 8f       	std	Y+30, r24	; 0x1e
    8442:	3f c0       	rjmp	.+126    	; 0x84c2 <LCD_read_data_4bit+0x5c8>
	else if (__tmp > 65535)
    8444:	68 a1       	ldd	r22, Y+32	; 0x20
    8446:	79 a1       	ldd	r23, Y+33	; 0x21
    8448:	8a a1       	ldd	r24, Y+34	; 0x22
    844a:	9b a1       	ldd	r25, Y+35	; 0x23
    844c:	20 e0       	ldi	r18, 0x00	; 0
    844e:	3f ef       	ldi	r19, 0xFF	; 255
    8450:	4f e7       	ldi	r20, 0x7F	; 127
    8452:	57 e4       	ldi	r21, 0x47	; 71
    8454:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8458:	18 16       	cp	r1, r24
    845a:	4c f5       	brge	.+82     	; 0x84ae <LCD_read_data_4bit+0x5b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    845c:	6c a1       	ldd	r22, Y+36	; 0x24
    845e:	7d a1       	ldd	r23, Y+37	; 0x25
    8460:	8e a1       	ldd	r24, Y+38	; 0x26
    8462:	9f a1       	ldd	r25, Y+39	; 0x27
    8464:	20 e0       	ldi	r18, 0x00	; 0
    8466:	30 e0       	ldi	r19, 0x00	; 0
    8468:	40 e2       	ldi	r20, 0x20	; 32
    846a:	51 e4       	ldi	r21, 0x41	; 65
    846c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8470:	dc 01       	movw	r26, r24
    8472:	cb 01       	movw	r24, r22
    8474:	bc 01       	movw	r22, r24
    8476:	cd 01       	movw	r24, r26
    8478:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    847c:	dc 01       	movw	r26, r24
    847e:	cb 01       	movw	r24, r22
    8480:	9f 8f       	std	Y+31, r25	; 0x1f
    8482:	8e 8f       	std	Y+30, r24	; 0x1e
    8484:	0f c0       	rjmp	.+30     	; 0x84a4 <LCD_read_data_4bit+0x5aa>
    8486:	80 e9       	ldi	r24, 0x90	; 144
    8488:	91 e0       	ldi	r25, 0x01	; 1
    848a:	9d 8f       	std	Y+29, r25	; 0x1d
    848c:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    848e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    8490:	9d 8d       	ldd	r25, Y+29	; 0x1d
    8492:	01 97       	sbiw	r24, 0x01	; 1
    8494:	f1 f7       	brne	.-4      	; 0x8492 <LCD_read_data_4bit+0x598>
    8496:	9d 8f       	std	Y+29, r25	; 0x1d
    8498:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    849a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    849c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    849e:	01 97       	sbiw	r24, 0x01	; 1
    84a0:	9f 8f       	std	Y+31, r25	; 0x1f
    84a2:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    84a4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    84a6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    84a8:	00 97       	sbiw	r24, 0x00	; 0
    84aa:	69 f7       	brne	.-38     	; 0x8486 <LCD_read_data_4bit+0x58c>
    84ac:	24 c0       	rjmp	.+72     	; 0x84f6 <LCD_read_data_4bit+0x5fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    84ae:	68 a1       	ldd	r22, Y+32	; 0x20
    84b0:	79 a1       	ldd	r23, Y+33	; 0x21
    84b2:	8a a1       	ldd	r24, Y+34	; 0x22
    84b4:	9b a1       	ldd	r25, Y+35	; 0x23
    84b6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    84ba:	dc 01       	movw	r26, r24
    84bc:	cb 01       	movw	r24, r22
    84be:	9f 8f       	std	Y+31, r25	; 0x1f
    84c0:	8e 8f       	std	Y+30, r24	; 0x1e
    84c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    84c4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    84c6:	9b 8f       	std	Y+27, r25	; 0x1b
    84c8:	8a 8f       	std	Y+26, r24	; 0x1a
    84ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    84cc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    84ce:	01 97       	sbiw	r24, 0x01	; 1
    84d0:	f1 f7       	brne	.-4      	; 0x84ce <LCD_read_data_4bit+0x5d4>
    84d2:	9b 8f       	std	Y+27, r25	; 0x1b
    84d4:	8a 8f       	std	Y+26, r24	; 0x1a
    84d6:	0f c0       	rjmp	.+30     	; 0x84f6 <LCD_read_data_4bit+0x5fc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    84d8:	69 a5       	ldd	r22, Y+41	; 0x29
    84da:	7a a5       	ldd	r23, Y+42	; 0x2a
    84dc:	8b a5       	ldd	r24, Y+43	; 0x2b
    84de:	9c a5       	ldd	r25, Y+44	; 0x2c
    84e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    84e4:	dc 01       	movw	r26, r24
    84e6:	cb 01       	movw	r24, r22
    84e8:	88 a7       	std	Y+40, r24	; 0x28
    84ea:	88 a5       	ldd	r24, Y+40	; 0x28
    84ec:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    84ee:	89 8d       	ldd	r24, Y+25	; 0x19
    84f0:	8a 95       	dec	r24
    84f2:	f1 f7       	brne	.-4      	; 0x84f0 <LCD_read_data_4bit+0x5f6>
    84f4:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(10);
	// Enable pin is high to recive the lower nipple
	DIO_void_set_pin(lcd_ctrl_port, lcd_EN);
    84f6:	82 e0       	ldi	r24, 0x02	; 2
    84f8:	60 e0       	ldi	r22, 0x00	; 0
    84fa:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
    84fe:	80 e0       	ldi	r24, 0x00	; 0
    8500:	90 e0       	ldi	r25, 0x00	; 0
    8502:	a0 e8       	ldi	r26, 0x80	; 128
    8504:	bf e3       	ldi	r27, 0x3F	; 63
    8506:	8d 8b       	std	Y+21, r24	; 0x15
    8508:	9e 8b       	std	Y+22, r25	; 0x16
    850a:	af 8b       	std	Y+23, r26	; 0x17
    850c:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    850e:	6d 89       	ldd	r22, Y+21	; 0x15
    8510:	7e 89       	ldd	r23, Y+22	; 0x16
    8512:	8f 89       	ldd	r24, Y+23	; 0x17
    8514:	98 8d       	ldd	r25, Y+24	; 0x18
    8516:	2b ea       	ldi	r18, 0xAB	; 171
    8518:	3a ea       	ldi	r19, 0xAA	; 170
    851a:	4a ea       	ldi	r20, 0xAA	; 170
    851c:	50 e4       	ldi	r21, 0x40	; 64
    851e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8522:	dc 01       	movw	r26, r24
    8524:	cb 01       	movw	r24, r22
    8526:	89 8b       	std	Y+17, r24	; 0x11
    8528:	9a 8b       	std	Y+18, r25	; 0x12
    852a:	ab 8b       	std	Y+19, r26	; 0x13
    852c:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    852e:	69 89       	ldd	r22, Y+17	; 0x11
    8530:	7a 89       	ldd	r23, Y+18	; 0x12
    8532:	8b 89       	ldd	r24, Y+19	; 0x13
    8534:	9c 89       	ldd	r25, Y+20	; 0x14
    8536:	20 e0       	ldi	r18, 0x00	; 0
    8538:	30 e0       	ldi	r19, 0x00	; 0
    853a:	40 e8       	ldi	r20, 0x80	; 128
    853c:	5f e3       	ldi	r21, 0x3F	; 63
    853e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8542:	88 23       	and	r24, r24
    8544:	1c f4       	brge	.+6      	; 0x854c <LCD_read_data_4bit+0x652>
		__ticks = 1;
    8546:	81 e0       	ldi	r24, 0x01	; 1
    8548:	88 8b       	std	Y+16, r24	; 0x10
    854a:	91 c0       	rjmp	.+290    	; 0x866e <LCD_read_data_4bit+0x774>
	else if (__tmp > 255)
    854c:	69 89       	ldd	r22, Y+17	; 0x11
    854e:	7a 89       	ldd	r23, Y+18	; 0x12
    8550:	8b 89       	ldd	r24, Y+19	; 0x13
    8552:	9c 89       	ldd	r25, Y+20	; 0x14
    8554:	20 e0       	ldi	r18, 0x00	; 0
    8556:	30 e0       	ldi	r19, 0x00	; 0
    8558:	4f e7       	ldi	r20, 0x7F	; 127
    855a:	53 e4       	ldi	r21, 0x43	; 67
    855c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8560:	18 16       	cp	r1, r24
    8562:	0c f0       	brlt	.+2      	; 0x8566 <LCD_read_data_4bit+0x66c>
    8564:	7b c0       	rjmp	.+246    	; 0x865c <LCD_read_data_4bit+0x762>
	{
		_delay_ms(__us / 1000.0);
    8566:	6d 89       	ldd	r22, Y+21	; 0x15
    8568:	7e 89       	ldd	r23, Y+22	; 0x16
    856a:	8f 89       	ldd	r24, Y+23	; 0x17
    856c:	98 8d       	ldd	r25, Y+24	; 0x18
    856e:	20 e0       	ldi	r18, 0x00	; 0
    8570:	30 e0       	ldi	r19, 0x00	; 0
    8572:	4a e7       	ldi	r20, 0x7A	; 122
    8574:	54 e4       	ldi	r21, 0x44	; 68
    8576:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    857a:	dc 01       	movw	r26, r24
    857c:	cb 01       	movw	r24, r22
    857e:	8c 87       	std	Y+12, r24	; 0x0c
    8580:	9d 87       	std	Y+13, r25	; 0x0d
    8582:	ae 87       	std	Y+14, r26	; 0x0e
    8584:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8586:	6c 85       	ldd	r22, Y+12	; 0x0c
    8588:	7d 85       	ldd	r23, Y+13	; 0x0d
    858a:	8e 85       	ldd	r24, Y+14	; 0x0e
    858c:	9f 85       	ldd	r25, Y+15	; 0x0f
    858e:	20 e0       	ldi	r18, 0x00	; 0
    8590:	30 e0       	ldi	r19, 0x00	; 0
    8592:	4a e7       	ldi	r20, 0x7A	; 122
    8594:	55 e4       	ldi	r21, 0x45	; 69
    8596:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    859a:	dc 01       	movw	r26, r24
    859c:	cb 01       	movw	r24, r22
    859e:	88 87       	std	Y+8, r24	; 0x08
    85a0:	99 87       	std	Y+9, r25	; 0x09
    85a2:	aa 87       	std	Y+10, r26	; 0x0a
    85a4:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    85a6:	68 85       	ldd	r22, Y+8	; 0x08
    85a8:	79 85       	ldd	r23, Y+9	; 0x09
    85aa:	8a 85       	ldd	r24, Y+10	; 0x0a
    85ac:	9b 85       	ldd	r25, Y+11	; 0x0b
    85ae:	20 e0       	ldi	r18, 0x00	; 0
    85b0:	30 e0       	ldi	r19, 0x00	; 0
    85b2:	40 e8       	ldi	r20, 0x80	; 128
    85b4:	5f e3       	ldi	r21, 0x3F	; 63
    85b6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    85ba:	88 23       	and	r24, r24
    85bc:	2c f4       	brge	.+10     	; 0x85c8 <LCD_read_data_4bit+0x6ce>
		__ticks = 1;
    85be:	81 e0       	ldi	r24, 0x01	; 1
    85c0:	90 e0       	ldi	r25, 0x00	; 0
    85c2:	9f 83       	std	Y+7, r25	; 0x07
    85c4:	8e 83       	std	Y+6, r24	; 0x06
    85c6:	3f c0       	rjmp	.+126    	; 0x8646 <LCD_read_data_4bit+0x74c>
	else if (__tmp > 65535)
    85c8:	68 85       	ldd	r22, Y+8	; 0x08
    85ca:	79 85       	ldd	r23, Y+9	; 0x09
    85cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    85ce:	9b 85       	ldd	r25, Y+11	; 0x0b
    85d0:	20 e0       	ldi	r18, 0x00	; 0
    85d2:	3f ef       	ldi	r19, 0xFF	; 255
    85d4:	4f e7       	ldi	r20, 0x7F	; 127
    85d6:	57 e4       	ldi	r21, 0x47	; 71
    85d8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    85dc:	18 16       	cp	r1, r24
    85de:	4c f5       	brge	.+82     	; 0x8632 <LCD_read_data_4bit+0x738>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    85e0:	6c 85       	ldd	r22, Y+12	; 0x0c
    85e2:	7d 85       	ldd	r23, Y+13	; 0x0d
    85e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    85e6:	9f 85       	ldd	r25, Y+15	; 0x0f
    85e8:	20 e0       	ldi	r18, 0x00	; 0
    85ea:	30 e0       	ldi	r19, 0x00	; 0
    85ec:	40 e2       	ldi	r20, 0x20	; 32
    85ee:	51 e4       	ldi	r21, 0x41	; 65
    85f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    85f4:	dc 01       	movw	r26, r24
    85f6:	cb 01       	movw	r24, r22
    85f8:	bc 01       	movw	r22, r24
    85fa:	cd 01       	movw	r24, r26
    85fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8600:	dc 01       	movw	r26, r24
    8602:	cb 01       	movw	r24, r22
    8604:	9f 83       	std	Y+7, r25	; 0x07
    8606:	8e 83       	std	Y+6, r24	; 0x06
    8608:	0f c0       	rjmp	.+30     	; 0x8628 <LCD_read_data_4bit+0x72e>
    860a:	80 e9       	ldi	r24, 0x90	; 144
    860c:	91 e0       	ldi	r25, 0x01	; 1
    860e:	9d 83       	std	Y+5, r25	; 0x05
    8610:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    8612:	8c 81       	ldd	r24, Y+4	; 0x04
    8614:	9d 81       	ldd	r25, Y+5	; 0x05
    8616:	01 97       	sbiw	r24, 0x01	; 1
    8618:	f1 f7       	brne	.-4      	; 0x8616 <LCD_read_data_4bit+0x71c>
    861a:	9d 83       	std	Y+5, r25	; 0x05
    861c:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    861e:	8e 81       	ldd	r24, Y+6	; 0x06
    8620:	9f 81       	ldd	r25, Y+7	; 0x07
    8622:	01 97       	sbiw	r24, 0x01	; 1
    8624:	9f 83       	std	Y+7, r25	; 0x07
    8626:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8628:	8e 81       	ldd	r24, Y+6	; 0x06
    862a:	9f 81       	ldd	r25, Y+7	; 0x07
    862c:	00 97       	sbiw	r24, 0x00	; 0
    862e:	69 f7       	brne	.-38     	; 0x860a <LCD_read_data_4bit+0x710>
    8630:	24 c0       	rjmp	.+72     	; 0x867a <LCD_read_data_4bit+0x780>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8632:	68 85       	ldd	r22, Y+8	; 0x08
    8634:	79 85       	ldd	r23, Y+9	; 0x09
    8636:	8a 85       	ldd	r24, Y+10	; 0x0a
    8638:	9b 85       	ldd	r25, Y+11	; 0x0b
    863a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    863e:	dc 01       	movw	r26, r24
    8640:	cb 01       	movw	r24, r22
    8642:	9f 83       	std	Y+7, r25	; 0x07
    8644:	8e 83       	std	Y+6, r24	; 0x06
    8646:	8e 81       	ldd	r24, Y+6	; 0x06
    8648:	9f 81       	ldd	r25, Y+7	; 0x07
    864a:	9b 83       	std	Y+3, r25	; 0x03
    864c:	8a 83       	std	Y+2, r24	; 0x02
    864e:	8a 81       	ldd	r24, Y+2	; 0x02
    8650:	9b 81       	ldd	r25, Y+3	; 0x03
    8652:	01 97       	sbiw	r24, 0x01	; 1
    8654:	f1 f7       	brne	.-4      	; 0x8652 <LCD_read_data_4bit+0x758>
    8656:	9b 83       	std	Y+3, r25	; 0x03
    8658:	8a 83       	std	Y+2, r24	; 0x02
    865a:	0f c0       	rjmp	.+30     	; 0x867a <LCD_read_data_4bit+0x780>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    865c:	69 89       	ldd	r22, Y+17	; 0x11
    865e:	7a 89       	ldd	r23, Y+18	; 0x12
    8660:	8b 89       	ldd	r24, Y+19	; 0x13
    8662:	9c 89       	ldd	r25, Y+20	; 0x14
    8664:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8668:	dc 01       	movw	r26, r24
    866a:	cb 01       	movw	r24, r22
    866c:	88 8b       	std	Y+16, r24	; 0x10
    866e:	88 89       	ldd	r24, Y+16	; 0x10
    8670:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    8672:	89 81       	ldd	r24, Y+1	; 0x01
    8674:	8a 95       	dec	r24
    8676:	f1 f7       	brne	.-4      	; 0x8674 <LCD_read_data_4bit+0x77a>
    8678:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	// Recive the lower nipple
	address|= DIO_u8_get_port(lcd_data_port);
    867a:	82 e0       	ldi	r24, 0x02	; 2
    867c:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <DIO_u8_get_port>
    8680:	98 2f       	mov	r25, r24
    8682:	de 01       	movw	r26, r28
    8684:	af 59       	subi	r26, 0x9F	; 159
    8686:	bf 4f       	sbci	r27, 0xFF	; 255
    8688:	fe 01       	movw	r30, r28
    868a:	ef 59       	subi	r30, 0x9F	; 159
    868c:	ff 4f       	sbci	r31, 0xFF	; 255
    868e:	80 81       	ld	r24, Z
    8690:	89 2b       	or	r24, r25
    8692:	8c 93       	st	X, r24
	// Enable pin is low
	DIO_void_clear_pin(lcd_ctrl_port, lcd_EN);
    8694:	82 e0       	ldi	r24, 0x02	; 2
    8696:	60 e0       	ldi	r22, 0x00	; 0
    8698:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
	// clear the busy flag bit
	clr_bit(address, lcd_busy_flag);
    869c:	de 01       	movw	r26, r28
    869e:	af 59       	subi	r26, 0x9F	; 159
    86a0:	bf 4f       	sbci	r27, 0xFF	; 255
    86a2:	fe 01       	movw	r30, r28
    86a4:	ef 59       	subi	r30, 0x9F	; 159
    86a6:	ff 4f       	sbci	r31, 0xFF	; 255
    86a8:	80 81       	ld	r24, Z
    86aa:	8f 77       	andi	r24, 0x7F	; 127
    86ac:	8c 93       	st	X, r24
	// Configure the data pins back to output
	DIO_void_set_pin_dir(lcd_data_port, B7, OUTPUT);
    86ae:	82 e0       	ldi	r24, 0x02	; 2
    86b0:	67 e0       	ldi	r22, 0x07	; 7
    86b2:	41 e0       	ldi	r20, 0x01	; 1
    86b4:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B6, OUTPUT);
    86b8:	82 e0       	ldi	r24, 0x02	; 2
    86ba:	66 e0       	ldi	r22, 0x06	; 6
    86bc:	41 e0       	ldi	r20, 0x01	; 1
    86be:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B5, OUTPUT);
    86c2:	82 e0       	ldi	r24, 0x02	; 2
    86c4:	65 e0       	ldi	r22, 0x05	; 5
    86c6:	41 e0       	ldi	r20, 0x01	; 1
    86c8:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B4, OUTPUT);
    86cc:	82 e0       	ldi	r24, 0x02	; 2
    86ce:	64 e0       	ldi	r22, 0x04	; 4
    86d0:	41 e0       	ldi	r20, 0x01	; 1
    86d2:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	// Return the current address
	return address;
    86d6:	fe 01       	movw	r30, r28
    86d8:	ef 59       	subi	r30, 0x9F	; 159
    86da:	ff 4f       	sbci	r31, 0xFF	; 255
    86dc:	80 81       	ld	r24, Z
}
    86de:	cf 59       	subi	r28, 0x9F	; 159
    86e0:	df 4f       	sbci	r29, 0xFF	; 255
    86e2:	0f b6       	in	r0, 0x3f	; 63
    86e4:	f8 94       	cli
    86e6:	de bf       	out	0x3e, r29	; 62
    86e8:	0f be       	out	0x3f, r0	; 63
    86ea:	cd bf       	out	0x3d, r28	; 61
    86ec:	cf 91       	pop	r28
    86ee:	df 91       	pop	r29
    86f0:	1f 91       	pop	r17
    86f2:	0f 91       	pop	r16
    86f4:	08 95       	ret

000086f6 <LCD_init>:


/******************************************************************************/

/* User interfacing functions implementation */
void LCD_init(void){
    86f6:	0f 93       	push	r16
    86f8:	1f 93       	push	r17
    86fa:	df 93       	push	r29
    86fc:	cf 93       	push	r28
    86fe:	cd b7       	in	r28, 0x3d	; 61
    8700:	de b7       	in	r29, 0x3e	; 62
    8702:	cc 54       	subi	r28, 0x4C	; 76
    8704:	d0 40       	sbci	r29, 0x00	; 0
    8706:	0f b6       	in	r0, 0x3f	; 63
    8708:	f8 94       	cli
    870a:	de bf       	out	0x3e, r29	; 62
    870c:	0f be       	out	0x3f, r0	; 63
    870e:	cd bf       	out	0x3d, r28	; 61
	LCD_write_cmd_8bit(display_clear);
	// Wait more than 1.53 ms
	_delay_ms(2);
#elif _LCD_interface_ == _4bit_interface
	// Configure the I/O Data pins
	DIO_void_set_pin_dir(lcd_data_port, B7, OUTPUT);
    8710:	82 e0       	ldi	r24, 0x02	; 2
    8712:	67 e0       	ldi	r22, 0x07	; 7
    8714:	41 e0       	ldi	r20, 0x01	; 1
    8716:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B6, OUTPUT);
    871a:	82 e0       	ldi	r24, 0x02	; 2
    871c:	66 e0       	ldi	r22, 0x06	; 6
    871e:	41 e0       	ldi	r20, 0x01	; 1
    8720:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B5, OUTPUT);
    8724:	82 e0       	ldi	r24, 0x02	; 2
    8726:	65 e0       	ldi	r22, 0x05	; 5
    8728:	41 e0       	ldi	r20, 0x01	; 1
    872a:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B4, OUTPUT);
    872e:	82 e0       	ldi	r24, 0x02	; 2
    8730:	64 e0       	ldi	r22, 0x04	; 4
    8732:	41 e0       	ldi	r20, 0x01	; 1
    8734:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	// Configure the I/O control pins
	DIO_void_set_pin_dir(lcd_ctrl_port, lcd_EN, OUTPUT);
    8738:	82 e0       	ldi	r24, 0x02	; 2
    873a:	60 e0       	ldi	r22, 0x00	; 0
    873c:	41 e0       	ldi	r20, 0x01	; 1
    873e:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_ctrl_port, lcd_RW, OUTPUT);
    8742:	82 e0       	ldi	r24, 0x02	; 2
    8744:	61 e0       	ldi	r22, 0x01	; 1
    8746:	41 e0       	ldi	r20, 0x01	; 1
    8748:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_ctrl_port, lcd_RS, OUTPUT);
    874c:	82 e0       	ldi	r24, 0x02	; 2
    874e:	62 e0       	ldi	r22, 0x02	; 2
    8750:	41 e0       	ldi	r20, 0x01	; 1
    8752:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
    8756:	fe 01       	movw	r30, r28
    8758:	e7 5b       	subi	r30, 0xB7	; 183
    875a:	ff 4f       	sbci	r31, 0xFF	; 255
    875c:	80 e0       	ldi	r24, 0x00	; 0
    875e:	90 e0       	ldi	r25, 0x00	; 0
    8760:	a8 e4       	ldi	r26, 0x48	; 72
    8762:	b2 e4       	ldi	r27, 0x42	; 66
    8764:	80 83       	st	Z, r24
    8766:	91 83       	std	Z+1, r25	; 0x01
    8768:	a2 83       	std	Z+2, r26	; 0x02
    876a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    876c:	8e 01       	movw	r16, r28
    876e:	0b 5b       	subi	r16, 0xBB	; 187
    8770:	1f 4f       	sbci	r17, 0xFF	; 255
    8772:	fe 01       	movw	r30, r28
    8774:	e7 5b       	subi	r30, 0xB7	; 183
    8776:	ff 4f       	sbci	r31, 0xFF	; 255
    8778:	60 81       	ld	r22, Z
    877a:	71 81       	ldd	r23, Z+1	; 0x01
    877c:	82 81       	ldd	r24, Z+2	; 0x02
    877e:	93 81       	ldd	r25, Z+3	; 0x03
    8780:	20 e0       	ldi	r18, 0x00	; 0
    8782:	30 e0       	ldi	r19, 0x00	; 0
    8784:	4a e7       	ldi	r20, 0x7A	; 122
    8786:	55 e4       	ldi	r21, 0x45	; 69
    8788:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    878c:	dc 01       	movw	r26, r24
    878e:	cb 01       	movw	r24, r22
    8790:	f8 01       	movw	r30, r16
    8792:	80 83       	st	Z, r24
    8794:	91 83       	std	Z+1, r25	; 0x01
    8796:	a2 83       	std	Z+2, r26	; 0x02
    8798:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    879a:	fe 01       	movw	r30, r28
    879c:	eb 5b       	subi	r30, 0xBB	; 187
    879e:	ff 4f       	sbci	r31, 0xFF	; 255
    87a0:	60 81       	ld	r22, Z
    87a2:	71 81       	ldd	r23, Z+1	; 0x01
    87a4:	82 81       	ldd	r24, Z+2	; 0x02
    87a6:	93 81       	ldd	r25, Z+3	; 0x03
    87a8:	20 e0       	ldi	r18, 0x00	; 0
    87aa:	30 e0       	ldi	r19, 0x00	; 0
    87ac:	40 e8       	ldi	r20, 0x80	; 128
    87ae:	5f e3       	ldi	r21, 0x3F	; 63
    87b0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    87b4:	88 23       	and	r24, r24
    87b6:	44 f4       	brge	.+16     	; 0x87c8 <LCD_init+0xd2>
		__ticks = 1;
    87b8:	fe 01       	movw	r30, r28
    87ba:	ed 5b       	subi	r30, 0xBD	; 189
    87bc:	ff 4f       	sbci	r31, 0xFF	; 255
    87be:	81 e0       	ldi	r24, 0x01	; 1
    87c0:	90 e0       	ldi	r25, 0x00	; 0
    87c2:	91 83       	std	Z+1, r25	; 0x01
    87c4:	80 83       	st	Z, r24
    87c6:	64 c0       	rjmp	.+200    	; 0x8890 <LCD_init+0x19a>
	else if (__tmp > 65535)
    87c8:	fe 01       	movw	r30, r28
    87ca:	eb 5b       	subi	r30, 0xBB	; 187
    87cc:	ff 4f       	sbci	r31, 0xFF	; 255
    87ce:	60 81       	ld	r22, Z
    87d0:	71 81       	ldd	r23, Z+1	; 0x01
    87d2:	82 81       	ldd	r24, Z+2	; 0x02
    87d4:	93 81       	ldd	r25, Z+3	; 0x03
    87d6:	20 e0       	ldi	r18, 0x00	; 0
    87d8:	3f ef       	ldi	r19, 0xFF	; 255
    87da:	4f e7       	ldi	r20, 0x7F	; 127
    87dc:	57 e4       	ldi	r21, 0x47	; 71
    87de:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    87e2:	18 16       	cp	r1, r24
    87e4:	0c f0       	brlt	.+2      	; 0x87e8 <LCD_init+0xf2>
    87e6:	43 c0       	rjmp	.+134    	; 0x886e <LCD_init+0x178>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    87e8:	fe 01       	movw	r30, r28
    87ea:	e7 5b       	subi	r30, 0xB7	; 183
    87ec:	ff 4f       	sbci	r31, 0xFF	; 255
    87ee:	60 81       	ld	r22, Z
    87f0:	71 81       	ldd	r23, Z+1	; 0x01
    87f2:	82 81       	ldd	r24, Z+2	; 0x02
    87f4:	93 81       	ldd	r25, Z+3	; 0x03
    87f6:	20 e0       	ldi	r18, 0x00	; 0
    87f8:	30 e0       	ldi	r19, 0x00	; 0
    87fa:	40 e2       	ldi	r20, 0x20	; 32
    87fc:	51 e4       	ldi	r21, 0x41	; 65
    87fe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8802:	dc 01       	movw	r26, r24
    8804:	cb 01       	movw	r24, r22
    8806:	8e 01       	movw	r16, r28
    8808:	0d 5b       	subi	r16, 0xBD	; 189
    880a:	1f 4f       	sbci	r17, 0xFF	; 255
    880c:	bc 01       	movw	r22, r24
    880e:	cd 01       	movw	r24, r26
    8810:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8814:	dc 01       	movw	r26, r24
    8816:	cb 01       	movw	r24, r22
    8818:	f8 01       	movw	r30, r16
    881a:	91 83       	std	Z+1, r25	; 0x01
    881c:	80 83       	st	Z, r24
    881e:	1f c0       	rjmp	.+62     	; 0x885e <LCD_init+0x168>
    8820:	fe 01       	movw	r30, r28
    8822:	ef 5b       	subi	r30, 0xBF	; 191
    8824:	ff 4f       	sbci	r31, 0xFF	; 255
    8826:	80 e9       	ldi	r24, 0x90	; 144
    8828:	91 e0       	ldi	r25, 0x01	; 1
    882a:	91 83       	std	Z+1, r25	; 0x01
    882c:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    882e:	fe 01       	movw	r30, r28
    8830:	ef 5b       	subi	r30, 0xBF	; 191
    8832:	ff 4f       	sbci	r31, 0xFF	; 255
    8834:	80 81       	ld	r24, Z
    8836:	91 81       	ldd	r25, Z+1	; 0x01
    8838:	01 97       	sbiw	r24, 0x01	; 1
    883a:	f1 f7       	brne	.-4      	; 0x8838 <LCD_init+0x142>
    883c:	fe 01       	movw	r30, r28
    883e:	ef 5b       	subi	r30, 0xBF	; 191
    8840:	ff 4f       	sbci	r31, 0xFF	; 255
    8842:	91 83       	std	Z+1, r25	; 0x01
    8844:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8846:	de 01       	movw	r26, r28
    8848:	ad 5b       	subi	r26, 0xBD	; 189
    884a:	bf 4f       	sbci	r27, 0xFF	; 255
    884c:	fe 01       	movw	r30, r28
    884e:	ed 5b       	subi	r30, 0xBD	; 189
    8850:	ff 4f       	sbci	r31, 0xFF	; 255
    8852:	80 81       	ld	r24, Z
    8854:	91 81       	ldd	r25, Z+1	; 0x01
    8856:	01 97       	sbiw	r24, 0x01	; 1
    8858:	11 96       	adiw	r26, 0x01	; 1
    885a:	9c 93       	st	X, r25
    885c:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    885e:	fe 01       	movw	r30, r28
    8860:	ed 5b       	subi	r30, 0xBD	; 189
    8862:	ff 4f       	sbci	r31, 0xFF	; 255
    8864:	80 81       	ld	r24, Z
    8866:	91 81       	ldd	r25, Z+1	; 0x01
    8868:	00 97       	sbiw	r24, 0x00	; 0
    886a:	d1 f6       	brne	.-76     	; 0x8820 <LCD_init+0x12a>
    886c:	24 c0       	rjmp	.+72     	; 0x88b6 <LCD_init+0x1c0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    886e:	8e 01       	movw	r16, r28
    8870:	0d 5b       	subi	r16, 0xBD	; 189
    8872:	1f 4f       	sbci	r17, 0xFF	; 255
    8874:	fe 01       	movw	r30, r28
    8876:	eb 5b       	subi	r30, 0xBB	; 187
    8878:	ff 4f       	sbci	r31, 0xFF	; 255
    887a:	60 81       	ld	r22, Z
    887c:	71 81       	ldd	r23, Z+1	; 0x01
    887e:	82 81       	ldd	r24, Z+2	; 0x02
    8880:	93 81       	ldd	r25, Z+3	; 0x03
    8882:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8886:	dc 01       	movw	r26, r24
    8888:	cb 01       	movw	r24, r22
    888a:	f8 01       	movw	r30, r16
    888c:	91 83       	std	Z+1, r25	; 0x01
    888e:	80 83       	st	Z, r24
    8890:	fe 01       	movw	r30, r28
    8892:	ed 5b       	subi	r30, 0xBD	; 189
    8894:	ff 4f       	sbci	r31, 0xFF	; 255
    8896:	80 81       	ld	r24, Z
    8898:	91 81       	ldd	r25, Z+1	; 0x01
    889a:	fe 01       	movw	r30, r28
    889c:	ff 96       	adiw	r30, 0x3f	; 63
    889e:	91 83       	std	Z+1, r25	; 0x01
    88a0:	80 83       	st	Z, r24
    88a2:	fe 01       	movw	r30, r28
    88a4:	ff 96       	adiw	r30, 0x3f	; 63
    88a6:	80 81       	ld	r24, Z
    88a8:	91 81       	ldd	r25, Z+1	; 0x01
    88aa:	01 97       	sbiw	r24, 0x01	; 1
    88ac:	f1 f7       	brne	.-4      	; 0x88aa <LCD_init+0x1b4>
    88ae:	fe 01       	movw	r30, r28
    88b0:	ff 96       	adiw	r30, 0x3f	; 63
    88b2:	91 83       	std	Z+1, r25	; 0x01
    88b4:	80 83       	st	Z, r24

	// Wait more than 30 ms
	_delay_ms(50);
	// Send the function set command
	LCD_function_set_4bit();
    88b6:	0e 94 bd 37 	call	0x6f7a	; 0x6f7a <LCD_function_set_4bit>
    88ba:	80 e0       	ldi	r24, 0x00	; 0
    88bc:	90 e0       	ldi	r25, 0x00	; 0
    88be:	a8 e4       	ldi	r26, 0x48	; 72
    88c0:	b2 e4       	ldi	r27, 0x42	; 66
    88c2:	8b af       	std	Y+59, r24	; 0x3b
    88c4:	9c af       	std	Y+60, r25	; 0x3c
    88c6:	ad af       	std	Y+61, r26	; 0x3d
    88c8:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    88ca:	6b ad       	ldd	r22, Y+59	; 0x3b
    88cc:	7c ad       	ldd	r23, Y+60	; 0x3c
    88ce:	8d ad       	ldd	r24, Y+61	; 0x3d
    88d0:	9e ad       	ldd	r25, Y+62	; 0x3e
    88d2:	2b ea       	ldi	r18, 0xAB	; 171
    88d4:	3a ea       	ldi	r19, 0xAA	; 170
    88d6:	4a ea       	ldi	r20, 0xAA	; 170
    88d8:	50 e4       	ldi	r21, 0x40	; 64
    88da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    88de:	dc 01       	movw	r26, r24
    88e0:	cb 01       	movw	r24, r22
    88e2:	8f ab       	std	Y+55, r24	; 0x37
    88e4:	98 af       	std	Y+56, r25	; 0x38
    88e6:	a9 af       	std	Y+57, r26	; 0x39
    88e8:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    88ea:	6f a9       	ldd	r22, Y+55	; 0x37
    88ec:	78 ad       	ldd	r23, Y+56	; 0x38
    88ee:	89 ad       	ldd	r24, Y+57	; 0x39
    88f0:	9a ad       	ldd	r25, Y+58	; 0x3a
    88f2:	20 e0       	ldi	r18, 0x00	; 0
    88f4:	30 e0       	ldi	r19, 0x00	; 0
    88f6:	40 e8       	ldi	r20, 0x80	; 128
    88f8:	5f e3       	ldi	r21, 0x3F	; 63
    88fa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    88fe:	88 23       	and	r24, r24
    8900:	1c f4       	brge	.+6      	; 0x8908 <LCD_init+0x212>
		__ticks = 1;
    8902:	81 e0       	ldi	r24, 0x01	; 1
    8904:	8e ab       	std	Y+54, r24	; 0x36
    8906:	91 c0       	rjmp	.+290    	; 0x8a2a <LCD_init+0x334>
	else if (__tmp > 255)
    8908:	6f a9       	ldd	r22, Y+55	; 0x37
    890a:	78 ad       	ldd	r23, Y+56	; 0x38
    890c:	89 ad       	ldd	r24, Y+57	; 0x39
    890e:	9a ad       	ldd	r25, Y+58	; 0x3a
    8910:	20 e0       	ldi	r18, 0x00	; 0
    8912:	30 e0       	ldi	r19, 0x00	; 0
    8914:	4f e7       	ldi	r20, 0x7F	; 127
    8916:	53 e4       	ldi	r21, 0x43	; 67
    8918:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    891c:	18 16       	cp	r1, r24
    891e:	0c f0       	brlt	.+2      	; 0x8922 <LCD_init+0x22c>
    8920:	7b c0       	rjmp	.+246    	; 0x8a18 <LCD_init+0x322>
	{
		_delay_ms(__us / 1000.0);
    8922:	6b ad       	ldd	r22, Y+59	; 0x3b
    8924:	7c ad       	ldd	r23, Y+60	; 0x3c
    8926:	8d ad       	ldd	r24, Y+61	; 0x3d
    8928:	9e ad       	ldd	r25, Y+62	; 0x3e
    892a:	20 e0       	ldi	r18, 0x00	; 0
    892c:	30 e0       	ldi	r19, 0x00	; 0
    892e:	4a e7       	ldi	r20, 0x7A	; 122
    8930:	54 e4       	ldi	r21, 0x44	; 68
    8932:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    8936:	dc 01       	movw	r26, r24
    8938:	cb 01       	movw	r24, r22
    893a:	8a ab       	std	Y+50, r24	; 0x32
    893c:	9b ab       	std	Y+51, r25	; 0x33
    893e:	ac ab       	std	Y+52, r26	; 0x34
    8940:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8942:	6a a9       	ldd	r22, Y+50	; 0x32
    8944:	7b a9       	ldd	r23, Y+51	; 0x33
    8946:	8c a9       	ldd	r24, Y+52	; 0x34
    8948:	9d a9       	ldd	r25, Y+53	; 0x35
    894a:	20 e0       	ldi	r18, 0x00	; 0
    894c:	30 e0       	ldi	r19, 0x00	; 0
    894e:	4a e7       	ldi	r20, 0x7A	; 122
    8950:	55 e4       	ldi	r21, 0x45	; 69
    8952:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8956:	dc 01       	movw	r26, r24
    8958:	cb 01       	movw	r24, r22
    895a:	8e a7       	std	Y+46, r24	; 0x2e
    895c:	9f a7       	std	Y+47, r25	; 0x2f
    895e:	a8 ab       	std	Y+48, r26	; 0x30
    8960:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    8962:	6e a5       	ldd	r22, Y+46	; 0x2e
    8964:	7f a5       	ldd	r23, Y+47	; 0x2f
    8966:	88 a9       	ldd	r24, Y+48	; 0x30
    8968:	99 a9       	ldd	r25, Y+49	; 0x31
    896a:	20 e0       	ldi	r18, 0x00	; 0
    896c:	30 e0       	ldi	r19, 0x00	; 0
    896e:	40 e8       	ldi	r20, 0x80	; 128
    8970:	5f e3       	ldi	r21, 0x3F	; 63
    8972:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8976:	88 23       	and	r24, r24
    8978:	2c f4       	brge	.+10     	; 0x8984 <LCD_init+0x28e>
		__ticks = 1;
    897a:	81 e0       	ldi	r24, 0x01	; 1
    897c:	90 e0       	ldi	r25, 0x00	; 0
    897e:	9d a7       	std	Y+45, r25	; 0x2d
    8980:	8c a7       	std	Y+44, r24	; 0x2c
    8982:	3f c0       	rjmp	.+126    	; 0x8a02 <LCD_init+0x30c>
	else if (__tmp > 65535)
    8984:	6e a5       	ldd	r22, Y+46	; 0x2e
    8986:	7f a5       	ldd	r23, Y+47	; 0x2f
    8988:	88 a9       	ldd	r24, Y+48	; 0x30
    898a:	99 a9       	ldd	r25, Y+49	; 0x31
    898c:	20 e0       	ldi	r18, 0x00	; 0
    898e:	3f ef       	ldi	r19, 0xFF	; 255
    8990:	4f e7       	ldi	r20, 0x7F	; 127
    8992:	57 e4       	ldi	r21, 0x47	; 71
    8994:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8998:	18 16       	cp	r1, r24
    899a:	4c f5       	brge	.+82     	; 0x89ee <LCD_init+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    899c:	6a a9       	ldd	r22, Y+50	; 0x32
    899e:	7b a9       	ldd	r23, Y+51	; 0x33
    89a0:	8c a9       	ldd	r24, Y+52	; 0x34
    89a2:	9d a9       	ldd	r25, Y+53	; 0x35
    89a4:	20 e0       	ldi	r18, 0x00	; 0
    89a6:	30 e0       	ldi	r19, 0x00	; 0
    89a8:	40 e2       	ldi	r20, 0x20	; 32
    89aa:	51 e4       	ldi	r21, 0x41	; 65
    89ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    89b0:	dc 01       	movw	r26, r24
    89b2:	cb 01       	movw	r24, r22
    89b4:	bc 01       	movw	r22, r24
    89b6:	cd 01       	movw	r24, r26
    89b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    89bc:	dc 01       	movw	r26, r24
    89be:	cb 01       	movw	r24, r22
    89c0:	9d a7       	std	Y+45, r25	; 0x2d
    89c2:	8c a7       	std	Y+44, r24	; 0x2c
    89c4:	0f c0       	rjmp	.+30     	; 0x89e4 <LCD_init+0x2ee>
    89c6:	80 e9       	ldi	r24, 0x90	; 144
    89c8:	91 e0       	ldi	r25, 0x01	; 1
    89ca:	9b a7       	std	Y+43, r25	; 0x2b
    89cc:	8a a7       	std	Y+42, r24	; 0x2a
    89ce:	8a a5       	ldd	r24, Y+42	; 0x2a
    89d0:	9b a5       	ldd	r25, Y+43	; 0x2b
    89d2:	01 97       	sbiw	r24, 0x01	; 1
    89d4:	f1 f7       	brne	.-4      	; 0x89d2 <LCD_init+0x2dc>
    89d6:	9b a7       	std	Y+43, r25	; 0x2b
    89d8:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    89da:	8c a5       	ldd	r24, Y+44	; 0x2c
    89dc:	9d a5       	ldd	r25, Y+45	; 0x2d
    89de:	01 97       	sbiw	r24, 0x01	; 1
    89e0:	9d a7       	std	Y+45, r25	; 0x2d
    89e2:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    89e4:	8c a5       	ldd	r24, Y+44	; 0x2c
    89e6:	9d a5       	ldd	r25, Y+45	; 0x2d
    89e8:	00 97       	sbiw	r24, 0x00	; 0
    89ea:	69 f7       	brne	.-38     	; 0x89c6 <LCD_init+0x2d0>
    89ec:	24 c0       	rjmp	.+72     	; 0x8a36 <LCD_init+0x340>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    89ee:	6e a5       	ldd	r22, Y+46	; 0x2e
    89f0:	7f a5       	ldd	r23, Y+47	; 0x2f
    89f2:	88 a9       	ldd	r24, Y+48	; 0x30
    89f4:	99 a9       	ldd	r25, Y+49	; 0x31
    89f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    89fa:	dc 01       	movw	r26, r24
    89fc:	cb 01       	movw	r24, r22
    89fe:	9d a7       	std	Y+45, r25	; 0x2d
    8a00:	8c a7       	std	Y+44, r24	; 0x2c
    8a02:	8c a5       	ldd	r24, Y+44	; 0x2c
    8a04:	9d a5       	ldd	r25, Y+45	; 0x2d
    8a06:	99 a7       	std	Y+41, r25	; 0x29
    8a08:	88 a7       	std	Y+40, r24	; 0x28
    8a0a:	88 a5       	ldd	r24, Y+40	; 0x28
    8a0c:	99 a5       	ldd	r25, Y+41	; 0x29
    8a0e:	01 97       	sbiw	r24, 0x01	; 1
    8a10:	f1 f7       	brne	.-4      	; 0x8a0e <LCD_init+0x318>
    8a12:	99 a7       	std	Y+41, r25	; 0x29
    8a14:	88 a7       	std	Y+40, r24	; 0x28
    8a16:	0f c0       	rjmp	.+30     	; 0x8a36 <LCD_init+0x340>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    8a18:	6f a9       	ldd	r22, Y+55	; 0x37
    8a1a:	78 ad       	ldd	r23, Y+56	; 0x38
    8a1c:	89 ad       	ldd	r24, Y+57	; 0x39
    8a1e:	9a ad       	ldd	r25, Y+58	; 0x3a
    8a20:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8a24:	dc 01       	movw	r26, r24
    8a26:	cb 01       	movw	r24, r22
    8a28:	8e ab       	std	Y+54, r24	; 0x36
    8a2a:	8e a9       	ldd	r24, Y+54	; 0x36
    8a2c:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    8a2e:	8f a1       	ldd	r24, Y+39	; 0x27
    8a30:	8a 95       	dec	r24
    8a32:	f1 f7       	brne	.-4      	; 0x8a30 <LCD_init+0x33a>
    8a34:	8f a3       	std	Y+39, r24	; 0x27
	// Wait more than 39 us
	_delay_us(50);
	// Send the display on command
	LCD_write_cmd_4bit(display_on);
    8a36:	8c e0       	ldi	r24, 0x0C	; 12
    8a38:	0e 94 a1 33 	call	0x6742	; 0x6742 <LCD_write_cmd_4bit>
    8a3c:	80 e0       	ldi	r24, 0x00	; 0
    8a3e:	90 e0       	ldi	r25, 0x00	; 0
    8a40:	a8 e4       	ldi	r26, 0x48	; 72
    8a42:	b2 e4       	ldi	r27, 0x42	; 66
    8a44:	8b a3       	std	Y+35, r24	; 0x23
    8a46:	9c a3       	std	Y+36, r25	; 0x24
    8a48:	ad a3       	std	Y+37, r26	; 0x25
    8a4a:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    8a4c:	6b a1       	ldd	r22, Y+35	; 0x23
    8a4e:	7c a1       	ldd	r23, Y+36	; 0x24
    8a50:	8d a1       	ldd	r24, Y+37	; 0x25
    8a52:	9e a1       	ldd	r25, Y+38	; 0x26
    8a54:	2b ea       	ldi	r18, 0xAB	; 171
    8a56:	3a ea       	ldi	r19, 0xAA	; 170
    8a58:	4a ea       	ldi	r20, 0xAA	; 170
    8a5a:	50 e4       	ldi	r21, 0x40	; 64
    8a5c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8a60:	dc 01       	movw	r26, r24
    8a62:	cb 01       	movw	r24, r22
    8a64:	8f 8f       	std	Y+31, r24	; 0x1f
    8a66:	98 a3       	std	Y+32, r25	; 0x20
    8a68:	a9 a3       	std	Y+33, r26	; 0x21
    8a6a:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    8a6c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    8a6e:	78 a1       	ldd	r23, Y+32	; 0x20
    8a70:	89 a1       	ldd	r24, Y+33	; 0x21
    8a72:	9a a1       	ldd	r25, Y+34	; 0x22
    8a74:	20 e0       	ldi	r18, 0x00	; 0
    8a76:	30 e0       	ldi	r19, 0x00	; 0
    8a78:	40 e8       	ldi	r20, 0x80	; 128
    8a7a:	5f e3       	ldi	r21, 0x3F	; 63
    8a7c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8a80:	88 23       	and	r24, r24
    8a82:	1c f4       	brge	.+6      	; 0x8a8a <LCD_init+0x394>
		__ticks = 1;
    8a84:	81 e0       	ldi	r24, 0x01	; 1
    8a86:	8e 8f       	std	Y+30, r24	; 0x1e
    8a88:	91 c0       	rjmp	.+290    	; 0x8bac <LCD_init+0x4b6>
	else if (__tmp > 255)
    8a8a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    8a8c:	78 a1       	ldd	r23, Y+32	; 0x20
    8a8e:	89 a1       	ldd	r24, Y+33	; 0x21
    8a90:	9a a1       	ldd	r25, Y+34	; 0x22
    8a92:	20 e0       	ldi	r18, 0x00	; 0
    8a94:	30 e0       	ldi	r19, 0x00	; 0
    8a96:	4f e7       	ldi	r20, 0x7F	; 127
    8a98:	53 e4       	ldi	r21, 0x43	; 67
    8a9a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8a9e:	18 16       	cp	r1, r24
    8aa0:	0c f0       	brlt	.+2      	; 0x8aa4 <LCD_init+0x3ae>
    8aa2:	7b c0       	rjmp	.+246    	; 0x8b9a <LCD_init+0x4a4>
	{
		_delay_ms(__us / 1000.0);
    8aa4:	6b a1       	ldd	r22, Y+35	; 0x23
    8aa6:	7c a1       	ldd	r23, Y+36	; 0x24
    8aa8:	8d a1       	ldd	r24, Y+37	; 0x25
    8aaa:	9e a1       	ldd	r25, Y+38	; 0x26
    8aac:	20 e0       	ldi	r18, 0x00	; 0
    8aae:	30 e0       	ldi	r19, 0x00	; 0
    8ab0:	4a e7       	ldi	r20, 0x7A	; 122
    8ab2:	54 e4       	ldi	r21, 0x44	; 68
    8ab4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    8ab8:	dc 01       	movw	r26, r24
    8aba:	cb 01       	movw	r24, r22
    8abc:	8a 8f       	std	Y+26, r24	; 0x1a
    8abe:	9b 8f       	std	Y+27, r25	; 0x1b
    8ac0:	ac 8f       	std	Y+28, r26	; 0x1c
    8ac2:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8ac4:	6a 8d       	ldd	r22, Y+26	; 0x1a
    8ac6:	7b 8d       	ldd	r23, Y+27	; 0x1b
    8ac8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    8aca:	9d 8d       	ldd	r25, Y+29	; 0x1d
    8acc:	20 e0       	ldi	r18, 0x00	; 0
    8ace:	30 e0       	ldi	r19, 0x00	; 0
    8ad0:	4a e7       	ldi	r20, 0x7A	; 122
    8ad2:	55 e4       	ldi	r21, 0x45	; 69
    8ad4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8ad8:	dc 01       	movw	r26, r24
    8ada:	cb 01       	movw	r24, r22
    8adc:	8e 8b       	std	Y+22, r24	; 0x16
    8ade:	9f 8b       	std	Y+23, r25	; 0x17
    8ae0:	a8 8f       	std	Y+24, r26	; 0x18
    8ae2:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    8ae4:	6e 89       	ldd	r22, Y+22	; 0x16
    8ae6:	7f 89       	ldd	r23, Y+23	; 0x17
    8ae8:	88 8d       	ldd	r24, Y+24	; 0x18
    8aea:	99 8d       	ldd	r25, Y+25	; 0x19
    8aec:	20 e0       	ldi	r18, 0x00	; 0
    8aee:	30 e0       	ldi	r19, 0x00	; 0
    8af0:	40 e8       	ldi	r20, 0x80	; 128
    8af2:	5f e3       	ldi	r21, 0x3F	; 63
    8af4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8af8:	88 23       	and	r24, r24
    8afa:	2c f4       	brge	.+10     	; 0x8b06 <LCD_init+0x410>
		__ticks = 1;
    8afc:	81 e0       	ldi	r24, 0x01	; 1
    8afe:	90 e0       	ldi	r25, 0x00	; 0
    8b00:	9d 8b       	std	Y+21, r25	; 0x15
    8b02:	8c 8b       	std	Y+20, r24	; 0x14
    8b04:	3f c0       	rjmp	.+126    	; 0x8b84 <LCD_init+0x48e>
	else if (__tmp > 65535)
    8b06:	6e 89       	ldd	r22, Y+22	; 0x16
    8b08:	7f 89       	ldd	r23, Y+23	; 0x17
    8b0a:	88 8d       	ldd	r24, Y+24	; 0x18
    8b0c:	99 8d       	ldd	r25, Y+25	; 0x19
    8b0e:	20 e0       	ldi	r18, 0x00	; 0
    8b10:	3f ef       	ldi	r19, 0xFF	; 255
    8b12:	4f e7       	ldi	r20, 0x7F	; 127
    8b14:	57 e4       	ldi	r21, 0x47	; 71
    8b16:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8b1a:	18 16       	cp	r1, r24
    8b1c:	4c f5       	brge	.+82     	; 0x8b70 <LCD_init+0x47a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8b1e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    8b20:	7b 8d       	ldd	r23, Y+27	; 0x1b
    8b22:	8c 8d       	ldd	r24, Y+28	; 0x1c
    8b24:	9d 8d       	ldd	r25, Y+29	; 0x1d
    8b26:	20 e0       	ldi	r18, 0x00	; 0
    8b28:	30 e0       	ldi	r19, 0x00	; 0
    8b2a:	40 e2       	ldi	r20, 0x20	; 32
    8b2c:	51 e4       	ldi	r21, 0x41	; 65
    8b2e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8b32:	dc 01       	movw	r26, r24
    8b34:	cb 01       	movw	r24, r22
    8b36:	bc 01       	movw	r22, r24
    8b38:	cd 01       	movw	r24, r26
    8b3a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8b3e:	dc 01       	movw	r26, r24
    8b40:	cb 01       	movw	r24, r22
    8b42:	9d 8b       	std	Y+21, r25	; 0x15
    8b44:	8c 8b       	std	Y+20, r24	; 0x14
    8b46:	0f c0       	rjmp	.+30     	; 0x8b66 <LCD_init+0x470>
    8b48:	80 e9       	ldi	r24, 0x90	; 144
    8b4a:	91 e0       	ldi	r25, 0x01	; 1
    8b4c:	9b 8b       	std	Y+19, r25	; 0x13
    8b4e:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    8b50:	8a 89       	ldd	r24, Y+18	; 0x12
    8b52:	9b 89       	ldd	r25, Y+19	; 0x13
    8b54:	01 97       	sbiw	r24, 0x01	; 1
    8b56:	f1 f7       	brne	.-4      	; 0x8b54 <LCD_init+0x45e>
    8b58:	9b 8b       	std	Y+19, r25	; 0x13
    8b5a:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8b5c:	8c 89       	ldd	r24, Y+20	; 0x14
    8b5e:	9d 89       	ldd	r25, Y+21	; 0x15
    8b60:	01 97       	sbiw	r24, 0x01	; 1
    8b62:	9d 8b       	std	Y+21, r25	; 0x15
    8b64:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8b66:	8c 89       	ldd	r24, Y+20	; 0x14
    8b68:	9d 89       	ldd	r25, Y+21	; 0x15
    8b6a:	00 97       	sbiw	r24, 0x00	; 0
    8b6c:	69 f7       	brne	.-38     	; 0x8b48 <LCD_init+0x452>
    8b6e:	24 c0       	rjmp	.+72     	; 0x8bb8 <LCD_init+0x4c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8b70:	6e 89       	ldd	r22, Y+22	; 0x16
    8b72:	7f 89       	ldd	r23, Y+23	; 0x17
    8b74:	88 8d       	ldd	r24, Y+24	; 0x18
    8b76:	99 8d       	ldd	r25, Y+25	; 0x19
    8b78:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8b7c:	dc 01       	movw	r26, r24
    8b7e:	cb 01       	movw	r24, r22
    8b80:	9d 8b       	std	Y+21, r25	; 0x15
    8b82:	8c 8b       	std	Y+20, r24	; 0x14
    8b84:	8c 89       	ldd	r24, Y+20	; 0x14
    8b86:	9d 89       	ldd	r25, Y+21	; 0x15
    8b88:	99 8b       	std	Y+17, r25	; 0x11
    8b8a:	88 8b       	std	Y+16, r24	; 0x10
    8b8c:	88 89       	ldd	r24, Y+16	; 0x10
    8b8e:	99 89       	ldd	r25, Y+17	; 0x11
    8b90:	01 97       	sbiw	r24, 0x01	; 1
    8b92:	f1 f7       	brne	.-4      	; 0x8b90 <LCD_init+0x49a>
    8b94:	99 8b       	std	Y+17, r25	; 0x11
    8b96:	88 8b       	std	Y+16, r24	; 0x10
    8b98:	0f c0       	rjmp	.+30     	; 0x8bb8 <LCD_init+0x4c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    8b9a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    8b9c:	78 a1       	ldd	r23, Y+32	; 0x20
    8b9e:	89 a1       	ldd	r24, Y+33	; 0x21
    8ba0:	9a a1       	ldd	r25, Y+34	; 0x22
    8ba2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8ba6:	dc 01       	movw	r26, r24
    8ba8:	cb 01       	movw	r24, r22
    8baa:	8e 8f       	std	Y+30, r24	; 0x1e
    8bac:	8e 8d       	ldd	r24, Y+30	; 0x1e
    8bae:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    8bb0:	8f 85       	ldd	r24, Y+15	; 0x0f
    8bb2:	8a 95       	dec	r24
    8bb4:	f1 f7       	brne	.-4      	; 0x8bb2 <LCD_init+0x4bc>
    8bb6:	8f 87       	std	Y+15, r24	; 0x0f
	// Wait more than 39 us
	_delay_us(50);
	// Send the display clean command
	LCD_write_cmd_4bit(display_clear);
    8bb8:	81 e0       	ldi	r24, 0x01	; 1
    8bba:	0e 94 a1 33 	call	0x6742	; 0x6742 <LCD_write_cmd_4bit>
    8bbe:	80 e0       	ldi	r24, 0x00	; 0
    8bc0:	90 e0       	ldi	r25, 0x00	; 0
    8bc2:	a0 e0       	ldi	r26, 0x00	; 0
    8bc4:	b0 e4       	ldi	r27, 0x40	; 64
    8bc6:	8b 87       	std	Y+11, r24	; 0x0b
    8bc8:	9c 87       	std	Y+12, r25	; 0x0c
    8bca:	ad 87       	std	Y+13, r26	; 0x0d
    8bcc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8bce:	6b 85       	ldd	r22, Y+11	; 0x0b
    8bd0:	7c 85       	ldd	r23, Y+12	; 0x0c
    8bd2:	8d 85       	ldd	r24, Y+13	; 0x0d
    8bd4:	9e 85       	ldd	r25, Y+14	; 0x0e
    8bd6:	20 e0       	ldi	r18, 0x00	; 0
    8bd8:	30 e0       	ldi	r19, 0x00	; 0
    8bda:	4a e7       	ldi	r20, 0x7A	; 122
    8bdc:	55 e4       	ldi	r21, 0x45	; 69
    8bde:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8be2:	dc 01       	movw	r26, r24
    8be4:	cb 01       	movw	r24, r22
    8be6:	8f 83       	std	Y+7, r24	; 0x07
    8be8:	98 87       	std	Y+8, r25	; 0x08
    8bea:	a9 87       	std	Y+9, r26	; 0x09
    8bec:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    8bee:	6f 81       	ldd	r22, Y+7	; 0x07
    8bf0:	78 85       	ldd	r23, Y+8	; 0x08
    8bf2:	89 85       	ldd	r24, Y+9	; 0x09
    8bf4:	9a 85       	ldd	r25, Y+10	; 0x0a
    8bf6:	20 e0       	ldi	r18, 0x00	; 0
    8bf8:	30 e0       	ldi	r19, 0x00	; 0
    8bfa:	40 e8       	ldi	r20, 0x80	; 128
    8bfc:	5f e3       	ldi	r21, 0x3F	; 63
    8bfe:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8c02:	88 23       	and	r24, r24
    8c04:	2c f4       	brge	.+10     	; 0x8c10 <LCD_init+0x51a>
		__ticks = 1;
    8c06:	81 e0       	ldi	r24, 0x01	; 1
    8c08:	90 e0       	ldi	r25, 0x00	; 0
    8c0a:	9e 83       	std	Y+6, r25	; 0x06
    8c0c:	8d 83       	std	Y+5, r24	; 0x05
    8c0e:	3f c0       	rjmp	.+126    	; 0x8c8e <LCD_init+0x598>
	else if (__tmp > 65535)
    8c10:	6f 81       	ldd	r22, Y+7	; 0x07
    8c12:	78 85       	ldd	r23, Y+8	; 0x08
    8c14:	89 85       	ldd	r24, Y+9	; 0x09
    8c16:	9a 85       	ldd	r25, Y+10	; 0x0a
    8c18:	20 e0       	ldi	r18, 0x00	; 0
    8c1a:	3f ef       	ldi	r19, 0xFF	; 255
    8c1c:	4f e7       	ldi	r20, 0x7F	; 127
    8c1e:	57 e4       	ldi	r21, 0x47	; 71
    8c20:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8c24:	18 16       	cp	r1, r24
    8c26:	4c f5       	brge	.+82     	; 0x8c7a <LCD_init+0x584>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8c28:	6b 85       	ldd	r22, Y+11	; 0x0b
    8c2a:	7c 85       	ldd	r23, Y+12	; 0x0c
    8c2c:	8d 85       	ldd	r24, Y+13	; 0x0d
    8c2e:	9e 85       	ldd	r25, Y+14	; 0x0e
    8c30:	20 e0       	ldi	r18, 0x00	; 0
    8c32:	30 e0       	ldi	r19, 0x00	; 0
    8c34:	40 e2       	ldi	r20, 0x20	; 32
    8c36:	51 e4       	ldi	r21, 0x41	; 65
    8c38:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8c3c:	dc 01       	movw	r26, r24
    8c3e:	cb 01       	movw	r24, r22
    8c40:	bc 01       	movw	r22, r24
    8c42:	cd 01       	movw	r24, r26
    8c44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8c48:	dc 01       	movw	r26, r24
    8c4a:	cb 01       	movw	r24, r22
    8c4c:	9e 83       	std	Y+6, r25	; 0x06
    8c4e:	8d 83       	std	Y+5, r24	; 0x05
    8c50:	0f c0       	rjmp	.+30     	; 0x8c70 <LCD_init+0x57a>
    8c52:	80 e9       	ldi	r24, 0x90	; 144
    8c54:	91 e0       	ldi	r25, 0x01	; 1
    8c56:	9c 83       	std	Y+4, r25	; 0x04
    8c58:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    8c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    8c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    8c5e:	01 97       	sbiw	r24, 0x01	; 1
    8c60:	f1 f7       	brne	.-4      	; 0x8c5e <LCD_init+0x568>
    8c62:	9c 83       	std	Y+4, r25	; 0x04
    8c64:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8c66:	8d 81       	ldd	r24, Y+5	; 0x05
    8c68:	9e 81       	ldd	r25, Y+6	; 0x06
    8c6a:	01 97       	sbiw	r24, 0x01	; 1
    8c6c:	9e 83       	std	Y+6, r25	; 0x06
    8c6e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8c70:	8d 81       	ldd	r24, Y+5	; 0x05
    8c72:	9e 81       	ldd	r25, Y+6	; 0x06
    8c74:	00 97       	sbiw	r24, 0x00	; 0
    8c76:	69 f7       	brne	.-38     	; 0x8c52 <LCD_init+0x55c>
    8c78:	14 c0       	rjmp	.+40     	; 0x8ca2 <LCD_init+0x5ac>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8c7a:	6f 81       	ldd	r22, Y+7	; 0x07
    8c7c:	78 85       	ldd	r23, Y+8	; 0x08
    8c7e:	89 85       	ldd	r24, Y+9	; 0x09
    8c80:	9a 85       	ldd	r25, Y+10	; 0x0a
    8c82:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8c86:	dc 01       	movw	r26, r24
    8c88:	cb 01       	movw	r24, r22
    8c8a:	9e 83       	std	Y+6, r25	; 0x06
    8c8c:	8d 83       	std	Y+5, r24	; 0x05
    8c8e:	8d 81       	ldd	r24, Y+5	; 0x05
    8c90:	9e 81       	ldd	r25, Y+6	; 0x06
    8c92:	9a 83       	std	Y+2, r25	; 0x02
    8c94:	89 83       	std	Y+1, r24	; 0x01
    8c96:	89 81       	ldd	r24, Y+1	; 0x01
    8c98:	9a 81       	ldd	r25, Y+2	; 0x02
    8c9a:	01 97       	sbiw	r24, 0x01	; 1
    8c9c:	f1 f7       	brne	.-4      	; 0x8c9a <LCD_init+0x5a4>
    8c9e:	9a 83       	std	Y+2, r25	; 0x02
    8ca0:	89 83       	std	Y+1, r24	; 0x01
	// Wait more than 1.53 ms
	_delay_ms(2);
#endif
}
    8ca2:	c4 5b       	subi	r28, 0xB4	; 180
    8ca4:	df 4f       	sbci	r29, 0xFF	; 255
    8ca6:	0f b6       	in	r0, 0x3f	; 63
    8ca8:	f8 94       	cli
    8caa:	de bf       	out	0x3e, r29	; 62
    8cac:	0f be       	out	0x3f, r0	; 63
    8cae:	cd bf       	out	0x3d, r28	; 61
    8cb0:	cf 91       	pop	r28
    8cb2:	df 91       	pop	r29
    8cb4:	1f 91       	pop	r17
    8cb6:	0f 91       	pop	r16
    8cb8:	08 95       	ret

00008cba <LCD_set_cursor>:

void LCD_set_cursor(u8 copy_u8_row, u8 copy_u8_column){
    8cba:	df 93       	push	r29
    8cbc:	cf 93       	push	r28
    8cbe:	cd b7       	in	r28, 0x3d	; 61
    8cc0:	de b7       	in	r29, 0x3e	; 62
    8cc2:	6b 97       	sbiw	r28, 0x1b	; 27
    8cc4:	0f b6       	in	r0, 0x3f	; 63
    8cc6:	f8 94       	cli
    8cc8:	de bf       	out	0x3e, r29	; 62
    8cca:	0f be       	out	0x3f, r0	; 63
    8ccc:	cd bf       	out	0x3d, r28	; 61
    8cce:	8a 8f       	std	Y+26, r24	; 0x1a
    8cd0:	6b 8f       	std	Y+27, r22	; 0x1b
	LCD_write_cmd_8bit(address);
	// wait more than 39 us
	_delay_us(50);
#elif _LCD_interface_ == _4bit_interface
	// calculate the addres from the given rows and columns
	u8 address= 128+(copy_u8_row*line2)+(copy_u8_column);
    8cd2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8cd4:	88 2f       	mov	r24, r24
    8cd6:	90 e0       	ldi	r25, 0x00	; 0
    8cd8:	02 96       	adiw	r24, 0x02	; 2
    8cda:	00 24       	eor	r0, r0
    8cdc:	96 95       	lsr	r25
    8cde:	87 95       	ror	r24
    8ce0:	07 94       	ror	r0
    8ce2:	96 95       	lsr	r25
    8ce4:	87 95       	ror	r24
    8ce6:	07 94       	ror	r0
    8ce8:	98 2f       	mov	r25, r24
    8cea:	80 2d       	mov	r24, r0
    8cec:	98 2f       	mov	r25, r24
    8cee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8cf0:	89 0f       	add	r24, r25
    8cf2:	89 8f       	std	Y+25, r24	; 0x19
	// Sent set address command
	LCD_write_cmd_4bit(address);
    8cf4:	89 8d       	ldd	r24, Y+25	; 0x19
    8cf6:	0e 94 a1 33 	call	0x6742	; 0x6742 <LCD_write_cmd_4bit>
    8cfa:	80 e0       	ldi	r24, 0x00	; 0
    8cfc:	90 e0       	ldi	r25, 0x00	; 0
    8cfe:	a8 e4       	ldi	r26, 0x48	; 72
    8d00:	b2 e4       	ldi	r27, 0x42	; 66
    8d02:	8d 8b       	std	Y+21, r24	; 0x15
    8d04:	9e 8b       	std	Y+22, r25	; 0x16
    8d06:	af 8b       	std	Y+23, r26	; 0x17
    8d08:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    8d0a:	6d 89       	ldd	r22, Y+21	; 0x15
    8d0c:	7e 89       	ldd	r23, Y+22	; 0x16
    8d0e:	8f 89       	ldd	r24, Y+23	; 0x17
    8d10:	98 8d       	ldd	r25, Y+24	; 0x18
    8d12:	2b ea       	ldi	r18, 0xAB	; 171
    8d14:	3a ea       	ldi	r19, 0xAA	; 170
    8d16:	4a ea       	ldi	r20, 0xAA	; 170
    8d18:	50 e4       	ldi	r21, 0x40	; 64
    8d1a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8d1e:	dc 01       	movw	r26, r24
    8d20:	cb 01       	movw	r24, r22
    8d22:	89 8b       	std	Y+17, r24	; 0x11
    8d24:	9a 8b       	std	Y+18, r25	; 0x12
    8d26:	ab 8b       	std	Y+19, r26	; 0x13
    8d28:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    8d2a:	69 89       	ldd	r22, Y+17	; 0x11
    8d2c:	7a 89       	ldd	r23, Y+18	; 0x12
    8d2e:	8b 89       	ldd	r24, Y+19	; 0x13
    8d30:	9c 89       	ldd	r25, Y+20	; 0x14
    8d32:	20 e0       	ldi	r18, 0x00	; 0
    8d34:	30 e0       	ldi	r19, 0x00	; 0
    8d36:	40 e8       	ldi	r20, 0x80	; 128
    8d38:	5f e3       	ldi	r21, 0x3F	; 63
    8d3a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8d3e:	88 23       	and	r24, r24
    8d40:	1c f4       	brge	.+6      	; 0x8d48 <LCD_set_cursor+0x8e>
		__ticks = 1;
    8d42:	81 e0       	ldi	r24, 0x01	; 1
    8d44:	88 8b       	std	Y+16, r24	; 0x10
    8d46:	91 c0       	rjmp	.+290    	; 0x8e6a <LCD_set_cursor+0x1b0>
	else if (__tmp > 255)
    8d48:	69 89       	ldd	r22, Y+17	; 0x11
    8d4a:	7a 89       	ldd	r23, Y+18	; 0x12
    8d4c:	8b 89       	ldd	r24, Y+19	; 0x13
    8d4e:	9c 89       	ldd	r25, Y+20	; 0x14
    8d50:	20 e0       	ldi	r18, 0x00	; 0
    8d52:	30 e0       	ldi	r19, 0x00	; 0
    8d54:	4f e7       	ldi	r20, 0x7F	; 127
    8d56:	53 e4       	ldi	r21, 0x43	; 67
    8d58:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8d5c:	18 16       	cp	r1, r24
    8d5e:	0c f0       	brlt	.+2      	; 0x8d62 <LCD_set_cursor+0xa8>
    8d60:	7b c0       	rjmp	.+246    	; 0x8e58 <LCD_set_cursor+0x19e>
	{
		_delay_ms(__us / 1000.0);
    8d62:	6d 89       	ldd	r22, Y+21	; 0x15
    8d64:	7e 89       	ldd	r23, Y+22	; 0x16
    8d66:	8f 89       	ldd	r24, Y+23	; 0x17
    8d68:	98 8d       	ldd	r25, Y+24	; 0x18
    8d6a:	20 e0       	ldi	r18, 0x00	; 0
    8d6c:	30 e0       	ldi	r19, 0x00	; 0
    8d6e:	4a e7       	ldi	r20, 0x7A	; 122
    8d70:	54 e4       	ldi	r21, 0x44	; 68
    8d72:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    8d76:	dc 01       	movw	r26, r24
    8d78:	cb 01       	movw	r24, r22
    8d7a:	8c 87       	std	Y+12, r24	; 0x0c
    8d7c:	9d 87       	std	Y+13, r25	; 0x0d
    8d7e:	ae 87       	std	Y+14, r26	; 0x0e
    8d80:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8d82:	6c 85       	ldd	r22, Y+12	; 0x0c
    8d84:	7d 85       	ldd	r23, Y+13	; 0x0d
    8d86:	8e 85       	ldd	r24, Y+14	; 0x0e
    8d88:	9f 85       	ldd	r25, Y+15	; 0x0f
    8d8a:	20 e0       	ldi	r18, 0x00	; 0
    8d8c:	30 e0       	ldi	r19, 0x00	; 0
    8d8e:	4a e7       	ldi	r20, 0x7A	; 122
    8d90:	55 e4       	ldi	r21, 0x45	; 69
    8d92:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8d96:	dc 01       	movw	r26, r24
    8d98:	cb 01       	movw	r24, r22
    8d9a:	88 87       	std	Y+8, r24	; 0x08
    8d9c:	99 87       	std	Y+9, r25	; 0x09
    8d9e:	aa 87       	std	Y+10, r26	; 0x0a
    8da0:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    8da2:	68 85       	ldd	r22, Y+8	; 0x08
    8da4:	79 85       	ldd	r23, Y+9	; 0x09
    8da6:	8a 85       	ldd	r24, Y+10	; 0x0a
    8da8:	9b 85       	ldd	r25, Y+11	; 0x0b
    8daa:	20 e0       	ldi	r18, 0x00	; 0
    8dac:	30 e0       	ldi	r19, 0x00	; 0
    8dae:	40 e8       	ldi	r20, 0x80	; 128
    8db0:	5f e3       	ldi	r21, 0x3F	; 63
    8db2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8db6:	88 23       	and	r24, r24
    8db8:	2c f4       	brge	.+10     	; 0x8dc4 <LCD_set_cursor+0x10a>
		__ticks = 1;
    8dba:	81 e0       	ldi	r24, 0x01	; 1
    8dbc:	90 e0       	ldi	r25, 0x00	; 0
    8dbe:	9f 83       	std	Y+7, r25	; 0x07
    8dc0:	8e 83       	std	Y+6, r24	; 0x06
    8dc2:	3f c0       	rjmp	.+126    	; 0x8e42 <LCD_set_cursor+0x188>
	else if (__tmp > 65535)
    8dc4:	68 85       	ldd	r22, Y+8	; 0x08
    8dc6:	79 85       	ldd	r23, Y+9	; 0x09
    8dc8:	8a 85       	ldd	r24, Y+10	; 0x0a
    8dca:	9b 85       	ldd	r25, Y+11	; 0x0b
    8dcc:	20 e0       	ldi	r18, 0x00	; 0
    8dce:	3f ef       	ldi	r19, 0xFF	; 255
    8dd0:	4f e7       	ldi	r20, 0x7F	; 127
    8dd2:	57 e4       	ldi	r21, 0x47	; 71
    8dd4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8dd8:	18 16       	cp	r1, r24
    8dda:	4c f5       	brge	.+82     	; 0x8e2e <LCD_set_cursor+0x174>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8ddc:	6c 85       	ldd	r22, Y+12	; 0x0c
    8dde:	7d 85       	ldd	r23, Y+13	; 0x0d
    8de0:	8e 85       	ldd	r24, Y+14	; 0x0e
    8de2:	9f 85       	ldd	r25, Y+15	; 0x0f
    8de4:	20 e0       	ldi	r18, 0x00	; 0
    8de6:	30 e0       	ldi	r19, 0x00	; 0
    8de8:	40 e2       	ldi	r20, 0x20	; 32
    8dea:	51 e4       	ldi	r21, 0x41	; 65
    8dec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8df0:	dc 01       	movw	r26, r24
    8df2:	cb 01       	movw	r24, r22
    8df4:	bc 01       	movw	r22, r24
    8df6:	cd 01       	movw	r24, r26
    8df8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8dfc:	dc 01       	movw	r26, r24
    8dfe:	cb 01       	movw	r24, r22
    8e00:	9f 83       	std	Y+7, r25	; 0x07
    8e02:	8e 83       	std	Y+6, r24	; 0x06
    8e04:	0f c0       	rjmp	.+30     	; 0x8e24 <LCD_set_cursor+0x16a>
    8e06:	80 e9       	ldi	r24, 0x90	; 144
    8e08:	91 e0       	ldi	r25, 0x01	; 1
    8e0a:	9d 83       	std	Y+5, r25	; 0x05
    8e0c:	8c 83       	std	Y+4, r24	; 0x04
    8e0e:	8c 81       	ldd	r24, Y+4	; 0x04
    8e10:	9d 81       	ldd	r25, Y+5	; 0x05
    8e12:	01 97       	sbiw	r24, 0x01	; 1
    8e14:	f1 f7       	brne	.-4      	; 0x8e12 <LCD_set_cursor+0x158>
    8e16:	9d 83       	std	Y+5, r25	; 0x05
    8e18:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8e1a:	8e 81       	ldd	r24, Y+6	; 0x06
    8e1c:	9f 81       	ldd	r25, Y+7	; 0x07
    8e1e:	01 97       	sbiw	r24, 0x01	; 1
    8e20:	9f 83       	std	Y+7, r25	; 0x07
    8e22:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8e24:	8e 81       	ldd	r24, Y+6	; 0x06
    8e26:	9f 81       	ldd	r25, Y+7	; 0x07
    8e28:	00 97       	sbiw	r24, 0x00	; 0
    8e2a:	69 f7       	brne	.-38     	; 0x8e06 <LCD_set_cursor+0x14c>
    8e2c:	24 c0       	rjmp	.+72     	; 0x8e76 <LCD_set_cursor+0x1bc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8e2e:	68 85       	ldd	r22, Y+8	; 0x08
    8e30:	79 85       	ldd	r23, Y+9	; 0x09
    8e32:	8a 85       	ldd	r24, Y+10	; 0x0a
    8e34:	9b 85       	ldd	r25, Y+11	; 0x0b
    8e36:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8e3a:	dc 01       	movw	r26, r24
    8e3c:	cb 01       	movw	r24, r22
    8e3e:	9f 83       	std	Y+7, r25	; 0x07
    8e40:	8e 83       	std	Y+6, r24	; 0x06
    8e42:	8e 81       	ldd	r24, Y+6	; 0x06
    8e44:	9f 81       	ldd	r25, Y+7	; 0x07
    8e46:	9b 83       	std	Y+3, r25	; 0x03
    8e48:	8a 83       	std	Y+2, r24	; 0x02
    8e4a:	8a 81       	ldd	r24, Y+2	; 0x02
    8e4c:	9b 81       	ldd	r25, Y+3	; 0x03
    8e4e:	01 97       	sbiw	r24, 0x01	; 1
    8e50:	f1 f7       	brne	.-4      	; 0x8e4e <LCD_set_cursor+0x194>
    8e52:	9b 83       	std	Y+3, r25	; 0x03
    8e54:	8a 83       	std	Y+2, r24	; 0x02
    8e56:	0f c0       	rjmp	.+30     	; 0x8e76 <LCD_set_cursor+0x1bc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    8e58:	69 89       	ldd	r22, Y+17	; 0x11
    8e5a:	7a 89       	ldd	r23, Y+18	; 0x12
    8e5c:	8b 89       	ldd	r24, Y+19	; 0x13
    8e5e:	9c 89       	ldd	r25, Y+20	; 0x14
    8e60:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8e64:	dc 01       	movw	r26, r24
    8e66:	cb 01       	movw	r24, r22
    8e68:	88 8b       	std	Y+16, r24	; 0x10
    8e6a:	88 89       	ldd	r24, Y+16	; 0x10
    8e6c:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    8e6e:	89 81       	ldd	r24, Y+1	; 0x01
    8e70:	8a 95       	dec	r24
    8e72:	f1 f7       	brne	.-4      	; 0x8e70 <LCD_set_cursor+0x1b6>
    8e74:	89 83       	std	Y+1, r24	; 0x01
	// wait more than 39 us
	_delay_us(50);
#endif
}
    8e76:	6b 96       	adiw	r28, 0x1b	; 27
    8e78:	0f b6       	in	r0, 0x3f	; 63
    8e7a:	f8 94       	cli
    8e7c:	de bf       	out	0x3e, r29	; 62
    8e7e:	0f be       	out	0x3f, r0	; 63
    8e80:	cd bf       	out	0x3d, r28	; 61
    8e82:	cf 91       	pop	r28
    8e84:	df 91       	pop	r29
    8e86:	08 95       	ret

00008e88 <LCD_clear>:

void LCD_clear(void){
    8e88:	df 93       	push	r29
    8e8a:	cf 93       	push	r28
    8e8c:	cd b7       	in	r28, 0x3d	; 61
    8e8e:	de b7       	in	r29, 0x3e	; 62
    8e90:	6c 97       	sbiw	r28, 0x1c	; 28
    8e92:	0f b6       	in	r0, 0x3f	; 63
    8e94:	f8 94       	cli
    8e96:	de bf       	out	0x3e, r29	; 62
    8e98:	0f be       	out	0x3f, r0	; 63
    8e9a:	cd bf       	out	0x3d, r28	; 61
	LCD_write_cmd_8bit(return_home);
	// wait more than 39 us
	_delay_ms(2);
#elif _LCD_interface_ == _4bit_interface
	// Send Display clear command
	LCD_write_cmd_4bit(display_clear);
    8e9c:	81 e0       	ldi	r24, 0x01	; 1
    8e9e:	0e 94 a1 33 	call	0x6742	; 0x6742 <LCD_write_cmd_4bit>
    8ea2:	80 e0       	ldi	r24, 0x00	; 0
    8ea4:	90 e0       	ldi	r25, 0x00	; 0
    8ea6:	a0 e0       	ldi	r26, 0x00	; 0
    8ea8:	b0 e4       	ldi	r27, 0x40	; 64
    8eaa:	89 8f       	std	Y+25, r24	; 0x19
    8eac:	9a 8f       	std	Y+26, r25	; 0x1a
    8eae:	ab 8f       	std	Y+27, r26	; 0x1b
    8eb0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8eb2:	69 8d       	ldd	r22, Y+25	; 0x19
    8eb4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8eb6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8eb8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    8eba:	20 e0       	ldi	r18, 0x00	; 0
    8ebc:	30 e0       	ldi	r19, 0x00	; 0
    8ebe:	4a e7       	ldi	r20, 0x7A	; 122
    8ec0:	55 e4       	ldi	r21, 0x45	; 69
    8ec2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8ec6:	dc 01       	movw	r26, r24
    8ec8:	cb 01       	movw	r24, r22
    8eca:	8d 8b       	std	Y+21, r24	; 0x15
    8ecc:	9e 8b       	std	Y+22, r25	; 0x16
    8ece:	af 8b       	std	Y+23, r26	; 0x17
    8ed0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    8ed2:	6d 89       	ldd	r22, Y+21	; 0x15
    8ed4:	7e 89       	ldd	r23, Y+22	; 0x16
    8ed6:	8f 89       	ldd	r24, Y+23	; 0x17
    8ed8:	98 8d       	ldd	r25, Y+24	; 0x18
    8eda:	20 e0       	ldi	r18, 0x00	; 0
    8edc:	30 e0       	ldi	r19, 0x00	; 0
    8ede:	40 e8       	ldi	r20, 0x80	; 128
    8ee0:	5f e3       	ldi	r21, 0x3F	; 63
    8ee2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8ee6:	88 23       	and	r24, r24
    8ee8:	2c f4       	brge	.+10     	; 0x8ef4 <LCD_clear+0x6c>
		__ticks = 1;
    8eea:	81 e0       	ldi	r24, 0x01	; 1
    8eec:	90 e0       	ldi	r25, 0x00	; 0
    8eee:	9c 8b       	std	Y+20, r25	; 0x14
    8ef0:	8b 8b       	std	Y+19, r24	; 0x13
    8ef2:	3f c0       	rjmp	.+126    	; 0x8f72 <LCD_clear+0xea>
	else if (__tmp > 65535)
    8ef4:	6d 89       	ldd	r22, Y+21	; 0x15
    8ef6:	7e 89       	ldd	r23, Y+22	; 0x16
    8ef8:	8f 89       	ldd	r24, Y+23	; 0x17
    8efa:	98 8d       	ldd	r25, Y+24	; 0x18
    8efc:	20 e0       	ldi	r18, 0x00	; 0
    8efe:	3f ef       	ldi	r19, 0xFF	; 255
    8f00:	4f e7       	ldi	r20, 0x7F	; 127
    8f02:	57 e4       	ldi	r21, 0x47	; 71
    8f04:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8f08:	18 16       	cp	r1, r24
    8f0a:	4c f5       	brge	.+82     	; 0x8f5e <LCD_clear+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8f0c:	69 8d       	ldd	r22, Y+25	; 0x19
    8f0e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8f10:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8f12:	9c 8d       	ldd	r25, Y+28	; 0x1c
    8f14:	20 e0       	ldi	r18, 0x00	; 0
    8f16:	30 e0       	ldi	r19, 0x00	; 0
    8f18:	40 e2       	ldi	r20, 0x20	; 32
    8f1a:	51 e4       	ldi	r21, 0x41	; 65
    8f1c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8f20:	dc 01       	movw	r26, r24
    8f22:	cb 01       	movw	r24, r22
    8f24:	bc 01       	movw	r22, r24
    8f26:	cd 01       	movw	r24, r26
    8f28:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8f2c:	dc 01       	movw	r26, r24
    8f2e:	cb 01       	movw	r24, r22
    8f30:	9c 8b       	std	Y+20, r25	; 0x14
    8f32:	8b 8b       	std	Y+19, r24	; 0x13
    8f34:	0f c0       	rjmp	.+30     	; 0x8f54 <LCD_clear+0xcc>
    8f36:	80 e9       	ldi	r24, 0x90	; 144
    8f38:	91 e0       	ldi	r25, 0x01	; 1
    8f3a:	9a 8b       	std	Y+18, r25	; 0x12
    8f3c:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    8f3e:	89 89       	ldd	r24, Y+17	; 0x11
    8f40:	9a 89       	ldd	r25, Y+18	; 0x12
    8f42:	01 97       	sbiw	r24, 0x01	; 1
    8f44:	f1 f7       	brne	.-4      	; 0x8f42 <LCD_clear+0xba>
    8f46:	9a 8b       	std	Y+18, r25	; 0x12
    8f48:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8f4a:	8b 89       	ldd	r24, Y+19	; 0x13
    8f4c:	9c 89       	ldd	r25, Y+20	; 0x14
    8f4e:	01 97       	sbiw	r24, 0x01	; 1
    8f50:	9c 8b       	std	Y+20, r25	; 0x14
    8f52:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8f54:	8b 89       	ldd	r24, Y+19	; 0x13
    8f56:	9c 89       	ldd	r25, Y+20	; 0x14
    8f58:	00 97       	sbiw	r24, 0x00	; 0
    8f5a:	69 f7       	brne	.-38     	; 0x8f36 <LCD_clear+0xae>
    8f5c:	14 c0       	rjmp	.+40     	; 0x8f86 <LCD_clear+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8f5e:	6d 89       	ldd	r22, Y+21	; 0x15
    8f60:	7e 89       	ldd	r23, Y+22	; 0x16
    8f62:	8f 89       	ldd	r24, Y+23	; 0x17
    8f64:	98 8d       	ldd	r25, Y+24	; 0x18
    8f66:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8f6a:	dc 01       	movw	r26, r24
    8f6c:	cb 01       	movw	r24, r22
    8f6e:	9c 8b       	std	Y+20, r25	; 0x14
    8f70:	8b 8b       	std	Y+19, r24	; 0x13
    8f72:	8b 89       	ldd	r24, Y+19	; 0x13
    8f74:	9c 89       	ldd	r25, Y+20	; 0x14
    8f76:	98 8b       	std	Y+16, r25	; 0x10
    8f78:	8f 87       	std	Y+15, r24	; 0x0f
    8f7a:	8f 85       	ldd	r24, Y+15	; 0x0f
    8f7c:	98 89       	ldd	r25, Y+16	; 0x10
    8f7e:	01 97       	sbiw	r24, 0x01	; 1
    8f80:	f1 f7       	brne	.-4      	; 0x8f7e <LCD_clear+0xf6>
    8f82:	98 8b       	std	Y+16, r25	; 0x10
    8f84:	8f 87       	std	Y+15, r24	; 0x0f
	// Wait more than 1.53 ms
	_delay_ms(2);
	// Send set address command with home address
	LCD_write_cmd_4bit(return_home);
    8f86:	82 e0       	ldi	r24, 0x02	; 2
    8f88:	0e 94 a1 33 	call	0x6742	; 0x6742 <LCD_write_cmd_4bit>
    8f8c:	80 e0       	ldi	r24, 0x00	; 0
    8f8e:	90 e0       	ldi	r25, 0x00	; 0
    8f90:	a0 e0       	ldi	r26, 0x00	; 0
    8f92:	b0 e4       	ldi	r27, 0x40	; 64
    8f94:	8b 87       	std	Y+11, r24	; 0x0b
    8f96:	9c 87       	std	Y+12, r25	; 0x0c
    8f98:	ad 87       	std	Y+13, r26	; 0x0d
    8f9a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8f9c:	6b 85       	ldd	r22, Y+11	; 0x0b
    8f9e:	7c 85       	ldd	r23, Y+12	; 0x0c
    8fa0:	8d 85       	ldd	r24, Y+13	; 0x0d
    8fa2:	9e 85       	ldd	r25, Y+14	; 0x0e
    8fa4:	20 e0       	ldi	r18, 0x00	; 0
    8fa6:	30 e0       	ldi	r19, 0x00	; 0
    8fa8:	4a e7       	ldi	r20, 0x7A	; 122
    8faa:	55 e4       	ldi	r21, 0x45	; 69
    8fac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8fb0:	dc 01       	movw	r26, r24
    8fb2:	cb 01       	movw	r24, r22
    8fb4:	8f 83       	std	Y+7, r24	; 0x07
    8fb6:	98 87       	std	Y+8, r25	; 0x08
    8fb8:	a9 87       	std	Y+9, r26	; 0x09
    8fba:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    8fbc:	6f 81       	ldd	r22, Y+7	; 0x07
    8fbe:	78 85       	ldd	r23, Y+8	; 0x08
    8fc0:	89 85       	ldd	r24, Y+9	; 0x09
    8fc2:	9a 85       	ldd	r25, Y+10	; 0x0a
    8fc4:	20 e0       	ldi	r18, 0x00	; 0
    8fc6:	30 e0       	ldi	r19, 0x00	; 0
    8fc8:	40 e8       	ldi	r20, 0x80	; 128
    8fca:	5f e3       	ldi	r21, 0x3F	; 63
    8fcc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8fd0:	88 23       	and	r24, r24
    8fd2:	2c f4       	brge	.+10     	; 0x8fde <LCD_clear+0x156>
		__ticks = 1;
    8fd4:	81 e0       	ldi	r24, 0x01	; 1
    8fd6:	90 e0       	ldi	r25, 0x00	; 0
    8fd8:	9e 83       	std	Y+6, r25	; 0x06
    8fda:	8d 83       	std	Y+5, r24	; 0x05
    8fdc:	3f c0       	rjmp	.+126    	; 0x905c <LCD_clear+0x1d4>
	else if (__tmp > 65535)
    8fde:	6f 81       	ldd	r22, Y+7	; 0x07
    8fe0:	78 85       	ldd	r23, Y+8	; 0x08
    8fe2:	89 85       	ldd	r24, Y+9	; 0x09
    8fe4:	9a 85       	ldd	r25, Y+10	; 0x0a
    8fe6:	20 e0       	ldi	r18, 0x00	; 0
    8fe8:	3f ef       	ldi	r19, 0xFF	; 255
    8fea:	4f e7       	ldi	r20, 0x7F	; 127
    8fec:	57 e4       	ldi	r21, 0x47	; 71
    8fee:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8ff2:	18 16       	cp	r1, r24
    8ff4:	4c f5       	brge	.+82     	; 0x9048 <LCD_clear+0x1c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8ff6:	6b 85       	ldd	r22, Y+11	; 0x0b
    8ff8:	7c 85       	ldd	r23, Y+12	; 0x0c
    8ffa:	8d 85       	ldd	r24, Y+13	; 0x0d
    8ffc:	9e 85       	ldd	r25, Y+14	; 0x0e
    8ffe:	20 e0       	ldi	r18, 0x00	; 0
    9000:	30 e0       	ldi	r19, 0x00	; 0
    9002:	40 e2       	ldi	r20, 0x20	; 32
    9004:	51 e4       	ldi	r21, 0x41	; 65
    9006:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    900a:	dc 01       	movw	r26, r24
    900c:	cb 01       	movw	r24, r22
    900e:	bc 01       	movw	r22, r24
    9010:	cd 01       	movw	r24, r26
    9012:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9016:	dc 01       	movw	r26, r24
    9018:	cb 01       	movw	r24, r22
    901a:	9e 83       	std	Y+6, r25	; 0x06
    901c:	8d 83       	std	Y+5, r24	; 0x05
    901e:	0f c0       	rjmp	.+30     	; 0x903e <LCD_clear+0x1b6>
    9020:	80 e9       	ldi	r24, 0x90	; 144
    9022:	91 e0       	ldi	r25, 0x01	; 1
    9024:	9c 83       	std	Y+4, r25	; 0x04
    9026:	8b 83       	std	Y+3, r24	; 0x03
    9028:	8b 81       	ldd	r24, Y+3	; 0x03
    902a:	9c 81       	ldd	r25, Y+4	; 0x04
    902c:	01 97       	sbiw	r24, 0x01	; 1
    902e:	f1 f7       	brne	.-4      	; 0x902c <LCD_clear+0x1a4>
    9030:	9c 83       	std	Y+4, r25	; 0x04
    9032:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9034:	8d 81       	ldd	r24, Y+5	; 0x05
    9036:	9e 81       	ldd	r25, Y+6	; 0x06
    9038:	01 97       	sbiw	r24, 0x01	; 1
    903a:	9e 83       	std	Y+6, r25	; 0x06
    903c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    903e:	8d 81       	ldd	r24, Y+5	; 0x05
    9040:	9e 81       	ldd	r25, Y+6	; 0x06
    9042:	00 97       	sbiw	r24, 0x00	; 0
    9044:	69 f7       	brne	.-38     	; 0x9020 <LCD_clear+0x198>
    9046:	14 c0       	rjmp	.+40     	; 0x9070 <LCD_clear+0x1e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9048:	6f 81       	ldd	r22, Y+7	; 0x07
    904a:	78 85       	ldd	r23, Y+8	; 0x08
    904c:	89 85       	ldd	r24, Y+9	; 0x09
    904e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9050:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9054:	dc 01       	movw	r26, r24
    9056:	cb 01       	movw	r24, r22
    9058:	9e 83       	std	Y+6, r25	; 0x06
    905a:	8d 83       	std	Y+5, r24	; 0x05
    905c:	8d 81       	ldd	r24, Y+5	; 0x05
    905e:	9e 81       	ldd	r25, Y+6	; 0x06
    9060:	9a 83       	std	Y+2, r25	; 0x02
    9062:	89 83       	std	Y+1, r24	; 0x01
    9064:	89 81       	ldd	r24, Y+1	; 0x01
    9066:	9a 81       	ldd	r25, Y+2	; 0x02
    9068:	01 97       	sbiw	r24, 0x01	; 1
    906a:	f1 f7       	brne	.-4      	; 0x9068 <LCD_clear+0x1e0>
    906c:	9a 83       	std	Y+2, r25	; 0x02
    906e:	89 83       	std	Y+1, r24	; 0x01
	// wait more than 39 us
	_delay_ms(2);
#endif
}
    9070:	6c 96       	adiw	r28, 0x1c	; 28
    9072:	0f b6       	in	r0, 0x3f	; 63
    9074:	f8 94       	cli
    9076:	de bf       	out	0x3e, r29	; 62
    9078:	0f be       	out	0x3f, r0	; 63
    907a:	cd bf       	out	0x3d, r28	; 61
    907c:	cf 91       	pop	r28
    907e:	df 91       	pop	r29
    9080:	08 95       	ret

00009082 <LCD_off>:

void LCD_off(void ){
    9082:	df 93       	push	r29
    9084:	cf 93       	push	r28
    9086:	cd b7       	in	r28, 0x3d	; 61
    9088:	de b7       	in	r29, 0x3e	; 62
    908a:	2e 97       	sbiw	r28, 0x0e	; 14
    908c:	0f b6       	in	r0, 0x3f	; 63
    908e:	f8 94       	cli
    9090:	de bf       	out	0x3e, r29	; 62
    9092:	0f be       	out	0x3f, r0	; 63
    9094:	cd bf       	out	0x3d, r28	; 61
	LCD_write_cmd_8bit(display_off);
	// Wait more than 39 us
	_delay_ms(50);
#elif _LCD_interface_ == _4bit_interface
	// Send display off command
	LCD_write_cmd_4bit(display_off);
    9096:	88 e0       	ldi	r24, 0x08	; 8
    9098:	0e 94 a1 33 	call	0x6742	; 0x6742 <LCD_write_cmd_4bit>
    909c:	80 e0       	ldi	r24, 0x00	; 0
    909e:	90 e0       	ldi	r25, 0x00	; 0
    90a0:	a8 e4       	ldi	r26, 0x48	; 72
    90a2:	b2 e4       	ldi	r27, 0x42	; 66
    90a4:	8b 87       	std	Y+11, r24	; 0x0b
    90a6:	9c 87       	std	Y+12, r25	; 0x0c
    90a8:	ad 87       	std	Y+13, r26	; 0x0d
    90aa:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    90ac:	6b 85       	ldd	r22, Y+11	; 0x0b
    90ae:	7c 85       	ldd	r23, Y+12	; 0x0c
    90b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    90b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    90b4:	20 e0       	ldi	r18, 0x00	; 0
    90b6:	30 e0       	ldi	r19, 0x00	; 0
    90b8:	4a e7       	ldi	r20, 0x7A	; 122
    90ba:	55 e4       	ldi	r21, 0x45	; 69
    90bc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    90c0:	dc 01       	movw	r26, r24
    90c2:	cb 01       	movw	r24, r22
    90c4:	8f 83       	std	Y+7, r24	; 0x07
    90c6:	98 87       	std	Y+8, r25	; 0x08
    90c8:	a9 87       	std	Y+9, r26	; 0x09
    90ca:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    90cc:	6f 81       	ldd	r22, Y+7	; 0x07
    90ce:	78 85       	ldd	r23, Y+8	; 0x08
    90d0:	89 85       	ldd	r24, Y+9	; 0x09
    90d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    90d4:	20 e0       	ldi	r18, 0x00	; 0
    90d6:	30 e0       	ldi	r19, 0x00	; 0
    90d8:	40 e8       	ldi	r20, 0x80	; 128
    90da:	5f e3       	ldi	r21, 0x3F	; 63
    90dc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    90e0:	88 23       	and	r24, r24
    90e2:	2c f4       	brge	.+10     	; 0x90ee <LCD_off+0x6c>
		__ticks = 1;
    90e4:	81 e0       	ldi	r24, 0x01	; 1
    90e6:	90 e0       	ldi	r25, 0x00	; 0
    90e8:	9e 83       	std	Y+6, r25	; 0x06
    90ea:	8d 83       	std	Y+5, r24	; 0x05
    90ec:	3f c0       	rjmp	.+126    	; 0x916c <LCD_off+0xea>
	else if (__tmp > 65535)
    90ee:	6f 81       	ldd	r22, Y+7	; 0x07
    90f0:	78 85       	ldd	r23, Y+8	; 0x08
    90f2:	89 85       	ldd	r24, Y+9	; 0x09
    90f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    90f6:	20 e0       	ldi	r18, 0x00	; 0
    90f8:	3f ef       	ldi	r19, 0xFF	; 255
    90fa:	4f e7       	ldi	r20, 0x7F	; 127
    90fc:	57 e4       	ldi	r21, 0x47	; 71
    90fe:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    9102:	18 16       	cp	r1, r24
    9104:	4c f5       	brge	.+82     	; 0x9158 <LCD_off+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9106:	6b 85       	ldd	r22, Y+11	; 0x0b
    9108:	7c 85       	ldd	r23, Y+12	; 0x0c
    910a:	8d 85       	ldd	r24, Y+13	; 0x0d
    910c:	9e 85       	ldd	r25, Y+14	; 0x0e
    910e:	20 e0       	ldi	r18, 0x00	; 0
    9110:	30 e0       	ldi	r19, 0x00	; 0
    9112:	40 e2       	ldi	r20, 0x20	; 32
    9114:	51 e4       	ldi	r21, 0x41	; 65
    9116:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    911a:	dc 01       	movw	r26, r24
    911c:	cb 01       	movw	r24, r22
    911e:	bc 01       	movw	r22, r24
    9120:	cd 01       	movw	r24, r26
    9122:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9126:	dc 01       	movw	r26, r24
    9128:	cb 01       	movw	r24, r22
    912a:	9e 83       	std	Y+6, r25	; 0x06
    912c:	8d 83       	std	Y+5, r24	; 0x05
    912e:	0f c0       	rjmp	.+30     	; 0x914e <LCD_off+0xcc>
    9130:	80 e9       	ldi	r24, 0x90	; 144
    9132:	91 e0       	ldi	r25, 0x01	; 1
    9134:	9c 83       	std	Y+4, r25	; 0x04
    9136:	8b 83       	std	Y+3, r24	; 0x03
    9138:	8b 81       	ldd	r24, Y+3	; 0x03
    913a:	9c 81       	ldd	r25, Y+4	; 0x04
    913c:	01 97       	sbiw	r24, 0x01	; 1
    913e:	f1 f7       	brne	.-4      	; 0x913c <LCD_off+0xba>
    9140:	9c 83       	std	Y+4, r25	; 0x04
    9142:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9144:	8d 81       	ldd	r24, Y+5	; 0x05
    9146:	9e 81       	ldd	r25, Y+6	; 0x06
    9148:	01 97       	sbiw	r24, 0x01	; 1
    914a:	9e 83       	std	Y+6, r25	; 0x06
    914c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    914e:	8d 81       	ldd	r24, Y+5	; 0x05
    9150:	9e 81       	ldd	r25, Y+6	; 0x06
    9152:	00 97       	sbiw	r24, 0x00	; 0
    9154:	69 f7       	brne	.-38     	; 0x9130 <LCD_off+0xae>
    9156:	14 c0       	rjmp	.+40     	; 0x9180 <LCD_off+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9158:	6f 81       	ldd	r22, Y+7	; 0x07
    915a:	78 85       	ldd	r23, Y+8	; 0x08
    915c:	89 85       	ldd	r24, Y+9	; 0x09
    915e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9160:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9164:	dc 01       	movw	r26, r24
    9166:	cb 01       	movw	r24, r22
    9168:	9e 83       	std	Y+6, r25	; 0x06
    916a:	8d 83       	std	Y+5, r24	; 0x05
    916c:	8d 81       	ldd	r24, Y+5	; 0x05
    916e:	9e 81       	ldd	r25, Y+6	; 0x06
    9170:	9a 83       	std	Y+2, r25	; 0x02
    9172:	89 83       	std	Y+1, r24	; 0x01
    9174:	89 81       	ldd	r24, Y+1	; 0x01
    9176:	9a 81       	ldd	r25, Y+2	; 0x02
    9178:	01 97       	sbiw	r24, 0x01	; 1
    917a:	f1 f7       	brne	.-4      	; 0x9178 <LCD_off+0xf6>
    917c:	9a 83       	std	Y+2, r25	; 0x02
    917e:	89 83       	std	Y+1, r24	; 0x01
	// Wait more than 39 us
	_delay_ms(50);
#endif
}
    9180:	2e 96       	adiw	r28, 0x0e	; 14
    9182:	0f b6       	in	r0, 0x3f	; 63
    9184:	f8 94       	cli
    9186:	de bf       	out	0x3e, r29	; 62
    9188:	0f be       	out	0x3f, r0	; 63
    918a:	cd bf       	out	0x3d, r28	; 61
    918c:	cf 91       	pop	r28
    918e:	df 91       	pop	r29
    9190:	08 95       	ret

00009192 <LCD_on>:

void LCD_on(void ){
    9192:	df 93       	push	r29
    9194:	cf 93       	push	r28
    9196:	cd b7       	in	r28, 0x3d	; 61
    9198:	de b7       	in	r29, 0x3e	; 62
    919a:	68 97       	sbiw	r28, 0x18	; 24
    919c:	0f b6       	in	r0, 0x3f	; 63
    919e:	f8 94       	cli
    91a0:	de bf       	out	0x3e, r29	; 62
    91a2:	0f be       	out	0x3f, r0	; 63
    91a4:	cd bf       	out	0x3d, r28	; 61
	LCD_write_cmd_8bit(display_on);
	// Wait more than 39 us
	_delay_us(50);
#elif _LCD_interface_ == _4bit_interface
	// Send display off command
	LCD_write_cmd_4bit(display_on);
    91a6:	8c e0       	ldi	r24, 0x0C	; 12
    91a8:	0e 94 a1 33 	call	0x6742	; 0x6742 <LCD_write_cmd_4bit>
    91ac:	80 e0       	ldi	r24, 0x00	; 0
    91ae:	90 e0       	ldi	r25, 0x00	; 0
    91b0:	a8 e4       	ldi	r26, 0x48	; 72
    91b2:	b2 e4       	ldi	r27, 0x42	; 66
    91b4:	8d 8b       	std	Y+21, r24	; 0x15
    91b6:	9e 8b       	std	Y+22, r25	; 0x16
    91b8:	af 8b       	std	Y+23, r26	; 0x17
    91ba:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    91bc:	6d 89       	ldd	r22, Y+21	; 0x15
    91be:	7e 89       	ldd	r23, Y+22	; 0x16
    91c0:	8f 89       	ldd	r24, Y+23	; 0x17
    91c2:	98 8d       	ldd	r25, Y+24	; 0x18
    91c4:	2b ea       	ldi	r18, 0xAB	; 171
    91c6:	3a ea       	ldi	r19, 0xAA	; 170
    91c8:	4a ea       	ldi	r20, 0xAA	; 170
    91ca:	50 e4       	ldi	r21, 0x40	; 64
    91cc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    91d0:	dc 01       	movw	r26, r24
    91d2:	cb 01       	movw	r24, r22
    91d4:	89 8b       	std	Y+17, r24	; 0x11
    91d6:	9a 8b       	std	Y+18, r25	; 0x12
    91d8:	ab 8b       	std	Y+19, r26	; 0x13
    91da:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    91dc:	69 89       	ldd	r22, Y+17	; 0x11
    91de:	7a 89       	ldd	r23, Y+18	; 0x12
    91e0:	8b 89       	ldd	r24, Y+19	; 0x13
    91e2:	9c 89       	ldd	r25, Y+20	; 0x14
    91e4:	20 e0       	ldi	r18, 0x00	; 0
    91e6:	30 e0       	ldi	r19, 0x00	; 0
    91e8:	40 e8       	ldi	r20, 0x80	; 128
    91ea:	5f e3       	ldi	r21, 0x3F	; 63
    91ec:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    91f0:	88 23       	and	r24, r24
    91f2:	1c f4       	brge	.+6      	; 0x91fa <LCD_on+0x68>
		__ticks = 1;
    91f4:	81 e0       	ldi	r24, 0x01	; 1
    91f6:	88 8b       	std	Y+16, r24	; 0x10
    91f8:	91 c0       	rjmp	.+290    	; 0x931c <LCD_on+0x18a>
	else if (__tmp > 255)
    91fa:	69 89       	ldd	r22, Y+17	; 0x11
    91fc:	7a 89       	ldd	r23, Y+18	; 0x12
    91fe:	8b 89       	ldd	r24, Y+19	; 0x13
    9200:	9c 89       	ldd	r25, Y+20	; 0x14
    9202:	20 e0       	ldi	r18, 0x00	; 0
    9204:	30 e0       	ldi	r19, 0x00	; 0
    9206:	4f e7       	ldi	r20, 0x7F	; 127
    9208:	53 e4       	ldi	r21, 0x43	; 67
    920a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    920e:	18 16       	cp	r1, r24
    9210:	0c f0       	brlt	.+2      	; 0x9214 <LCD_on+0x82>
    9212:	7b c0       	rjmp	.+246    	; 0x930a <LCD_on+0x178>
	{
		_delay_ms(__us / 1000.0);
    9214:	6d 89       	ldd	r22, Y+21	; 0x15
    9216:	7e 89       	ldd	r23, Y+22	; 0x16
    9218:	8f 89       	ldd	r24, Y+23	; 0x17
    921a:	98 8d       	ldd	r25, Y+24	; 0x18
    921c:	20 e0       	ldi	r18, 0x00	; 0
    921e:	30 e0       	ldi	r19, 0x00	; 0
    9220:	4a e7       	ldi	r20, 0x7A	; 122
    9222:	54 e4       	ldi	r21, 0x44	; 68
    9224:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    9228:	dc 01       	movw	r26, r24
    922a:	cb 01       	movw	r24, r22
    922c:	8c 87       	std	Y+12, r24	; 0x0c
    922e:	9d 87       	std	Y+13, r25	; 0x0d
    9230:	ae 87       	std	Y+14, r26	; 0x0e
    9232:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    9234:	6c 85       	ldd	r22, Y+12	; 0x0c
    9236:	7d 85       	ldd	r23, Y+13	; 0x0d
    9238:	8e 85       	ldd	r24, Y+14	; 0x0e
    923a:	9f 85       	ldd	r25, Y+15	; 0x0f
    923c:	20 e0       	ldi	r18, 0x00	; 0
    923e:	30 e0       	ldi	r19, 0x00	; 0
    9240:	4a e7       	ldi	r20, 0x7A	; 122
    9242:	55 e4       	ldi	r21, 0x45	; 69
    9244:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9248:	dc 01       	movw	r26, r24
    924a:	cb 01       	movw	r24, r22
    924c:	88 87       	std	Y+8, r24	; 0x08
    924e:	99 87       	std	Y+9, r25	; 0x09
    9250:	aa 87       	std	Y+10, r26	; 0x0a
    9252:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    9254:	68 85       	ldd	r22, Y+8	; 0x08
    9256:	79 85       	ldd	r23, Y+9	; 0x09
    9258:	8a 85       	ldd	r24, Y+10	; 0x0a
    925a:	9b 85       	ldd	r25, Y+11	; 0x0b
    925c:	20 e0       	ldi	r18, 0x00	; 0
    925e:	30 e0       	ldi	r19, 0x00	; 0
    9260:	40 e8       	ldi	r20, 0x80	; 128
    9262:	5f e3       	ldi	r21, 0x3F	; 63
    9264:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    9268:	88 23       	and	r24, r24
    926a:	2c f4       	brge	.+10     	; 0x9276 <LCD_on+0xe4>
		__ticks = 1;
    926c:	81 e0       	ldi	r24, 0x01	; 1
    926e:	90 e0       	ldi	r25, 0x00	; 0
    9270:	9f 83       	std	Y+7, r25	; 0x07
    9272:	8e 83       	std	Y+6, r24	; 0x06
    9274:	3f c0       	rjmp	.+126    	; 0x92f4 <LCD_on+0x162>
	else if (__tmp > 65535)
    9276:	68 85       	ldd	r22, Y+8	; 0x08
    9278:	79 85       	ldd	r23, Y+9	; 0x09
    927a:	8a 85       	ldd	r24, Y+10	; 0x0a
    927c:	9b 85       	ldd	r25, Y+11	; 0x0b
    927e:	20 e0       	ldi	r18, 0x00	; 0
    9280:	3f ef       	ldi	r19, 0xFF	; 255
    9282:	4f e7       	ldi	r20, 0x7F	; 127
    9284:	57 e4       	ldi	r21, 0x47	; 71
    9286:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    928a:	18 16       	cp	r1, r24
    928c:	4c f5       	brge	.+82     	; 0x92e0 <LCD_on+0x14e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    928e:	6c 85       	ldd	r22, Y+12	; 0x0c
    9290:	7d 85       	ldd	r23, Y+13	; 0x0d
    9292:	8e 85       	ldd	r24, Y+14	; 0x0e
    9294:	9f 85       	ldd	r25, Y+15	; 0x0f
    9296:	20 e0       	ldi	r18, 0x00	; 0
    9298:	30 e0       	ldi	r19, 0x00	; 0
    929a:	40 e2       	ldi	r20, 0x20	; 32
    929c:	51 e4       	ldi	r21, 0x41	; 65
    929e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    92a2:	dc 01       	movw	r26, r24
    92a4:	cb 01       	movw	r24, r22
    92a6:	bc 01       	movw	r22, r24
    92a8:	cd 01       	movw	r24, r26
    92aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    92ae:	dc 01       	movw	r26, r24
    92b0:	cb 01       	movw	r24, r22
    92b2:	9f 83       	std	Y+7, r25	; 0x07
    92b4:	8e 83       	std	Y+6, r24	; 0x06
    92b6:	0f c0       	rjmp	.+30     	; 0x92d6 <LCD_on+0x144>
    92b8:	80 e9       	ldi	r24, 0x90	; 144
    92ba:	91 e0       	ldi	r25, 0x01	; 1
    92bc:	9d 83       	std	Y+5, r25	; 0x05
    92be:	8c 83       	std	Y+4, r24	; 0x04
    92c0:	8c 81       	ldd	r24, Y+4	; 0x04
    92c2:	9d 81       	ldd	r25, Y+5	; 0x05
    92c4:	01 97       	sbiw	r24, 0x01	; 1
    92c6:	f1 f7       	brne	.-4      	; 0x92c4 <LCD_on+0x132>
    92c8:	9d 83       	std	Y+5, r25	; 0x05
    92ca:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    92cc:	8e 81       	ldd	r24, Y+6	; 0x06
    92ce:	9f 81       	ldd	r25, Y+7	; 0x07
    92d0:	01 97       	sbiw	r24, 0x01	; 1
    92d2:	9f 83       	std	Y+7, r25	; 0x07
    92d4:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    92d6:	8e 81       	ldd	r24, Y+6	; 0x06
    92d8:	9f 81       	ldd	r25, Y+7	; 0x07
    92da:	00 97       	sbiw	r24, 0x00	; 0
    92dc:	69 f7       	brne	.-38     	; 0x92b8 <LCD_on+0x126>
    92de:	24 c0       	rjmp	.+72     	; 0x9328 <LCD_on+0x196>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    92e0:	68 85       	ldd	r22, Y+8	; 0x08
    92e2:	79 85       	ldd	r23, Y+9	; 0x09
    92e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    92e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    92e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    92ec:	dc 01       	movw	r26, r24
    92ee:	cb 01       	movw	r24, r22
    92f0:	9f 83       	std	Y+7, r25	; 0x07
    92f2:	8e 83       	std	Y+6, r24	; 0x06
    92f4:	8e 81       	ldd	r24, Y+6	; 0x06
    92f6:	9f 81       	ldd	r25, Y+7	; 0x07
    92f8:	9b 83       	std	Y+3, r25	; 0x03
    92fa:	8a 83       	std	Y+2, r24	; 0x02
    92fc:	8a 81       	ldd	r24, Y+2	; 0x02
    92fe:	9b 81       	ldd	r25, Y+3	; 0x03
    9300:	01 97       	sbiw	r24, 0x01	; 1
    9302:	f1 f7       	brne	.-4      	; 0x9300 <LCD_on+0x16e>
    9304:	9b 83       	std	Y+3, r25	; 0x03
    9306:	8a 83       	std	Y+2, r24	; 0x02
    9308:	0f c0       	rjmp	.+30     	; 0x9328 <LCD_on+0x196>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    930a:	69 89       	ldd	r22, Y+17	; 0x11
    930c:	7a 89       	ldd	r23, Y+18	; 0x12
    930e:	8b 89       	ldd	r24, Y+19	; 0x13
    9310:	9c 89       	ldd	r25, Y+20	; 0x14
    9312:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9316:	dc 01       	movw	r26, r24
    9318:	cb 01       	movw	r24, r22
    931a:	88 8b       	std	Y+16, r24	; 0x10
    931c:	88 89       	ldd	r24, Y+16	; 0x10
    931e:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    9320:	89 81       	ldd	r24, Y+1	; 0x01
    9322:	8a 95       	dec	r24
    9324:	f1 f7       	brne	.-4      	; 0x9322 <LCD_on+0x190>
    9326:	89 83       	std	Y+1, r24	; 0x01
	// Wait more than 39 us
	_delay_us(50);
#endif
}
    9328:	68 96       	adiw	r28, 0x18	; 24
    932a:	0f b6       	in	r0, 0x3f	; 63
    932c:	f8 94       	cli
    932e:	de bf       	out	0x3e, r29	; 62
    9330:	0f be       	out	0x3f, r0	; 63
    9332:	cd bf       	out	0x3d, r28	; 61
    9334:	cf 91       	pop	r28
    9336:	df 91       	pop	r29
    9338:	08 95       	ret

0000933a <LCD_create_char>:

void LCD_create_char(u8* copy_pu8_char_data, u8 copy_u8_loc){
    933a:	df 93       	push	r29
    933c:	cf 93       	push	r28
    933e:	00 d0       	rcall	.+0      	; 0x9340 <LCD_create_char+0x6>
    9340:	0f 92       	push	r0
    9342:	cd b7       	in	r28, 0x3d	; 61
    9344:	de b7       	in	r29, 0x3e	; 62
    9346:	9a 83       	std	Y+2, r25	; 0x02
    9348:	89 83       	std	Y+1, r24	; 0x01
    934a:	6b 83       	std	Y+3, r22	; 0x03
	// Wait more than 39 us
	_delay_us(50);
#elif _LCD_interface_ == _4bit_interface

#endif
}
    934c:	0f 90       	pop	r0
    934e:	0f 90       	pop	r0
    9350:	0f 90       	pop	r0
    9352:	cf 91       	pop	r28
    9354:	df 91       	pop	r29
    9356:	08 95       	ret

00009358 <LCD_write_char>:

void LCD_write_char(u8 copy_u8_char){
    9358:	df 93       	push	r29
    935a:	cf 93       	push	r28
    935c:	cd b7       	in	r28, 0x3d	; 61
    935e:	de b7       	in	r29, 0x3e	; 62
    9360:	69 97       	sbiw	r28, 0x19	; 25
    9362:	0f b6       	in	r0, 0x3f	; 63
    9364:	f8 94       	cli
    9366:	de bf       	out	0x3e, r29	; 62
    9368:	0f be       	out	0x3f, r0	; 63
    936a:	cd bf       	out	0x3d, r28	; 61
    936c:	89 8f       	std	Y+25, r24	; 0x19
	LCD_write_data_8bit(copy_u8_char);
	// Wait more than 39 us
	_delay_us(50);
#elif _LCD_interface_ == _4bit_interface
	// Wait more than 39 us
	LCD_write_data_4bit(copy_u8_char);
    936e:	89 8d       	ldd	r24, Y+25	; 0x19
    9370:	0e 94 85 2f 	call	0x5f0a	; 0x5f0a <LCD_write_data_4bit>
    9374:	80 e0       	ldi	r24, 0x00	; 0
    9376:	90 e0       	ldi	r25, 0x00	; 0
    9378:	a8 e4       	ldi	r26, 0x48	; 72
    937a:	b2 e4       	ldi	r27, 0x42	; 66
    937c:	8d 8b       	std	Y+21, r24	; 0x15
    937e:	9e 8b       	std	Y+22, r25	; 0x16
    9380:	af 8b       	std	Y+23, r26	; 0x17
    9382:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    9384:	6d 89       	ldd	r22, Y+21	; 0x15
    9386:	7e 89       	ldd	r23, Y+22	; 0x16
    9388:	8f 89       	ldd	r24, Y+23	; 0x17
    938a:	98 8d       	ldd	r25, Y+24	; 0x18
    938c:	2b ea       	ldi	r18, 0xAB	; 171
    938e:	3a ea       	ldi	r19, 0xAA	; 170
    9390:	4a ea       	ldi	r20, 0xAA	; 170
    9392:	50 e4       	ldi	r21, 0x40	; 64
    9394:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9398:	dc 01       	movw	r26, r24
    939a:	cb 01       	movw	r24, r22
    939c:	89 8b       	std	Y+17, r24	; 0x11
    939e:	9a 8b       	std	Y+18, r25	; 0x12
    93a0:	ab 8b       	std	Y+19, r26	; 0x13
    93a2:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    93a4:	69 89       	ldd	r22, Y+17	; 0x11
    93a6:	7a 89       	ldd	r23, Y+18	; 0x12
    93a8:	8b 89       	ldd	r24, Y+19	; 0x13
    93aa:	9c 89       	ldd	r25, Y+20	; 0x14
    93ac:	20 e0       	ldi	r18, 0x00	; 0
    93ae:	30 e0       	ldi	r19, 0x00	; 0
    93b0:	40 e8       	ldi	r20, 0x80	; 128
    93b2:	5f e3       	ldi	r21, 0x3F	; 63
    93b4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    93b8:	88 23       	and	r24, r24
    93ba:	1c f4       	brge	.+6      	; 0x93c2 <LCD_write_char+0x6a>
		__ticks = 1;
    93bc:	81 e0       	ldi	r24, 0x01	; 1
    93be:	88 8b       	std	Y+16, r24	; 0x10
    93c0:	91 c0       	rjmp	.+290    	; 0x94e4 <LCD_write_char+0x18c>
	else if (__tmp > 255)
    93c2:	69 89       	ldd	r22, Y+17	; 0x11
    93c4:	7a 89       	ldd	r23, Y+18	; 0x12
    93c6:	8b 89       	ldd	r24, Y+19	; 0x13
    93c8:	9c 89       	ldd	r25, Y+20	; 0x14
    93ca:	20 e0       	ldi	r18, 0x00	; 0
    93cc:	30 e0       	ldi	r19, 0x00	; 0
    93ce:	4f e7       	ldi	r20, 0x7F	; 127
    93d0:	53 e4       	ldi	r21, 0x43	; 67
    93d2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    93d6:	18 16       	cp	r1, r24
    93d8:	0c f0       	brlt	.+2      	; 0x93dc <LCD_write_char+0x84>
    93da:	7b c0       	rjmp	.+246    	; 0x94d2 <LCD_write_char+0x17a>
	{
		_delay_ms(__us / 1000.0);
    93dc:	6d 89       	ldd	r22, Y+21	; 0x15
    93de:	7e 89       	ldd	r23, Y+22	; 0x16
    93e0:	8f 89       	ldd	r24, Y+23	; 0x17
    93e2:	98 8d       	ldd	r25, Y+24	; 0x18
    93e4:	20 e0       	ldi	r18, 0x00	; 0
    93e6:	30 e0       	ldi	r19, 0x00	; 0
    93e8:	4a e7       	ldi	r20, 0x7A	; 122
    93ea:	54 e4       	ldi	r21, 0x44	; 68
    93ec:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    93f0:	dc 01       	movw	r26, r24
    93f2:	cb 01       	movw	r24, r22
    93f4:	8c 87       	std	Y+12, r24	; 0x0c
    93f6:	9d 87       	std	Y+13, r25	; 0x0d
    93f8:	ae 87       	std	Y+14, r26	; 0x0e
    93fa:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    93fc:	6c 85       	ldd	r22, Y+12	; 0x0c
    93fe:	7d 85       	ldd	r23, Y+13	; 0x0d
    9400:	8e 85       	ldd	r24, Y+14	; 0x0e
    9402:	9f 85       	ldd	r25, Y+15	; 0x0f
    9404:	20 e0       	ldi	r18, 0x00	; 0
    9406:	30 e0       	ldi	r19, 0x00	; 0
    9408:	4a e7       	ldi	r20, 0x7A	; 122
    940a:	55 e4       	ldi	r21, 0x45	; 69
    940c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9410:	dc 01       	movw	r26, r24
    9412:	cb 01       	movw	r24, r22
    9414:	88 87       	std	Y+8, r24	; 0x08
    9416:	99 87       	std	Y+9, r25	; 0x09
    9418:	aa 87       	std	Y+10, r26	; 0x0a
    941a:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    941c:	68 85       	ldd	r22, Y+8	; 0x08
    941e:	79 85       	ldd	r23, Y+9	; 0x09
    9420:	8a 85       	ldd	r24, Y+10	; 0x0a
    9422:	9b 85       	ldd	r25, Y+11	; 0x0b
    9424:	20 e0       	ldi	r18, 0x00	; 0
    9426:	30 e0       	ldi	r19, 0x00	; 0
    9428:	40 e8       	ldi	r20, 0x80	; 128
    942a:	5f e3       	ldi	r21, 0x3F	; 63
    942c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    9430:	88 23       	and	r24, r24
    9432:	2c f4       	brge	.+10     	; 0x943e <LCD_write_char+0xe6>
		__ticks = 1;
    9434:	81 e0       	ldi	r24, 0x01	; 1
    9436:	90 e0       	ldi	r25, 0x00	; 0
    9438:	9f 83       	std	Y+7, r25	; 0x07
    943a:	8e 83       	std	Y+6, r24	; 0x06
    943c:	3f c0       	rjmp	.+126    	; 0x94bc <LCD_write_char+0x164>
	else if (__tmp > 65535)
    943e:	68 85       	ldd	r22, Y+8	; 0x08
    9440:	79 85       	ldd	r23, Y+9	; 0x09
    9442:	8a 85       	ldd	r24, Y+10	; 0x0a
    9444:	9b 85       	ldd	r25, Y+11	; 0x0b
    9446:	20 e0       	ldi	r18, 0x00	; 0
    9448:	3f ef       	ldi	r19, 0xFF	; 255
    944a:	4f e7       	ldi	r20, 0x7F	; 127
    944c:	57 e4       	ldi	r21, 0x47	; 71
    944e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    9452:	18 16       	cp	r1, r24
    9454:	4c f5       	brge	.+82     	; 0x94a8 <LCD_write_char+0x150>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9456:	6c 85       	ldd	r22, Y+12	; 0x0c
    9458:	7d 85       	ldd	r23, Y+13	; 0x0d
    945a:	8e 85       	ldd	r24, Y+14	; 0x0e
    945c:	9f 85       	ldd	r25, Y+15	; 0x0f
    945e:	20 e0       	ldi	r18, 0x00	; 0
    9460:	30 e0       	ldi	r19, 0x00	; 0
    9462:	40 e2       	ldi	r20, 0x20	; 32
    9464:	51 e4       	ldi	r21, 0x41	; 65
    9466:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    946a:	dc 01       	movw	r26, r24
    946c:	cb 01       	movw	r24, r22
    946e:	bc 01       	movw	r22, r24
    9470:	cd 01       	movw	r24, r26
    9472:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9476:	dc 01       	movw	r26, r24
    9478:	cb 01       	movw	r24, r22
    947a:	9f 83       	std	Y+7, r25	; 0x07
    947c:	8e 83       	std	Y+6, r24	; 0x06
    947e:	0f c0       	rjmp	.+30     	; 0x949e <LCD_write_char+0x146>
    9480:	80 e9       	ldi	r24, 0x90	; 144
    9482:	91 e0       	ldi	r25, 0x01	; 1
    9484:	9d 83       	std	Y+5, r25	; 0x05
    9486:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    9488:	8c 81       	ldd	r24, Y+4	; 0x04
    948a:	9d 81       	ldd	r25, Y+5	; 0x05
    948c:	01 97       	sbiw	r24, 0x01	; 1
    948e:	f1 f7       	brne	.-4      	; 0x948c <LCD_write_char+0x134>
    9490:	9d 83       	std	Y+5, r25	; 0x05
    9492:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9494:	8e 81       	ldd	r24, Y+6	; 0x06
    9496:	9f 81       	ldd	r25, Y+7	; 0x07
    9498:	01 97       	sbiw	r24, 0x01	; 1
    949a:	9f 83       	std	Y+7, r25	; 0x07
    949c:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    949e:	8e 81       	ldd	r24, Y+6	; 0x06
    94a0:	9f 81       	ldd	r25, Y+7	; 0x07
    94a2:	00 97       	sbiw	r24, 0x00	; 0
    94a4:	69 f7       	brne	.-38     	; 0x9480 <LCD_write_char+0x128>
    94a6:	24 c0       	rjmp	.+72     	; 0x94f0 <LCD_write_char+0x198>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    94a8:	68 85       	ldd	r22, Y+8	; 0x08
    94aa:	79 85       	ldd	r23, Y+9	; 0x09
    94ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    94ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    94b0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    94b4:	dc 01       	movw	r26, r24
    94b6:	cb 01       	movw	r24, r22
    94b8:	9f 83       	std	Y+7, r25	; 0x07
    94ba:	8e 83       	std	Y+6, r24	; 0x06
    94bc:	8e 81       	ldd	r24, Y+6	; 0x06
    94be:	9f 81       	ldd	r25, Y+7	; 0x07
    94c0:	9b 83       	std	Y+3, r25	; 0x03
    94c2:	8a 83       	std	Y+2, r24	; 0x02
    94c4:	8a 81       	ldd	r24, Y+2	; 0x02
    94c6:	9b 81       	ldd	r25, Y+3	; 0x03
    94c8:	01 97       	sbiw	r24, 0x01	; 1
    94ca:	f1 f7       	brne	.-4      	; 0x94c8 <LCD_write_char+0x170>
    94cc:	9b 83       	std	Y+3, r25	; 0x03
    94ce:	8a 83       	std	Y+2, r24	; 0x02
    94d0:	0f c0       	rjmp	.+30     	; 0x94f0 <LCD_write_char+0x198>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    94d2:	69 89       	ldd	r22, Y+17	; 0x11
    94d4:	7a 89       	ldd	r23, Y+18	; 0x12
    94d6:	8b 89       	ldd	r24, Y+19	; 0x13
    94d8:	9c 89       	ldd	r25, Y+20	; 0x14
    94da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    94de:	dc 01       	movw	r26, r24
    94e0:	cb 01       	movw	r24, r22
    94e2:	88 8b       	std	Y+16, r24	; 0x10
    94e4:	88 89       	ldd	r24, Y+16	; 0x10
    94e6:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    94e8:	89 81       	ldd	r24, Y+1	; 0x01
    94ea:	8a 95       	dec	r24
    94ec:	f1 f7       	brne	.-4      	; 0x94ea <LCD_write_char+0x192>
    94ee:	89 83       	std	Y+1, r24	; 0x01
	// Wait more than 39 us
	_delay_us(50);
#endif
}
    94f0:	69 96       	adiw	r28, 0x19	; 25
    94f2:	0f b6       	in	r0, 0x3f	; 63
    94f4:	f8 94       	cli
    94f6:	de bf       	out	0x3e, r29	; 62
    94f8:	0f be       	out	0x3f, r0	; 63
    94fa:	cd bf       	out	0x3d, r28	; 61
    94fc:	cf 91       	pop	r28
    94fe:	df 91       	pop	r29
    9500:	08 95       	ret

00009502 <LCD_write_str>:

void LCD_write_str(u8* copy_pu8_str_ref){
    9502:	df 93       	push	r29
    9504:	cf 93       	push	r28
    9506:	00 d0       	rcall	.+0      	; 0x9508 <LCD_write_str+0x6>
    9508:	0f 92       	push	r0
    950a:	cd b7       	in	r28, 0x3d	; 61
    950c:	de b7       	in	r29, 0x3e	; 62
    950e:	9b 83       	std	Y+3, r25	; 0x03
    9510:	8a 83       	std	Y+2, r24	; 0x02
	 *		copy_pu8_str_ref>> Pointer to the first element of the string.
	 *	
	 *	Function does not return any values.
	 */
	// Create a counter for string indexing
	u8 i = 0;
    9512:	19 82       	std	Y+1, r1	; 0x01
    9514:	0e c0       	rjmp	.+28     	; 0x9532 <LCD_write_str+0x30>
	// Loop on the string till null terminator
	while(copy_pu8_str_ref[i] != null){
		// Display the curent character
		LCD_write_char(copy_pu8_str_ref[i]);
    9516:	89 81       	ldd	r24, Y+1	; 0x01
    9518:	28 2f       	mov	r18, r24
    951a:	30 e0       	ldi	r19, 0x00	; 0
    951c:	8a 81       	ldd	r24, Y+2	; 0x02
    951e:	9b 81       	ldd	r25, Y+3	; 0x03
    9520:	fc 01       	movw	r30, r24
    9522:	e2 0f       	add	r30, r18
    9524:	f3 1f       	adc	r31, r19
    9526:	80 81       	ld	r24, Z
    9528:	0e 94 ac 49 	call	0x9358	; 0x9358 <LCD_write_char>
		// Increment the string index
		i++;
    952c:	89 81       	ldd	r24, Y+1	; 0x01
    952e:	8f 5f       	subi	r24, 0xFF	; 255
    9530:	89 83       	std	Y+1, r24	; 0x01
	 *	Function does not return any values.
	 */
	// Create a counter for string indexing
	u8 i = 0;
	// Loop on the string till null terminator
	while(copy_pu8_str_ref[i] != null){
    9532:	89 81       	ldd	r24, Y+1	; 0x01
    9534:	28 2f       	mov	r18, r24
    9536:	30 e0       	ldi	r19, 0x00	; 0
    9538:	8a 81       	ldd	r24, Y+2	; 0x02
    953a:	9b 81       	ldd	r25, Y+3	; 0x03
    953c:	fc 01       	movw	r30, r24
    953e:	e2 0f       	add	r30, r18
    9540:	f3 1f       	adc	r31, r19
    9542:	80 81       	ld	r24, Z
    9544:	88 23       	and	r24, r24
    9546:	39 f7       	brne	.-50     	; 0x9516 <LCD_write_str+0x14>
		// Display the curent character
		LCD_write_char(copy_pu8_str_ref[i]);
		// Increment the string index
		i++;
	}
}
    9548:	0f 90       	pop	r0
    954a:	0f 90       	pop	r0
    954c:	0f 90       	pop	r0
    954e:	cf 91       	pop	r28
    9550:	df 91       	pop	r29
    9552:	08 95       	ret

00009554 <LCD_write_s32_number>:

void LCD_write_s32_number(s32 copy_s32_number){
    9554:	0f 93       	push	r16
    9556:	1f 93       	push	r17
    9558:	df 93       	push	r29
    955a:	cf 93       	push	r28
    955c:	cd b7       	in	r28, 0x3d	; 61
    955e:	de b7       	in	r29, 0x3e	; 62
    9560:	60 97       	sbiw	r28, 0x10	; 16
    9562:	0f b6       	in	r0, 0x3f	; 63
    9564:	f8 94       	cli
    9566:	de bf       	out	0x3e, r29	; 62
    9568:	0f be       	out	0x3f, r0	; 63
    956a:	cd bf       	out	0x3d, r28	; 61
    956c:	6d 87       	std	Y+13, r22	; 0x0d
    956e:	7e 87       	std	Y+14, r23	; 0x0e
    9570:	8f 87       	std	Y+15, r24	; 0x0f
    9572:	98 8b       	std	Y+16, r25	; 0x10
	 *		copy_s32_number>> The number to displayed.
	 *	
	 *	Function does not return any values.
	 */
	// Print zero if the original number is zero
	if(0 == copy_s32_number)
    9574:	8d 85       	ldd	r24, Y+13	; 0x0d
    9576:	9e 85       	ldd	r25, Y+14	; 0x0e
    9578:	af 85       	ldd	r26, Y+15	; 0x0f
    957a:	b8 89       	ldd	r27, Y+16	; 0x10
    957c:	00 97       	sbiw	r24, 0x00	; 0
    957e:	a1 05       	cpc	r26, r1
    9580:	b1 05       	cpc	r27, r1
    9582:	21 f4       	brne	.+8      	; 0x958c <LCD_write_s32_number+0x38>
		LCD_write_char('0');
    9584:	80 e3       	ldi	r24, 0x30	; 48
    9586:	0e 94 ac 49 	call	0x9358	; 0x9358 <LCD_write_char>
    958a:	18 c0       	rjmp	.+48     	; 0x95bc <LCD_write_s32_number+0x68>
	// Check if the number is negative to print sign
	else if(0 > copy_s32_number){
    958c:	8d 85       	ldd	r24, Y+13	; 0x0d
    958e:	9e 85       	ldd	r25, Y+14	; 0x0e
    9590:	af 85       	ldd	r26, Y+15	; 0x0f
    9592:	b8 89       	ldd	r27, Y+16	; 0x10
    9594:	bb 23       	and	r27, r27
    9596:	94 f4       	brge	.+36     	; 0x95bc <LCD_write_s32_number+0x68>
		// Print the negative sign
		LCD_write_char('-');
    9598:	8d e2       	ldi	r24, 0x2D	; 45
    959a:	0e 94 ac 49 	call	0x9358	; 0x9358 <LCD_write_char>
		// Conver the number to positive
		copy_s32_number *= -1;
    959e:	8d 85       	ldd	r24, Y+13	; 0x0d
    95a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    95a2:	af 85       	ldd	r26, Y+15	; 0x0f
    95a4:	b8 89       	ldd	r27, Y+16	; 0x10
    95a6:	b0 95       	com	r27
    95a8:	a0 95       	com	r26
    95aa:	90 95       	com	r25
    95ac:	81 95       	neg	r24
    95ae:	9f 4f       	sbci	r25, 0xFF	; 255
    95b0:	af 4f       	sbci	r26, 0xFF	; 255
    95b2:	bf 4f       	sbci	r27, 0xFF	; 255
    95b4:	8d 87       	std	Y+13, r24	; 0x0d
    95b6:	9e 87       	std	Y+14, r25	; 0x0e
    95b8:	af 87       	std	Y+15, r26	; 0x0f
    95ba:	b8 8b       	std	Y+16, r27	; 0x10
	}
	// Start printing the given number
	// Create a container for storing the nunmber
	u8 val_container[10];
	// Create counter to exit with the exact index
	u8 counter= 0;
    95bc:	1a 82       	std	Y+2, r1	; 0x02
    95be:	2d c0       	rjmp	.+90     	; 0x961a <LCD_write_s32_number+0xc6>
	// Loop till the end of the number or overflow the container
	while((10 >= counter)  && (0 != copy_s32_number)){
		// Store the units in the container in the current index
		val_container[counter]= copy_s32_number%10;
    95c0:	8a 81       	ldd	r24, Y+2	; 0x02
    95c2:	08 2f       	mov	r16, r24
    95c4:	10 e0       	ldi	r17, 0x00	; 0
    95c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    95c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    95ca:	af 85       	ldd	r26, Y+15	; 0x0f
    95cc:	b8 89       	ldd	r27, Y+16	; 0x10
    95ce:	2a e0       	ldi	r18, 0x0A	; 10
    95d0:	30 e0       	ldi	r19, 0x00	; 0
    95d2:	40 e0       	ldi	r20, 0x00	; 0
    95d4:	50 e0       	ldi	r21, 0x00	; 0
    95d6:	bc 01       	movw	r22, r24
    95d8:	cd 01       	movw	r24, r26
    95da:	0e 94 9a 4c 	call	0x9934	; 0x9934 <__divmodsi4>
    95de:	dc 01       	movw	r26, r24
    95e0:	cb 01       	movw	r24, r22
    95e2:	28 2f       	mov	r18, r24
    95e4:	ce 01       	movw	r24, r28
    95e6:	03 96       	adiw	r24, 0x03	; 3
    95e8:	fc 01       	movw	r30, r24
    95ea:	e0 0f       	add	r30, r16
    95ec:	f1 1f       	adc	r31, r17
    95ee:	20 83       	st	Z, r18
		// Remove the stored unit from the original number
		copy_s32_number /= 10;
    95f0:	8d 85       	ldd	r24, Y+13	; 0x0d
    95f2:	9e 85       	ldd	r25, Y+14	; 0x0e
    95f4:	af 85       	ldd	r26, Y+15	; 0x0f
    95f6:	b8 89       	ldd	r27, Y+16	; 0x10
    95f8:	2a e0       	ldi	r18, 0x0A	; 10
    95fa:	30 e0       	ldi	r19, 0x00	; 0
    95fc:	40 e0       	ldi	r20, 0x00	; 0
    95fe:	50 e0       	ldi	r21, 0x00	; 0
    9600:	bc 01       	movw	r22, r24
    9602:	cd 01       	movw	r24, r26
    9604:	0e 94 9a 4c 	call	0x9934	; 0x9934 <__divmodsi4>
    9608:	da 01       	movw	r26, r20
    960a:	c9 01       	movw	r24, r18
    960c:	8d 87       	std	Y+13, r24	; 0x0d
    960e:	9e 87       	std	Y+14, r25	; 0x0e
    9610:	af 87       	std	Y+15, r26	; 0x0f
    9612:	b8 8b       	std	Y+16, r27	; 0x10
		// Increment the index
		counter++;
    9614:	8a 81       	ldd	r24, Y+2	; 0x02
    9616:	8f 5f       	subi	r24, 0xFF	; 255
    9618:	8a 83       	std	Y+2, r24	; 0x02
	// Create a container for storing the nunmber
	u8 val_container[10];
	// Create counter to exit with the exact index
	u8 counter= 0;
	// Loop till the end of the number or overflow the container
	while((10 >= counter)  && (0 != copy_s32_number)){
    961a:	8a 81       	ldd	r24, Y+2	; 0x02
    961c:	8b 30       	cpi	r24, 0x0B	; 11
    961e:	40 f4       	brcc	.+16     	; 0x9630 <LCD_write_s32_number+0xdc>
    9620:	8d 85       	ldd	r24, Y+13	; 0x0d
    9622:	9e 85       	ldd	r25, Y+14	; 0x0e
    9624:	af 85       	ldd	r26, Y+15	; 0x0f
    9626:	b8 89       	ldd	r27, Y+16	; 0x10
    9628:	00 97       	sbiw	r24, 0x00	; 0
    962a:	a1 05       	cpc	r26, r1
    962c:	b1 05       	cpc	r27, r1
    962e:	41 f6       	brne	.-112    	; 0x95c0 <LCD_write_s32_number+0x6c>
		copy_s32_number /= 10;
		// Increment the index
		counter++;
	}
	// Print the number in the container in reverse order
	for(u8 i= 1; i < (counter+1); i++){ //1, 2, 3, 4, 5
    9630:	81 e0       	ldi	r24, 0x01	; 1
    9632:	89 83       	std	Y+1, r24	; 0x01
    9634:	14 c0       	rjmp	.+40     	; 0x965e <LCD_write_s32_number+0x10a>
		LCD_write_char(val_container[counter-i]+'0'); //4, 3, 2, 1, 0
    9636:	8a 81       	ldd	r24, Y+2	; 0x02
    9638:	28 2f       	mov	r18, r24
    963a:	30 e0       	ldi	r19, 0x00	; 0
    963c:	89 81       	ldd	r24, Y+1	; 0x01
    963e:	88 2f       	mov	r24, r24
    9640:	90 e0       	ldi	r25, 0x00	; 0
    9642:	28 1b       	sub	r18, r24
    9644:	39 0b       	sbc	r19, r25
    9646:	ce 01       	movw	r24, r28
    9648:	03 96       	adiw	r24, 0x03	; 3
    964a:	fc 01       	movw	r30, r24
    964c:	e2 0f       	add	r30, r18
    964e:	f3 1f       	adc	r31, r19
    9650:	80 81       	ld	r24, Z
    9652:	80 5d       	subi	r24, 0xD0	; 208
    9654:	0e 94 ac 49 	call	0x9358	; 0x9358 <LCD_write_char>
		copy_s32_number /= 10;
		// Increment the index
		counter++;
	}
	// Print the number in the container in reverse order
	for(u8 i= 1; i < (counter+1); i++){ //1, 2, 3, 4, 5
    9658:	89 81       	ldd	r24, Y+1	; 0x01
    965a:	8f 5f       	subi	r24, 0xFF	; 255
    965c:	89 83       	std	Y+1, r24	; 0x01
    965e:	89 81       	ldd	r24, Y+1	; 0x01
    9660:	28 2f       	mov	r18, r24
    9662:	30 e0       	ldi	r19, 0x00	; 0
    9664:	8a 81       	ldd	r24, Y+2	; 0x02
    9666:	88 2f       	mov	r24, r24
    9668:	90 e0       	ldi	r25, 0x00	; 0
    966a:	01 96       	adiw	r24, 0x01	; 1
    966c:	28 17       	cp	r18, r24
    966e:	39 07       	cpc	r19, r25
    9670:	14 f3       	brlt	.-60     	; 0x9636 <LCD_write_s32_number+0xe2>
		LCD_write_char(val_container[counter-i]+'0'); //4, 3, 2, 1, 0
	}
}
    9672:	60 96       	adiw	r28, 0x10	; 16
    9674:	0f b6       	in	r0, 0x3f	; 63
    9676:	f8 94       	cli
    9678:	de bf       	out	0x3e, r29	; 62
    967a:	0f be       	out	0x3f, r0	; 63
    967c:	cd bf       	out	0x3d, r28	; 61
    967e:	cf 91       	pop	r28
    9680:	df 91       	pop	r29
    9682:	1f 91       	pop	r17
    9684:	0f 91       	pop	r16
    9686:	08 95       	ret

00009688 <LCD_write_float>:

void LCD_write_float(f32 copy_f32_number, u8 copy_u8_floating_point){
    9688:	ef 92       	push	r14
    968a:	ff 92       	push	r15
    968c:	0f 93       	push	r16
    968e:	1f 93       	push	r17
    9690:	df 93       	push	r29
    9692:	cf 93       	push	r28
    9694:	cd b7       	in	r28, 0x3d	; 61
    9696:	de b7       	in	r29, 0x3e	; 62
    9698:	2d 97       	sbiw	r28, 0x0d	; 13
    969a:	0f b6       	in	r0, 0x3f	; 63
    969c:	f8 94       	cli
    969e:	de bf       	out	0x3e, r29	; 62
    96a0:	0f be       	out	0x3f, r0	; 63
    96a2:	cd bf       	out	0x3d, r28	; 61
    96a4:	69 87       	std	Y+9, r22	; 0x09
    96a6:	7a 87       	std	Y+10, r23	; 0x0a
    96a8:	8b 87       	std	Y+11, r24	; 0x0b
    96aa:	9c 87       	std	Y+12, r25	; 0x0c
    96ac:	4d 87       	std	Y+13, r20	; 0x0d
	 *		copy_u8_floating_point>> Required floating point to display.
	 *	
	 *	Function does not return any values.
	 */
	// Get the decimal value
	s32 int_val = (s32)copy_f32_number;
    96ae:	69 85       	ldd	r22, Y+9	; 0x09
    96b0:	7a 85       	ldd	r23, Y+10	; 0x0a
    96b2:	8b 85       	ldd	r24, Y+11	; 0x0b
    96b4:	9c 85       	ldd	r25, Y+12	; 0x0c
    96b6:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
    96ba:	dc 01       	movw	r26, r24
    96bc:	cb 01       	movw	r24, r22
    96be:	8d 83       	std	Y+5, r24	; 0x05
    96c0:	9e 83       	std	Y+6, r25	; 0x06
    96c2:	af 83       	std	Y+7, r26	; 0x07
    96c4:	b8 87       	std	Y+8, r27	; 0x08
	// Get the floating value
	s32 float_val = (s32)((copy_f32_number - (f32)int_val) * LCD_pow(10, copy_u8_floating_point));
    96c6:	6d 81       	ldd	r22, Y+5	; 0x05
    96c8:	7e 81       	ldd	r23, Y+6	; 0x06
    96ca:	8f 81       	ldd	r24, Y+7	; 0x07
    96cc:	98 85       	ldd	r25, Y+8	; 0x08
    96ce:	0e 94 55 04 	call	0x8aa	; 0x8aa <__floatsisf>
    96d2:	9b 01       	movw	r18, r22
    96d4:	ac 01       	movw	r20, r24
    96d6:	69 85       	ldd	r22, Y+9	; 0x09
    96d8:	7a 85       	ldd	r23, Y+10	; 0x0a
    96da:	8b 85       	ldd	r24, Y+11	; 0x0b
    96dc:	9c 85       	ldd	r25, Y+12	; 0x0c
    96de:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    96e2:	dc 01       	movw	r26, r24
    96e4:	cb 01       	movw	r24, r22
    96e6:	7c 01       	movw	r14, r24
    96e8:	8d 01       	movw	r16, r26
    96ea:	8a e0       	ldi	r24, 0x0A	; 10
    96ec:	6d 85       	ldd	r22, Y+13	; 0x0d
    96ee:	0e 94 d6 29 	call	0x53ac	; 0x53ac <LCD_pow>
    96f2:	dc 01       	movw	r26, r24
    96f4:	cb 01       	movw	r24, r22
    96f6:	bc 01       	movw	r22, r24
    96f8:	cd 01       	movw	r24, r26
    96fa:	0e 94 55 04 	call	0x8aa	; 0x8aa <__floatsisf>
    96fe:	9b 01       	movw	r18, r22
    9700:	ac 01       	movw	r20, r24
    9702:	c8 01       	movw	r24, r16
    9704:	b7 01       	movw	r22, r14
    9706:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    970a:	dc 01       	movw	r26, r24
    970c:	cb 01       	movw	r24, r22
    970e:	bc 01       	movw	r22, r24
    9710:	cd 01       	movw	r24, r26
    9712:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
    9716:	dc 01       	movw	r26, r24
    9718:	cb 01       	movw	r24, r22
    971a:	89 83       	std	Y+1, r24	; 0x01
    971c:	9a 83       	std	Y+2, r25	; 0x02
    971e:	ab 83       	std	Y+3, r26	; 0x03
    9720:	bc 83       	std	Y+4, r27	; 0x04
	// Print the decimal value
	LCD_write_s32_number(int_val);
    9722:	8d 81       	ldd	r24, Y+5	; 0x05
    9724:	9e 81       	ldd	r25, Y+6	; 0x06
    9726:	af 81       	ldd	r26, Y+7	; 0x07
    9728:	b8 85       	ldd	r27, Y+8	; 0x08
    972a:	bc 01       	movw	r22, r24
    972c:	cd 01       	movw	r24, r26
    972e:	0e 94 aa 4a 	call	0x9554	; 0x9554 <LCD_write_s32_number>
	// Print the decimal point
	LCD_write_char('.');
    9732:	8e e2       	ldi	r24, 0x2E	; 46
    9734:	0e 94 ac 49 	call	0x9358	; 0x9358 <LCD_write_char>
	// Print the floating value after making sure its postive
	LCD_write_s32_number((float_val&(~(1<<7))));
    9738:	89 81       	ldd	r24, Y+1	; 0x01
    973a:	9a 81       	ldd	r25, Y+2	; 0x02
    973c:	ab 81       	ldd	r26, Y+3	; 0x03
    973e:	bc 81       	ldd	r27, Y+4	; 0x04
    9740:	8f 77       	andi	r24, 0x7F	; 127
    9742:	bc 01       	movw	r22, r24
    9744:	cd 01       	movw	r24, r26
    9746:	0e 94 aa 4a 	call	0x9554	; 0x9554 <LCD_write_s32_number>
	//LCD_wtire_s32_number((float_val > 0) ? float_val : (-1*float_val));
}
    974a:	2d 96       	adiw	r28, 0x0d	; 13
    974c:	0f b6       	in	r0, 0x3f	; 63
    974e:	f8 94       	cli
    9750:	de bf       	out	0x3e, r29	; 62
    9752:	0f be       	out	0x3f, r0	; 63
    9754:	cd bf       	out	0x3d, r28	; 61
    9756:	cf 91       	pop	r28
    9758:	df 91       	pop	r29
    975a:	1f 91       	pop	r17
    975c:	0f 91       	pop	r16
    975e:	ff 90       	pop	r15
    9760:	ef 90       	pop	r14
    9762:	08 95       	ret

00009764 <keypad_init>:

//Global variables


/* Implementing of the driver functions */
void keypad_init(void){
    9764:	df 93       	push	r29
    9766:	cf 93       	push	r28
    9768:	00 d0       	rcall	.+0      	; 0x976a <keypad_init+0x6>
    976a:	cd b7       	in	r28, 0x3d	; 61
    976c:	de b7       	in	r29, 0x3e	; 62
	 *	Also Setting configurations in the config.h file is essential before use
	 *
	 *	No return from the function
	 */
	// Set the direction of the columns as output
	for(u8 col = start_col; col < no_columns; col++){
    976e:	1a 82       	std	Y+2, r1	; 0x02
    9770:	0c c0       	rjmp	.+24     	; 0x978a <keypad_init+0x26>
		DIO_void_set_pin_dir(port_keypad_, col, OUTPUT);
    9772:	80 e0       	ldi	r24, 0x00	; 0
    9774:	6a 81       	ldd	r22, Y+2	; 0x02
    9776:	41 e0       	ldi	r20, 0x01	; 1
    9778:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <DIO_void_set_pin_dir>
		DIO_void_set_pin(port_keypad_, col);
    977c:	80 e0       	ldi	r24, 0x00	; 0
    977e:	6a 81       	ldd	r22, Y+2	; 0x02
    9780:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
	 *	Also Setting configurations in the config.h file is essential before use
	 *
	 *	No return from the function
	 */
	// Set the direction of the columns as output
	for(u8 col = start_col; col < no_columns; col++){
    9784:	8a 81       	ldd	r24, Y+2	; 0x02
    9786:	8f 5f       	subi	r24, 0xFF	; 255
    9788:	8a 83       	std	Y+2, r24	; 0x02
    978a:	8a 81       	ldd	r24, Y+2	; 0x02
    978c:	84 30       	cpi	r24, 0x04	; 4
    978e:	88 f3       	brcs	.-30     	; 0x9772 <keypad_init+0xe>
		DIO_void_set_pin_dir(port_keypad_, col, OUTPUT);
		DIO_void_set_pin(port_keypad_, col);
		}
	// set the direction of the rows as input pullUp
	for(u8 row = start_row; row < (start_row+no_rows); row++){
    9790:	84 e0       	ldi	r24, 0x04	; 4
    9792:	89 83       	std	Y+1, r24	; 0x01
    9794:	07 c0       	rjmp	.+14     	; 0x97a4 <keypad_init+0x40>
		DIO_void_set_pin_in_pullUP(port_keypad_, row);
    9796:	80 e0       	ldi	r24, 0x00	; 0
    9798:	69 81       	ldd	r22, Y+1	; 0x01
    979a:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <DIO_void_set_pin_in_pullUP>
	for(u8 col = start_col; col < no_columns; col++){
		DIO_void_set_pin_dir(port_keypad_, col, OUTPUT);
		DIO_void_set_pin(port_keypad_, col);
		}
	// set the direction of the rows as input pullUp
	for(u8 row = start_row; row < (start_row+no_rows); row++){
    979e:	89 81       	ldd	r24, Y+1	; 0x01
    97a0:	8f 5f       	subi	r24, 0xFF	; 255
    97a2:	89 83       	std	Y+1, r24	; 0x01
    97a4:	89 81       	ldd	r24, Y+1	; 0x01
    97a6:	88 30       	cpi	r24, 0x08	; 8
    97a8:	b0 f3       	brcs	.-20     	; 0x9796 <keypad_init+0x32>
		DIO_void_set_pin_in_pullUP(port_keypad_, row);
	}
}
    97aa:	0f 90       	pop	r0
    97ac:	0f 90       	pop	r0
    97ae:	cf 91       	pop	r28
    97b0:	df 91       	pop	r29
    97b2:	08 95       	ret

000097b4 <keypad_read>:


s8 keypad_read(void){
    97b4:	df 93       	push	r29
    97b6:	cf 93       	push	r28
    97b8:	00 d0       	rcall	.+0      	; 0x97ba <keypad_read+0x6>
    97ba:	0f 92       	push	r0
    97bc:	cd b7       	in	r28, 0x3d	; 61
    97be:	de b7       	in	r29, 0x3e	; 62
	 *	as it will not return the higher order key if two keys are pressed as the same time.
	 *	Ex: 1 and 6 is pressed >> 1 is lower in order so the return will be value 1, and at the same time,
	 *	6 will not be returned is the two keys were released at the same time.
	 */
	// Loop on each columns
	for(u8 COL = start_col; COL < no_columns; COL++){
    97c0:	1a 82       	std	Y+2, r1	; 0x02
    97c2:	36 c0       	rjmp	.+108    	; 0x9830 <keypad_read+0x7c>
		// turn on the column to check if thier is pressed button
		DIO_void_clear_pin(port_keypad_, COL);
    97c4:	80 e0       	ldi	r24, 0x00	; 0
    97c6:	6a 81       	ldd	r22, Y+2	; 0x02
    97c8:	0e 94 09 27 	call	0x4e12	; 0x4e12 <DIO_void_clear_pin>
		for(u8 ROW = start_row; ROW < (start_row+no_rows); ROW++){
    97cc:	84 e0       	ldi	r24, 0x04	; 4
    97ce:	89 83       	std	Y+1, r24	; 0x01
    97d0:	25 c0       	rjmp	.+74     	; 0x981c <keypad_read+0x68>
			//check row value for the selected column
			if(LOW == DIO_u8_get_pin(port_keypad_, ROW)){
    97d2:	80 e0       	ldi	r24, 0x00	; 0
    97d4:	69 81       	ldd	r22, Y+1	; 0x01
    97d6:	0e 94 01 28 	call	0x5002	; 0x5002 <DIO_u8_get_pin>
    97da:	88 23       	and	r24, r24
    97dc:	e1 f4       	brne	.+56     	; 0x9816 <keypad_read+0x62>
				//return selected row value after the key is unpressed
				while(LOW == DIO_u8_get_pin(port_keypad_, ROW));
    97de:	80 e0       	ldi	r24, 0x00	; 0
    97e0:	69 81       	ldd	r22, Y+1	; 0x01
    97e2:	0e 94 01 28 	call	0x5002	; 0x5002 <DIO_u8_get_pin>
    97e6:	88 23       	and	r24, r24
    97e8:	d1 f3       	breq	.-12     	; 0x97de <keypad_read+0x2a>
				return keypad_map[ROW-start_row][COL];
    97ea:	89 81       	ldd	r24, Y+1	; 0x01
    97ec:	88 2f       	mov	r24, r24
    97ee:	90 e0       	ldi	r25, 0x00	; 0
    97f0:	ac 01       	movw	r20, r24
    97f2:	44 50       	subi	r20, 0x04	; 4
    97f4:	50 40       	sbci	r21, 0x00	; 0
    97f6:	8a 81       	ldd	r24, Y+2	; 0x02
    97f8:	28 2f       	mov	r18, r24
    97fa:	30 e0       	ldi	r19, 0x00	; 0
    97fc:	ca 01       	movw	r24, r20
    97fe:	88 0f       	add	r24, r24
    9800:	99 1f       	adc	r25, r25
    9802:	88 0f       	add	r24, r24
    9804:	99 1f       	adc	r25, r25
    9806:	82 0f       	add	r24, r18
    9808:	93 1f       	adc	r25, r19
    980a:	fc 01       	movw	r30, r24
    980c:	e8 5f       	subi	r30, 0xF8	; 248
    980e:	fd 4f       	sbci	r31, 0xFD	; 253
    9810:	80 81       	ld	r24, Z
    9812:	8b 83       	std	Y+3, r24	; 0x03
    9814:	12 c0       	rjmp	.+36     	; 0x983a <keypad_read+0x86>
	 */
	// Loop on each columns
	for(u8 COL = start_col; COL < no_columns; COL++){
		// turn on the column to check if thier is pressed button
		DIO_void_clear_pin(port_keypad_, COL);
		for(u8 ROW = start_row; ROW < (start_row+no_rows); ROW++){
    9816:	89 81       	ldd	r24, Y+1	; 0x01
    9818:	8f 5f       	subi	r24, 0xFF	; 255
    981a:	89 83       	std	Y+1, r24	; 0x01
    981c:	89 81       	ldd	r24, Y+1	; 0x01
    981e:	88 30       	cpi	r24, 0x08	; 8
    9820:	c0 f2       	brcs	.-80     	; 0x97d2 <keypad_read+0x1e>
				while(LOW == DIO_u8_get_pin(port_keypad_, ROW));
				return keypad_map[ROW-start_row][COL];
			}
		}
		// Turn off the column if no key was pressed
		DIO_void_set_pin(port_keypad_, COL);
    9822:	80 e0       	ldi	r24, 0x00	; 0
    9824:	6a 81       	ldd	r22, Y+2	; 0x02
    9826:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <DIO_void_set_pin>
	 *	as it will not return the higher order key if two keys are pressed as the same time.
	 *	Ex: 1 and 6 is pressed >> 1 is lower in order so the return will be value 1, and at the same time,
	 *	6 will not be returned is the two keys were released at the same time.
	 */
	// Loop on each columns
	for(u8 COL = start_col; COL < no_columns; COL++){
    982a:	8a 81       	ldd	r24, Y+2	; 0x02
    982c:	8f 5f       	subi	r24, 0xFF	; 255
    982e:	8a 83       	std	Y+2, r24	; 0x02
    9830:	8a 81       	ldd	r24, Y+2	; 0x02
    9832:	84 30       	cpi	r24, 0x04	; 4
    9834:	38 f2       	brcs	.-114    	; 0x97c4 <keypad_read+0x10>
		}
		// Turn off the column if no key was pressed
		DIO_void_set_pin(port_keypad_, COL);
	}
	// return -1 if no buttons were pressed
	return -1;
    9836:	8f ef       	ldi	r24, 0xFF	; 255
    9838:	8b 83       	std	Y+3, r24	; 0x03
    983a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    983c:	0f 90       	pop	r0
    983e:	0f 90       	pop	r0
    9840:	0f 90       	pop	r0
    9842:	cf 91       	pop	r28
    9844:	df 91       	pop	r29
    9846:	08 95       	ret

00009848 <keypad_set_map>:

void keypad_set_map(s8* copy_pu8_new_keypad_map){
    9848:	df 93       	push	r29
    984a:	cf 93       	push	r28
    984c:	00 d0       	rcall	.+0      	; 0x984e <keypad_set_map+0x6>
    984e:	00 d0       	rcall	.+0      	; 0x9850 <keypad_set_map+0x8>
    9850:	cd b7       	in	r28, 0x3d	; 61
    9852:	de b7       	in	r29, 0x3e	; 62
    9854:	9c 83       	std	Y+4, r25	; 0x04
    9856:	8b 83       	std	Y+3, r24	; 0x03
	 *									   -> EX: R= 3, C= 4 means its length Should be equal 12
	 *
	 *	No return from the function
	 */
	// Loop on each column
	for(u8 COL = start_; COL < no_columns; COL++){
    9858:	1a 82       	std	Y+2, r1	; 0x02
    985a:	2f c0       	rjmp	.+94     	; 0x98ba <keypad_set_map+0x72>
		// Loop on each row
		for(u8 ROW = start_; ROW < no_rows; ROW++){
    985c:	19 82       	std	Y+1, r1	; 0x01
    985e:	27 c0       	rjmp	.+78     	; 0x98ae <keypad_set_map+0x66>
			// Assign the the new value of the key
			keypad_map[ROW][COL] = *(copy_pu8_new_keypad_map+(ROW*no_columns)+(COL));
    9860:	89 81       	ldd	r24, Y+1	; 0x01
    9862:	48 2f       	mov	r20, r24
    9864:	50 e0       	ldi	r21, 0x00	; 0
    9866:	8a 81       	ldd	r24, Y+2	; 0x02
    9868:	68 2f       	mov	r22, r24
    986a:	70 e0       	ldi	r23, 0x00	; 0
    986c:	89 81       	ldd	r24, Y+1	; 0x01
    986e:	88 2f       	mov	r24, r24
    9870:	90 e0       	ldi	r25, 0x00	; 0
    9872:	88 0f       	add	r24, r24
    9874:	99 1f       	adc	r25, r25
    9876:	88 0f       	add	r24, r24
    9878:	99 1f       	adc	r25, r25
    987a:	9c 01       	movw	r18, r24
    987c:	8a 81       	ldd	r24, Y+2	; 0x02
    987e:	88 2f       	mov	r24, r24
    9880:	90 e0       	ldi	r25, 0x00	; 0
    9882:	28 0f       	add	r18, r24
    9884:	39 1f       	adc	r19, r25
    9886:	8b 81       	ldd	r24, Y+3	; 0x03
    9888:	9c 81       	ldd	r25, Y+4	; 0x04
    988a:	fc 01       	movw	r30, r24
    988c:	e2 0f       	add	r30, r18
    988e:	f3 1f       	adc	r31, r19
    9890:	20 81       	ld	r18, Z
    9892:	ca 01       	movw	r24, r20
    9894:	88 0f       	add	r24, r24
    9896:	99 1f       	adc	r25, r25
    9898:	88 0f       	add	r24, r24
    989a:	99 1f       	adc	r25, r25
    989c:	86 0f       	add	r24, r22
    989e:	97 1f       	adc	r25, r23
    98a0:	fc 01       	movw	r30, r24
    98a2:	e8 5f       	subi	r30, 0xF8	; 248
    98a4:	fd 4f       	sbci	r31, 0xFD	; 253
    98a6:	20 83       	st	Z, r18
	 *	No return from the function
	 */
	// Loop on each column
	for(u8 COL = start_; COL < no_columns; COL++){
		// Loop on each row
		for(u8 ROW = start_; ROW < no_rows; ROW++){
    98a8:	89 81       	ldd	r24, Y+1	; 0x01
    98aa:	8f 5f       	subi	r24, 0xFF	; 255
    98ac:	89 83       	std	Y+1, r24	; 0x01
    98ae:	89 81       	ldd	r24, Y+1	; 0x01
    98b0:	84 30       	cpi	r24, 0x04	; 4
    98b2:	b0 f2       	brcs	.-84     	; 0x9860 <keypad_set_map+0x18>
	 *									   -> EX: R= 3, C= 4 means its length Should be equal 12
	 *
	 *	No return from the function
	 */
	// Loop on each column
	for(u8 COL = start_; COL < no_columns; COL++){
    98b4:	8a 81       	ldd	r24, Y+2	; 0x02
    98b6:	8f 5f       	subi	r24, 0xFF	; 255
    98b8:	8a 83       	std	Y+2, r24	; 0x02
    98ba:	8a 81       	ldd	r24, Y+2	; 0x02
    98bc:	84 30       	cpi	r24, 0x04	; 4
    98be:	70 f2       	brcs	.-100    	; 0x985c <keypad_set_map+0x14>
		for(u8 ROW = start_; ROW < no_rows; ROW++){
			// Assign the the new value of the key
			keypad_map[ROW][COL] = *(copy_pu8_new_keypad_map+(ROW*no_columns)+(COL));
		}
	}
}
    98c0:	0f 90       	pop	r0
    98c2:	0f 90       	pop	r0
    98c4:	0f 90       	pop	r0
    98c6:	0f 90       	pop	r0
    98c8:	cf 91       	pop	r28
    98ca:	df 91       	pop	r29
    98cc:	08 95       	ret

000098ce <__mulsi3>:
    98ce:	62 9f       	mul	r22, r18
    98d0:	d0 01       	movw	r26, r0
    98d2:	73 9f       	mul	r23, r19
    98d4:	f0 01       	movw	r30, r0
    98d6:	82 9f       	mul	r24, r18
    98d8:	e0 0d       	add	r30, r0
    98da:	f1 1d       	adc	r31, r1
    98dc:	64 9f       	mul	r22, r20
    98de:	e0 0d       	add	r30, r0
    98e0:	f1 1d       	adc	r31, r1
    98e2:	92 9f       	mul	r25, r18
    98e4:	f0 0d       	add	r31, r0
    98e6:	83 9f       	mul	r24, r19
    98e8:	f0 0d       	add	r31, r0
    98ea:	74 9f       	mul	r23, r20
    98ec:	f0 0d       	add	r31, r0
    98ee:	65 9f       	mul	r22, r21
    98f0:	f0 0d       	add	r31, r0
    98f2:	99 27       	eor	r25, r25
    98f4:	72 9f       	mul	r23, r18
    98f6:	b0 0d       	add	r27, r0
    98f8:	e1 1d       	adc	r30, r1
    98fa:	f9 1f       	adc	r31, r25
    98fc:	63 9f       	mul	r22, r19
    98fe:	b0 0d       	add	r27, r0
    9900:	e1 1d       	adc	r30, r1
    9902:	f9 1f       	adc	r31, r25
    9904:	bd 01       	movw	r22, r26
    9906:	cf 01       	movw	r24, r30
    9908:	11 24       	eor	r1, r1
    990a:	08 95       	ret

0000990c <__udivmodhi4>:
    990c:	aa 1b       	sub	r26, r26
    990e:	bb 1b       	sub	r27, r27
    9910:	51 e1       	ldi	r21, 0x11	; 17
    9912:	07 c0       	rjmp	.+14     	; 0x9922 <__udivmodhi4_ep>

00009914 <__udivmodhi4_loop>:
    9914:	aa 1f       	adc	r26, r26
    9916:	bb 1f       	adc	r27, r27
    9918:	a6 17       	cp	r26, r22
    991a:	b7 07       	cpc	r27, r23
    991c:	10 f0       	brcs	.+4      	; 0x9922 <__udivmodhi4_ep>
    991e:	a6 1b       	sub	r26, r22
    9920:	b7 0b       	sbc	r27, r23

00009922 <__udivmodhi4_ep>:
    9922:	88 1f       	adc	r24, r24
    9924:	99 1f       	adc	r25, r25
    9926:	5a 95       	dec	r21
    9928:	a9 f7       	brne	.-22     	; 0x9914 <__udivmodhi4_loop>
    992a:	80 95       	com	r24
    992c:	90 95       	com	r25
    992e:	bc 01       	movw	r22, r24
    9930:	cd 01       	movw	r24, r26
    9932:	08 95       	ret

00009934 <__divmodsi4>:
    9934:	97 fb       	bst	r25, 7
    9936:	09 2e       	mov	r0, r25
    9938:	05 26       	eor	r0, r21
    993a:	0e d0       	rcall	.+28     	; 0x9958 <__divmodsi4_neg1>
    993c:	57 fd       	sbrc	r21, 7
    993e:	04 d0       	rcall	.+8      	; 0x9948 <__divmodsi4_neg2>
    9940:	14 d0       	rcall	.+40     	; 0x996a <__udivmodsi4>
    9942:	0a d0       	rcall	.+20     	; 0x9958 <__divmodsi4_neg1>
    9944:	00 1c       	adc	r0, r0
    9946:	38 f4       	brcc	.+14     	; 0x9956 <__divmodsi4_exit>

00009948 <__divmodsi4_neg2>:
    9948:	50 95       	com	r21
    994a:	40 95       	com	r20
    994c:	30 95       	com	r19
    994e:	21 95       	neg	r18
    9950:	3f 4f       	sbci	r19, 0xFF	; 255
    9952:	4f 4f       	sbci	r20, 0xFF	; 255
    9954:	5f 4f       	sbci	r21, 0xFF	; 255

00009956 <__divmodsi4_exit>:
    9956:	08 95       	ret

00009958 <__divmodsi4_neg1>:
    9958:	f6 f7       	brtc	.-4      	; 0x9956 <__divmodsi4_exit>
    995a:	90 95       	com	r25
    995c:	80 95       	com	r24
    995e:	70 95       	com	r23
    9960:	61 95       	neg	r22
    9962:	7f 4f       	sbci	r23, 0xFF	; 255
    9964:	8f 4f       	sbci	r24, 0xFF	; 255
    9966:	9f 4f       	sbci	r25, 0xFF	; 255
    9968:	08 95       	ret

0000996a <__udivmodsi4>:
    996a:	a1 e2       	ldi	r26, 0x21	; 33
    996c:	1a 2e       	mov	r1, r26
    996e:	aa 1b       	sub	r26, r26
    9970:	bb 1b       	sub	r27, r27
    9972:	fd 01       	movw	r30, r26
    9974:	0d c0       	rjmp	.+26     	; 0x9990 <__udivmodsi4_ep>

00009976 <__udivmodsi4_loop>:
    9976:	aa 1f       	adc	r26, r26
    9978:	bb 1f       	adc	r27, r27
    997a:	ee 1f       	adc	r30, r30
    997c:	ff 1f       	adc	r31, r31
    997e:	a2 17       	cp	r26, r18
    9980:	b3 07       	cpc	r27, r19
    9982:	e4 07       	cpc	r30, r20
    9984:	f5 07       	cpc	r31, r21
    9986:	20 f0       	brcs	.+8      	; 0x9990 <__udivmodsi4_ep>
    9988:	a2 1b       	sub	r26, r18
    998a:	b3 0b       	sbc	r27, r19
    998c:	e4 0b       	sbc	r30, r20
    998e:	f5 0b       	sbc	r31, r21

00009990 <__udivmodsi4_ep>:
    9990:	66 1f       	adc	r22, r22
    9992:	77 1f       	adc	r23, r23
    9994:	88 1f       	adc	r24, r24
    9996:	99 1f       	adc	r25, r25
    9998:	1a 94       	dec	r1
    999a:	69 f7       	brne	.-38     	; 0x9976 <__udivmodsi4_loop>
    999c:	60 95       	com	r22
    999e:	70 95       	com	r23
    99a0:	80 95       	com	r24
    99a2:	90 95       	com	r25
    99a4:	9b 01       	movw	r18, r22
    99a6:	ac 01       	movw	r20, r24
    99a8:	bd 01       	movw	r22, r26
    99aa:	cf 01       	movw	r24, r30
    99ac:	08 95       	ret

000099ae <__prologue_saves__>:
    99ae:	2f 92       	push	r2
    99b0:	3f 92       	push	r3
    99b2:	4f 92       	push	r4
    99b4:	5f 92       	push	r5
    99b6:	6f 92       	push	r6
    99b8:	7f 92       	push	r7
    99ba:	8f 92       	push	r8
    99bc:	9f 92       	push	r9
    99be:	af 92       	push	r10
    99c0:	bf 92       	push	r11
    99c2:	cf 92       	push	r12
    99c4:	df 92       	push	r13
    99c6:	ef 92       	push	r14
    99c8:	ff 92       	push	r15
    99ca:	0f 93       	push	r16
    99cc:	1f 93       	push	r17
    99ce:	cf 93       	push	r28
    99d0:	df 93       	push	r29
    99d2:	cd b7       	in	r28, 0x3d	; 61
    99d4:	de b7       	in	r29, 0x3e	; 62
    99d6:	ca 1b       	sub	r28, r26
    99d8:	db 0b       	sbc	r29, r27
    99da:	0f b6       	in	r0, 0x3f	; 63
    99dc:	f8 94       	cli
    99de:	de bf       	out	0x3e, r29	; 62
    99e0:	0f be       	out	0x3f, r0	; 63
    99e2:	cd bf       	out	0x3d, r28	; 61
    99e4:	09 94       	ijmp

000099e6 <__epilogue_restores__>:
    99e6:	2a 88       	ldd	r2, Y+18	; 0x12
    99e8:	39 88       	ldd	r3, Y+17	; 0x11
    99ea:	48 88       	ldd	r4, Y+16	; 0x10
    99ec:	5f 84       	ldd	r5, Y+15	; 0x0f
    99ee:	6e 84       	ldd	r6, Y+14	; 0x0e
    99f0:	7d 84       	ldd	r7, Y+13	; 0x0d
    99f2:	8c 84       	ldd	r8, Y+12	; 0x0c
    99f4:	9b 84       	ldd	r9, Y+11	; 0x0b
    99f6:	aa 84       	ldd	r10, Y+10	; 0x0a
    99f8:	b9 84       	ldd	r11, Y+9	; 0x09
    99fa:	c8 84       	ldd	r12, Y+8	; 0x08
    99fc:	df 80       	ldd	r13, Y+7	; 0x07
    99fe:	ee 80       	ldd	r14, Y+6	; 0x06
    9a00:	fd 80       	ldd	r15, Y+5	; 0x05
    9a02:	0c 81       	ldd	r16, Y+4	; 0x04
    9a04:	1b 81       	ldd	r17, Y+3	; 0x03
    9a06:	aa 81       	ldd	r26, Y+2	; 0x02
    9a08:	b9 81       	ldd	r27, Y+1	; 0x01
    9a0a:	ce 0f       	add	r28, r30
    9a0c:	d1 1d       	adc	r29, r1
    9a0e:	0f b6       	in	r0, 0x3f	; 63
    9a10:	f8 94       	cli
    9a12:	de bf       	out	0x3e, r29	; 62
    9a14:	0f be       	out	0x3f, r0	; 63
    9a16:	cd bf       	out	0x3d, r28	; 61
    9a18:	ed 01       	movw	r28, r26
    9a1a:	08 95       	ret

00009a1c <memcpy>:
    9a1c:	fb 01       	movw	r30, r22
    9a1e:	dc 01       	movw	r26, r24
    9a20:	02 c0       	rjmp	.+4      	; 0x9a26 <memcpy+0xa>
    9a22:	01 90       	ld	r0, Z+
    9a24:	0d 92       	st	X+, r0
    9a26:	41 50       	subi	r20, 0x01	; 1
    9a28:	50 40       	sbci	r21, 0x00	; 0
    9a2a:	d8 f7       	brcc	.-10     	; 0x9a22 <memcpy+0x6>
    9a2c:	08 95       	ret

00009a2e <_exit>:
    9a2e:	f8 94       	cli

00009a30 <__stop_program>:
    9a30:	ff cf       	rjmp	.-2      	; 0x9a30 <__stop_program>
